[{"id":"f63fd983001a548ddde94851f2bab33a","title":"Netty源码分析","content":"本文将介绍 Netty，Java 平台上使用最广泛的 NIO 包，它是对 JDK 中的 NIO 实现的一层封装，让我们能更方便地开发 NIO 程序。其实，Netty 不仅仅是 NIO 吧，但是，基本上大家都冲着 NIO 来的。\n\n本文只介绍 TCP 相关的内容，Netty 对于其他协议的支持，不在本文的讨论范围内。\n和并发包的源码分析不一样，我不可能一行一行源码说，所以有些异常分支是会直接略过，除非我觉得需要介绍。\nNetty 源码一直在更新，各版本之间有些差异，我是按照 4.1.25.Final 版本来进行介绍的。\n\n建议初学者在看完本文以后，可以去翻翻《Netty In Action》，网上也可以找到中文文字版的。\n准备学习源码，一开始肯定是准备环境。\n我喜欢用 maven，也喜欢 Spring Boot，所以我一般先到 https://start.spring.io/ 准备一个最简单的脚手架。\n10 秒搞定脚手架，然后就是导入到 Intellij 中，如果用新版本的 Spring Boot，可能还需要等待下载依赖，期间打开 https://mvnrepository.com/ 搜索马上要用到的 maven 依赖。\nNetty 分为好些模块，有 netty-handler、netty-buffer、netty-transport、netty-common 等等，也有一个 netty-all，它包含了所有的模块。\n既然我们是源码分析，那么自然是用一个最简单的。netty-all 不是最好的选择，netty-example 才是：\n&lt;dependency>\n   &lt;groupId>io.netty&lt;/groupId>\n   &lt;artifactId>netty-example&lt;/artifactId>\n   &lt;version>4.1.25.Final&lt;/version>\n&lt;/dependency>\n\n它不仅可以解决我们的依赖，而且 example 里面的示例非常适合我们学习使用。\n\nEcho 例子Netty 作为 NIO 的库，自然既可以作为服务端接受请求，也可以作为客户端发起请求。使用 Netty 开发客户端或服务端都是非常简单的，Netty 做了很好的封装，我们通常只要开发一个或多个 handler 用来处理我们的自定义逻辑就可以了。\n下面，我们来看一个经常会见到的例子，它叫 Echo，也就是回声，客户端传过去什么值，服务端原样返回什么值。\n\n\n\n\n\n\n\n\n\n打开 netty-example 的源码，把 echo 包下面的代码复制出来玩一玩。\n\n\n\n\n\n\n\n\n\n\n左边是服务端代码，右边是客户端代码。\n上面的代码基本就是模板代码，每次使用都是这一个套路，唯一需要我们开发的部分是 handler(…) 和 childHandler(…) 方法中指定的各个 handler，如 **EchoServerHandler** 和 **EchoClientHandler**，当然 Netty 源码也给我们提供了很多的 handler，比如上面的 LoggingHandler，它就是 Netty 源码中为我们提供的，需要的时候直接拿过来用就好了。\n我们先来看一下上述代码中涉及到的一些内容：\n\nServerBootstrap 类用于创建服务端实例，Bootstrap 用于创建客户端实例。 \n\n两个 EventLoopGroup ：bossGroup 和 workerGroup，它们涉及的是 Netty 的线程模型，可以看到服务端有两个 group，而客户端只有一个，它们就是 Netty 中的线程池。 \n\nNetty 中的 Channel，没有直接使用 Java 原生的 ServerSocketChannel 和 SocketChannel，而是包装了 NioServerSocketChannel 和 NioSocketChannel 与之对应。  \n\n\n\n\n\n\n\n\n\n当然，也有对其他协议的支持，如支持 UDP 协议的 NioDatagramChannel，本文只关心 TCP 相关的。\n\n左边 handler(…) 方法指定了一个 handler（LoggingHandler），这个 handler 是给服务端收到新的请求的时候处理用的。右边 handler(...) 方法指定了客户端处理请求过程中需要使用的 handlers。  \n\n\n\n\n\n\n\n\n\n如果你想在 EchoServer 中也指定多个 handler，也可以像右边的 EchoClient 一样使用 ChannelInitializer\n\n左边 childHandler(…) 指定了 childHandler，这边的 handlers 是给新创建的连接用的，我们知道服务端 ServerSocketChannel 在 accept 一个连接以后，需要创建 SocketChannel 的实例，childHandler(…) 中设置的 handler 就是用于处理新创建的 SocketChannel 的，而不是用来处理 ServerSocketChannel 实例的。 \n\npipeline：handler 可以指定多个（需要上面的 ChannelInitializer 类辅助），它们会组成了一个 pipeline，它们其实就类似拦截器的概念，现在只要记住一点，每个 NioSocketChannel 或 NioServerSocketChannel 实例内部都会有一个 pipeline 实例。pipeline 中还涉及到 handler 的执行顺序。 \n\nChannelFuture：这个涉及到 Netty 中的异步编程，和 JDK 中的 Future 接口类似。\n\n\n对于不了解 Netty 的读者，也不要有什么压力，我会一一介绍它们，本文主要面向新手，我觉得比较难理解或比较重要的部分，会花比较大的篇幅来介绍清楚。\n上面的源码中没有展示消息发送和消息接收的处理，此部分我会在介绍完上面的这些内容以后再进行介绍。\n\n源码分析1.网络操作抽象类： Channel初始化 ChannelChannel 接口是 Netty 对网络操作抽象类。通过 Channel 我们可以进行 I&#x2F;O 操作。\n一旦客户端成功连接服务端，就会新建一个 Channel 同该用户端进行绑定，示例代码如下：\n//  通过 Bootstrap 的 connect 方法连接到服务端\npublic Channel doConnect(InetSocketAddress inetSocketAddress) &#123;\n     CompletableFuture&lt;Channel> completableFuture = new CompletableFuture&lt;>();\n     bootstrap.connect(inetSocketAddress).addListener((ChannelFutureListener) future -> &#123;\n         if (future.isSuccess()) &#123;\n             completableFuture.complete(future.channel());\n         &#125; else &#123;\n             throw new IllegalStateException();\n         &#125;\n     &#125;);\n     return completableFuture.get();\n &#125;\n\n比较常用的Channel接口实现类是 ：\n\nNioServerSocketChannel（服务端）\nNioSocketChannel（客户端）\n\n这两个 Channel 可以和 BIO 编程模型中的ServerSocket以及Socket两个概念对应上。\n这节我们来看看 NioSocketChannel 是怎么和 JDK 底层的 SocketChannel 联系在一起的，它们是一对一的关系。NioServerSocketChannel 和 ServerSocketChannel 同理，也是一对一的关系。\n\n在 Bootstrap（客户端） 和 ServerBootstrap（服务端） 的启动过程中都会调用 channel(…) 方法：\n\n下面，我们来看 channel(…) 方法的源码：\n// AbstractBootstrap\npublic B channel(Class&lt;? extends C> channelClass) &#123;\n    if (channelClass == null) &#123;\n        throw new NullPointerException(\"channelClass\");\n    &#125;\n    return channelFactory(new ReflectiveChannelFactory&lt;C>(channelClass));\n&#125;\n\n我们可以看到，这个方法只是设置了 channelFactory 为 ReflectiveChannelFactory 的一个实例，然后我们看下这里的 ReflectiveChannelFactory 到底是什么：\n\n**newChannel()** 方法是 ChannelFactory 接口中的唯一方法，工厂模式 大家都很熟悉。我们可以看到，ReflectiveChannelFactory#newChannel() 方法中使用了反射调用 Channel 的无参构造方法来创建 Channel，我们只要知道，ChannelFactory 的 newChannel() 方法什么时候会被调用就可以了。\n\n对于 NioSocketChannel，由于它充当客户端的功能，它的创建时机在 connect(…) 的时候；\n对于 NioServerSocketChannel 来说，它充当服务端功能，它的创建时机在绑定端口 bind(…) 的时候。\n\n接下来，我们来简单追踪下充当客户端的 Bootstrap 中 NioSocketChannel 的创建过程，看看 NioSocketChannel 是怎么和 JDK 中的 SocketChannel 关联在一起的：\n// Bootstrap\npublic ChannelFuture connect(String inetHost, int inetPort) &#123;\n    return connect(InetSocketAddress.createUnresolved(inetHost, inetPort));\n&#125;\n\n然后再往里看，到这个方法：\npublic ChannelFuture connect(SocketAddress remoteAddress) &#123;\n    if (remoteAddress == null) &#123;\n        throw new NullPointerException(\"remoteAddress\");\n    // validate 只是校验一下各个参数是不是正确设置了\n    validate();\n    return doResolveAndConnect(remoteAddress, config.localAddress());\n&#125;\n\n继续：\n// 再往里就到这里了\nprivate ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;\n    // 我们要说的部分在这里\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n    ......\n&#125;\n\n然后，我们看 initAndRegister() 方法：\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel = null;\n    try &#123;\n        // 前面我们说过，这里会进行 Channel 的实例化\n        channel = channelFactory.newChannel();\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n    ...\n    return regFuture;\n&#125;\n\n我们找到了 channel = channelFactory.newChannel() 这行代码，根据前面说的，这里会调用相应 Channel 的无参构造方法。\n然后我们就可以去看 NioSocketChannel 的构造方法了：\npublic NioSocketChannel() &#123;\n    // SelectorProvider 实例用于创建 JDK 的 SocketChannel 实例\n    this(DEFAULT_SELECTOR_PROVIDER);\n&#125;\n\npublic NioSocketChannel(SelectorProvider provider) &#123;\n    // 看这里，newSocket(provider) 方法会创建 JDK 的 SocketChannel\n    this(newSocket(provider));\n&#125;\n\n我们可以看到，在调用 newSocket(provider) 的时候，会创建 JDK NIO 的一个 SocketChannel 实例：\nprivate static SocketChannel newSocket(SelectorProvider provider) &#123;\n    try &#123;\n        // 创建 SocketChannel 实例\n        return provider.openSocketChannel();\n    &#125; catch (IOException e) &#123;\n        throw new ChannelException(\"Failed to open a socket.\", e);\n    &#125;\n&#125;\n\nNioServerSocketChannel 同理，也非常简单，从 ServerBootstrap#bind(...) 方法一路点进去就清楚了。\n所以我们知道了，NioSocketChannel 在实例化过程中，会先实例化 JDK 底层的 SocketChannel，NioServerSocketChannel 也一样，会先实例化 ServerSocketChannel 实例：\n\n说到这里，我们顺便再继续往里看一下 NioSocketChannel 的构造方法：\npublic NioSocketChannel(SelectorProvider provider) &#123;\n    this(newSocket(provider));\n&#125;\n\n刚才我们看到这里，newSocket(provider) 创建了底层的 SocketChannel 实例，我们继续往下看构造方法：\npublic NioSocketChannel(Channel parent, SocketChannel socket) &#123;\n    super(parent, socket);\n    config = new NioSocketChannelConfig(this, socket.socket());\n&#125;\n\n上面有两行代码，第二行代码很简单，实例化了内部的 NioSocketChannelConfig 实例，它用于保存 channel 的配置信息，这里没有我们现在需要关心的内容，直接跳过。\n第一行调用父类构造器，除了设置属性外，还设置了 SocketChannel 的非阻塞模式：\nprotected AbstractNioByteChannel(Channel parent, SelectableChannel ch) &#123;\n    // 毫无疑问，客户端关心的是 OP_READ 事件，等待读取服务端返回数据\n    super(parent, ch, SelectionKey.OP_READ);\n&#125;\n\n// 然后是到这里\nprotected AbstractNioChannel(Channel parent, SelectableChannel ch, int readInterestOp) &#123;\n    super(parent);\n    this.ch = ch;\n    // 我们看到这里只是保存了 SelectionKey.OP_READ 这个信息，在后面的时候会用到\n    this.readInterestOp = readInterestOp;\n    try &#123;\n        // ******设置 channel 的非阻塞模式******\n        ch.configureBlocking(false);\n    &#125; catch (IOException e) &#123;\n        ......\n    &#125;\n&#125;\n\nNioServerSocketChannel 的构造方法类似，也设置了非阻塞，然后设置服务端关心的 SelectionKey.OP_ACCEPT 事件：\npublic NioServerSocketChannel(ServerSocketChannel channel) &#123;\n    // 对于服务端来说，关心的是 SelectionKey.OP_ACCEPT 事件，等待客户端连接\n    super(null, channel, SelectionKey.OP_ACCEPT);\n    config = new NioServerSocketChannelConfig(this, javaChannel().socket());\n&#125;\n\n这节关于 Channel 的内容我们先介绍这么多，主要就是实例化了 JDK 层的 SocketChannel 或 ServerSocketChannel，然后设置了非阻塞模式，我们后面再继续深入下去。\n\nChannel 的 register 操作经过前面的铺垫，我们已经具备一定的基础了，我们开始来把前面学到的内容揉在一起。这节，我们会介绍 register 操作，这一步其实是非常关键的，对于我们源码分析非常重要。\n我们从 EchoClient 中的 connect() 方法出发，或者 EchoServer 的 bind(port) 方法出发，都会走到 initAndRegister() 这个方法：\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel = null;\n    try &#123;\n        // 1\n        channel = channelFactory.newChannel();\n        // 2 对于 Bootstrap 和 ServerBootstrap，这里面有些不一样\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n    // 3 我们这里要说的是这行\n    ChannelFuture regFuture = config().group().register(channel);\n    if (regFuture.cause() != null) &#123;\n        if (channel.isRegistered()) &#123;\n            channel.close();\n        &#125; else &#123;\n            channel.unsafe().closeForcibly();\n        &#125;\n    &#125;\n    return regFuture;\n&#125;\n\ninitAndRegister() 这个方法我们已经接触过两次了，前面介绍了:\n\nChannel 的实例化，实例化过程中，会执行 Channel 内部 Unsafe 和 Pipeline 的实例化；\ninit(channel) 方法中，会往 pipeline 中添加 handler（pipeline 此时是 head+channelnitializer+tail）。\n\n\n\n\n\n\n\n\n\n\n我们终于要揭秘 ChannelInitializer 中的 initChannel 方法了~~~\n现在，我们继续往下走，看看第 3 步 **register** ：\nChannelFuture regFuture = config().group().register(channel);\n\n\n\n\n\n\n\n\n\n\n我们说了，register 这一步是非常关键的，它发生在 channel 实例化以后，大家回忆一下当前 channel 中的一些情况：\n实例化了 JDK 底层的 Channel，设置了非阻塞，实例化了 Unsafe，实例化了 Pipeline，同时往 pipeline 中添加了 head、tail 以及一个 ChannelInitializer 实例。\n上面的 config().group() 方法会返回前面实例化的 NioEventLoopGroup 的实例，然后调用其 register(channel) 方法：\nio.netty.channel.MultithreadEventLoopGroup\n@Override\npublic ChannelFuture register(Channel channel) &#123;\n    return next().register(channel);\n&#125;\n\nnext() 方法很简单，就是选择线程池中的一个线程（还记得 chooserFactory 吗?），也就是选择一个 NioEventLoop 实例，这个时候我们就进入到 NioEventLoop 了。\nNioEventLoop 的 register(channel) 方法实现在它的父类 **SingleThreadEventLoop** 中：\n@Override\npublic ChannelFuture register(Channel channel) &#123;\n    return register(new DefaultChannelPromise(channel, this));\n&#125;\n\n上面的代码实例化了一个 Promise，将当前 channel 带了进去：\n@Override\npublic ChannelFuture register(final ChannelPromise promise) &#123;\n    ObjectUtil.checkNotNull(promise, \"promise\");\n    // promise 关联了 channel，channel 持有 Unsafe 实例，register 操作就封装在 Unsafe 中\n    promise.channel().unsafe().register(this, promise);\n    return promise;\n&#125;\n\n\n拿到 channel 中关联的 Unsafe 实例，然后调用它的 register 方法：\n\n\n\n\n\n\n\n\n\n我们说过，Unsafe 专门用来封装底层实现，当然这里也没那么“底层”\nio.netty.channel.AbstractChannel#AbstractUnsafe\n@Override\npublic final void register(EventLoop eventLoop, final ChannelPromise promise) &#123;\n    ...\n    // 将这个 eventLoop 实例设置给这个 channel，从此这个 channel 就是有 eventLoop 的了\n    // 我觉得这一步其实挺关键的，因为后续该 channel 中的所有异步操作，都要提交给这个 eventLoop 来执行\n    AbstractChannel.this.eventLoop = eventLoop;\n\n    // 如果发起 register 动作的线程就是 eventLoop 实例中的线程，那么直接调用 register0(promise)\n    // 对于我们来说，它不会进入到这个分支，\n    //     之所以有这个分支，是因为我们是可以 unregister，然后再 register 的，后面再仔细看\n    if (eventLoop.inEventLoop()) &#123;\n        register0(promise);\n    &#125; else &#123;\n        try &#123;\n            // 否则，提交任务给 eventLoop，eventLoop 中的线程会负责调用 register0(promise)\n            eventLoop.execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    register0(promise);\n                &#125;\n            &#125;);\n        &#125; catch (Throwable t) &#123;\n            ...\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n到这里，我们要明白，NioEventLoop 中是还没有实例化 Thread 实例的。\n这几步涉及到了好几个类：NioEventLoop、Promise、Channel、Unsafe 等，大家要仔细理清楚它们的关系。\n对于我们前面过来的 register 操作，其实提交到 eventLoop 以后，就直接返回 promise 实例了，剩下的 register0 是异步操作，它由 NioEventLoop 实例来完成。\n\n\n\n\n\n\n\n\n\nChannel 实例一旦 register 到了 NioEventLoopGroup 实例中的某个 NioEventLoop 实例，那么后续该 Channel 的所有操作，都是由该 NioEventLoop 实例来完成的。\n这个也非常简单，因为 Selector 实例是在 NioEventLoop 实例中的，Channel 实例一旦注册到某个 Selector 实例中，当然也只能在这个实例中处理 NIO 事件。\n我们来看 register0(promise) 方法，我们知道，这个 register 任务进入到了 NioEventLoop 的 taskQueue 中，然后会启动 NioEventLoop 中的线程，该线程会轮询这个 taskQueue，然后执行这个 register 任务。\n注意，此时执行该方法的是 eventLoop 中的线程：\nio.netty.channel.AbstractChannel#register0\nprivate void register0(ChannelPromise promise) &#123;\n    try &#123;\n        ...\n        boolean firstRegistration = neverRegistered;\n        // *** 进行 JDK 底层的操作：Channel 注册到 Selector 上 ***\n        doRegister();\n\n        neverRegistered = false;\n        registered = true;\n        // 到这里，就算是 registered 了\n\n        // 这一步也很关键，因为这涉及到了 ChannelInitializer 的 init(channel)\n        // 我们之前说过，init 方法会将 ChannelInitializer 内部添加的 handlers 添加到 pipeline 中\n        pipeline.invokeHandlerAddedIfNeeded();\n\n        // 设置当前 promise 的状态为 success\n        //   因为当前 register 方法是在 eventLoop 中的线程中执行的，需要通知提交 register 操作的线程\n        safeSetSuccess(promise);\n\n        // 当前的 register 操作已经成功，该事件应该被 pipeline 上\n        //   所有关心 register 事件的 handler 感知到，往 pipeline 中扔一个事件\n        pipeline.fireChannelRegistered();\n\n        // 这里 active 指的是 channel 已经打开\n        if (isActive()) &#123;\n            // 如果该 channel 是第一次执行 register，那么 fire ChannelActive 事件\n            if (firstRegistration) &#123;\n                pipeline.fireChannelActive();\n            &#125; else if (config().isAutoRead()) &#123;\n                // 该 channel 之前已经 register 过了，\n                // 这里让该 channel 立马去监听通道中的 OP_READ 事件\n                beginRead();\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n&#125;\n\n\n我们先说掉上面的 doRegister() 方法，然后再说 pipeline。\n@Override\nprotected void doRegister() throws Exception &#123;\n    boolean selected = false;\n    for (;;) &#123;\n        try &#123;\n            // 附 JDK 中 Channel 的 register 方法：\n            // public final SelectionKey register(Selector sel, int ops, Object att) &#123;...&#125;\n            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);\n            return;\n        &#125; catch (CancelledKeyException e) &#123;\n            ...\n        &#125;\n    &#125;\n&#125;\n\n\n我们可以看到，这里做了 JDK 底层的 register 操作，将 SocketChannel(或 ServerSocketChannel) 注册到 Selector 中，并且可以看到，这里的监听集合设置为了 0，也就是什么都不监听。\n\n\n\n\n\n\n\n\n\n当然，也就意味着，后续一定有某个地方会需要修改这个 selectionKey 的监听集合，不然啥都干不了\n我们重点来说说 **pipeline** 操作，我们之前在介绍 NioSocketChannel 的 pipeline 的时候介绍到，我们的 pipeline 现在长这个样子：\n\n\n\n\n\n\n\n\n\n\n现在，我们将看到这里会把 LoggingHandler 和 EchoClientHandler 添加到 pipeline。\n我们继续看代码，register 成功以后，执行了以下操作：\npipeline.invokeHandlerAddedIfNeeded();\n\n\n大家可以跟踪一下，这一步会执行到 pipeline 中 ChannelInitializer 实例的 handlerAdded 方法，在这里会执行它的 init(context) 方法：\n@Override\npublic void handlerAdded(ChannelHandlerContext ctx) throws Exception &#123;\n    if (ctx.channel().isRegistered()) &#123;\n        initChannel(ctx);\n    &#125;\n&#125;\n\n\n然后我们看下 initChannel(ctx)，这里终于来了我们之前介绍过的 init(channel) 方法：\nprivate boolean initChannel(ChannelHandlerContext ctx) throws Exception &#123;\n    if (initMap.putIfAbsent(ctx, Boolean.TRUE) == null) &#123; // Guard against re-entrance.\n        try &#123;\n            // 1. 将把我们自定义的 handlers 添加到 pipeline 中\n            initChannel((C) ctx.channel());\n        &#125; catch (Throwable cause) &#123;\n            ...\n        &#125; finally &#123;\n            // 2. 将 ChannelInitializer 实例从 pipeline 中删除\n            remove(ctx);\n        &#125;\n        return true;\n    &#125;\n    return false;\n&#125;\n\n\n我们前面也说过，ChannelInitializer 的 init(channel) 被执行以后，那么其内部添加的 handlers 会进入到 pipeline 中，然后上面的 finally 块中将 ChannelInitializer 的实例从 pipeline 中删除，那么此时 pipeline 就算建立起来了，如下图：\n\n\n\n\n\n\n\n\n\n\n其实这里还有个问题，如果我们在 ChannelInitializer 中添加的是一个 ChannelInitializer 实例呢？大家可以考虑下这个情况。\npipeline 建立了以后，然后我们继续往下走，会执行到这一句：\npipeline.fireChannelRegistered();\n\n\n我们只要摸清楚了 fireChannelRegistered() 方法，以后碰到其他像 fireChannelActive()、fireXxx() 等就知道怎么回事了，它们都是类似的。我们来看看这句代码会发生什么：\nio.netty.channel.DefaultChannelPipeline#fireChannelRegistered\n@Override\npublic final ChannelPipeline fireChannelRegistered() &#123;\n    // 注意这里的传参是 head\n    AbstractChannelHandlerContext.invokeChannelRegistered(head);\n    return this;\n&#125;\n\n\n也就是说，我们往 pipeline 中扔了一个 **channelRegistered** 事件，这里的 register 属于 Inbound 事件，pipeline 接下来要做的就是执行 pipeline 中的 Inbound 类型的 handlers 中的 channelRegistered() 方法。\n从上面的代码，我们可以看出，往 pipeline 中扔出 channelRegistered 事件以后，第一个处理的 handler 是 **head**。\n接下来，我们还是跟着代码走，此时我们来到了 pipeline 的第一个节点 **head** 的处理中：\nio.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered\n// next 此时是 head\nstatic void invokeChannelRegistered(final AbstractChannelHandlerContext next) &#123;\n\n    EventExecutor executor = next.executor();\n    // 执行 head 的 invokeChannelRegistered()\n    if (executor.inEventLoop()) &#123;\n        next.invokeChannelRegistered();\n    &#125; else &#123;\n        executor.execute(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                next.invokeChannelRegistered();\n            &#125;\n        &#125;);\n    &#125;\n&#125;\n\n\n也就是说，这里会先执行 head.invokeChannelRegistered() 方法，而且是放到 NioEventLoop 中的 taskQueue 中执行的：\nio.netty.channel.AbstractChannelHandlerContext#invokeChannelRegistered\nprivate void invokeChannelRegistered() &#123;\n    if (invokeHandler()) &#123;\n        try &#123;\n            // handler() 方法此时会返回 head\n            ((ChannelInboundHandler) handler()).channelRegistered(this);\n        &#125; catch (Throwable t) &#123;\n            notifyHandlerException(t);\n        &#125;\n    &#125; else &#123;\n        fireChannelRegistered();\n    &#125;\n&#125;\n\n\n我们去看 head 的 channelRegistered 方法。\nHeadContext 是 DefaultChannelPipeline 的内部类：\n\nio.netty.channel.DefaultChannelPipeline.HeadContext#channelRegistered\n@Override\npublic void channelRegistered(ChannelHandlerContext ctx) throws Exception &#123;\n    // 1. 这一步是 head 对于 channelRegistered 事件的处理。没有我们要关心的\n    invokeHandlerAddedIfNeeded();\n    // 2. 向后传播 Inbound 事件\n    ctx.fireChannelRegistered();\n&#125;\n\n\n然后 head 会执行 fireChannelRegister() 方法：\nio.netty.channel.AbstractChannelHandlerContext#fireChannelRegistered\n@Override\npublic ChannelHandlerContext fireChannelRegistered() &#123;\n    // 这里很关键\n    // findContextInbound() 方法会沿着 pipeline 找到下一个 Inbound 类型的 handler\n    invokeChannelRegistered(findContextInbound());\n    return this;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n注意：pipeline.fireChannelRegistered() 是将 channelRegistered 事件抛到 pipeline 中，pipeline 中的 handlers 准备处理该事件。而 context.fireChannelRegistered() 是一个 handler 处理完了以后，向后传播给下一个 handler。\n它们两个的方法名字是一样的，但是来自于不同的类。\nfindContextInbound() 将找到下一个 Inbound 类型的 handler，然后又是重复上面的几个方法。\n\n\n\n\n\n\n\n\n\n我觉得上面这块代码没必要太纠结，总之就是从 head 中开始，依次往下寻找所有 Inbound handler，执行其 channelRegistered(ctx) 操作。\n说了这么多，我们的 register 操作算是真正完成了。\n下面，我们回到 initAndRegister 这个方法：\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel = null;\n    try &#123;\n        channel = channelFactory.newChannel();\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n        ...\n    &#125;\n\n    // 我们上面说完了这行\n    ChannelFuture regFuture = config().group().register(channel);\n\n    // 如果在 register 的过程中，发生了错误\n    if (regFuture.cause() != null) &#123;\n        if (channel.isRegistered()) &#123;\n            channel.close();\n        &#125; else &#123;\n            channel.unsafe().closeForcibly();\n        &#125;\n    &#125;\n\n    // 源码中说得很清楚，如果到这里，说明后续可以进行 connect() 或 bind() 了，因为两种情况：\n    // 1. 如果 register 动作是在 eventLoop 中发起的，那么到这里的时候，register 一定已经完成\n    // 2. 如果 register 任务已经提交到 eventLoop 中，也就是进到了 eventLoop 中的 taskQueue 中，\n    //    由于后续的 connect 或 bind 也会进入到同一个 eventLoop 的 queue 中，所以一定是会先 register 成功，才会执行 connect 或 bind\n    return regFuture;\n&#125;\n\n\n我们要知道，不管是服务端的 NioServerSocketChannel 还是客户端的 NioSocketChannel，在 bind 或 connect 时，都会先进入 initAndRegister 这个方法，所以我们上面说的那些，对于两者都是通用的。\n大家要记住，register 操作是非常重要的，要知道这一步大概做了哪些事情，register 操作以后，将进入到 bind 或 connect 操作中。\n\nconnect 过程和 bind 过程分析上面我们介绍的 register 操作非常关键，它建立起来了很多的东西，它是 Netty 中 NioSocketChannel 和 NioServerSocketChannel 开始工作的起点。\n这一节，我们来说说 register 之后的 connect 操作和 bind 操作。这节非常简单。\n\nconnect 过程分析对于客户端 NioSocketChannel 来说，前面 register 完成以后，就要开始 connect 了，这一步将连接到服务端。\nprivate ChannelFuture doResolveAndConnect(final SocketAddress remoteAddress, final SocketAddress localAddress) &#123;\n    // 这里完成了 register 操作\n    final ChannelFuture regFuture = initAndRegister();\n    final Channel channel = regFuture.channel();\n\n    // 这里我们不去纠结 register 操作是否 isDone()\n    if (regFuture.isDone()) &#123;\n        if (!regFuture.isSuccess()) &#123;\n            return regFuture;\n        &#125;\n        // 看这里\n        return doResolveAndConnect0(channel, remoteAddress, localAddress, channel.newPromise());\n    &#125; else &#123;\n        ....\n    &#125;\n&#125;\n\n\n这里大家自己一路点进去，我就不浪费篇幅了。最后，我们会来到 AbstractChannel 的 connect 方法：\n@Override\npublic ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;\n    return pipeline.connect(remoteAddress, promise);\n&#125;\n\n\n我们看到，connect 操作是交给 pipeline 来执行的。进入 pipeline 中，我们会发现，connect 这种 Outbound 类型的操作，是从 pipeline 的 tail 开始的：\n\n\n\n\n\n\n\n\n\n前面我们介绍的 register 操作是 Inbound 的，是从 head 开始的\n@Override\npublic final ChannelFuture connect(SocketAddress remoteAddress, ChannelPromise promise) &#123;\n    return tail.connect(remoteAddress, promise);\n&#125;\n\n\n接下来就是 pipeline 的操作了，从 tail 开始，执行 pipeline 上的 Outbound 类型的 handlers 的 connect(...) 方法，那么真正的底层的 connect 的操作发生在哪里呢？还记得我们的 pipeline 的图吗？\n\n从 tail 开始往前找 out 类型的 handlers，每经过一个 handler，都执行里面的 connect() 方法，最后会到 head 中，因为 head 也是 Outbound 类型的，我们需要的 connect 操作就在 head 中，它会负责调用 unsafe 中提供的 connect 方法：\n// HeadContext\npublic void connect(\n        ChannelHandlerContext ctx,\n        SocketAddress remoteAddress, SocketAddress localAddress,\n        ChannelPromise promise) throws Exception &#123;\n    unsafe.connect(remoteAddress, localAddress, promise);\n&#125;\n\n\n接下来，我们来看一看 connect 在 unsafe 类中所谓的底层操作：\n// AbstractNioChannel.AbstractNioUnsafe\n@Override\npublic final void connect(\n        final SocketAddress remoteAddress, final SocketAddress localAddress, final ChannelPromise promise) &#123;\n        ......\n\n        boolean wasActive = isActive();\n        // 大家自己点进去看 doConnect 方法\n        // 这一步会做 JDK 底层的 SocketChannel connect，然后设置 interestOps 为 SelectionKey.OP_CONNECT\n        // 返回值代表是否已经连接成功\n        if (doConnect(remoteAddress, localAddress)) &#123;\n            // 处理连接成功的情况\n            fulfillConnectPromise(promise, wasActive);\n        &#125; else &#123;\n            connectPromise = promise;\n            requestedRemoteAddress = remoteAddress;\n\n            // 下面这块代码，在处理连接超时的情况，代码很简单\n            // 这里用到了 NioEventLoop 的定时任务的功能，这个我们之前一直都没有介绍过，因为我觉得也不太重要\n            int connectTimeoutMillis = config().getConnectTimeoutMillis();\n            if (connectTimeoutMillis > 0) &#123;\n                connectTimeoutFuture = eventLoop().schedule(new Runnable() &#123;\n                    @Override\n                    public void run() &#123;\n                        ChannelPromise connectPromise = AbstractNioChannel.this.connectPromise;\n                        ConnectTimeoutException cause =\n                                new ConnectTimeoutException(\"connection timed out: \" + remoteAddress);\n                        if (connectPromise != null &amp;&amp; connectPromise.tryFailure(cause)) &#123;\n                            close(voidPromise());\n                        &#125;\n                    &#125;\n                &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);\n            &#125;\n\n            promise.addListener(new ChannelFutureListener() &#123;\n                @Override\n                public void operationComplete(ChannelFuture future) throws Exception &#123;\n                    if (future.isCancelled()) &#123;\n                        if (connectTimeoutFuture != null) &#123;\n                            connectTimeoutFuture.cancel(false);\n                        &#125;\n                        connectPromise = null;\n                        close(voidPromise());\n                    &#125;\n                &#125;\n            &#125;);\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        promise.tryFailure(annotateConnectException(t, remoteAddress));\n        closeIfClosed();\n    &#125;\n&#125;\n\n\n如果上面的 doConnect 方法返回 false，那么后续是怎么处理的呢？\n在上一节介绍的 register 操作中，channel 已经 register 到了 selector 上，只不过将 interestOps 设置为了 0，也就是什么都不监听。\n而在上面的 doConnect 方法中，我们看到它在调用底层的 connect 方法后，会设置 interestOps 为 SelectionKey.OP_CONNECT。\n剩下的就是 NioEventLoop 的事情了，还记得 NioEventLoop 的 run() 方法吗？也就是说这里的 connect 成功以后，这个 TCP 连接就建立起来了，后续的操作会在 NioEventLoop.run() 方法中被 processSelectedKeys() 方法处理掉。\n\nbind 过程分析说完 connect 过程，我们再来简单看下 bind 过程：\nprivate ChannelFuture doBind(final SocketAddress localAddress) &#123;\n    // **前面说的 initAndRegister**\n    final ChannelFuture regFuture = initAndRegister();\n\n    final Channel channel = regFuture.channel();\n    if (regFuture.cause() != null) &#123;\n        return regFuture;\n    &#125;\n\n    if (regFuture.isDone()) &#123;\n        // register 动作已经完成，那么执行 bind 操作\n        ChannelPromise promise = channel.newPromise();\n        doBind0(regFuture, channel, localAddress, promise);\n        return promise;\n    &#125; else &#123;\n        ......\n    &#125;\n&#125;\n\n\n然后一直往里看，会看到，bind 操作也是要由 pipeline 来完成的：\nio.netty.channel.AbstractChannel#bind\n@Override\npublic ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;\n    return pipeline.bind(localAddress, promise);\n&#125;\n\n\nbind 操作和 connect 一样，都是 Outbound 类型的，所以都是 tail 开始：\n@Override\npublic final ChannelFuture bind(SocketAddress localAddress, ChannelPromise promise) &#123;\n    return tail.bind(localAddress, promise);\n&#125;\n\n\n最后的 bind 操作又到了 head 中，由 head 来调用 unsafe 提供的 bind 方法：\n@Override\npublic void bind(\n        ChannelHandlerContext ctx, SocketAddress localAddress, ChannelPromise promise)\n        throws Exception &#123;\n    unsafe.bind(localAddress, promise);\n&#125;\n\n\n感兴趣的读者自己去看一下 unsafe 中的 bind 方法，非常简单，bind 操作也不是什么异步方法，我们就介绍到这里了。\nChannelHandler 是消息的具体处理器，主要负责处理客户端&#x2F;服务端接收和发送的数据。ChannelPipeline 则是包含了一个或多个 ChannelHandler 的链表。\n\n2.消息处理器链表：ChannelPipelineChannelPipeline：消息处理器链表我想很多读者应该或多或少都有 Netty 中 pipeline 的概念。前面我们说了，使用 Netty 的时候，我们通常就只要写一些自定义的 handler 就可以了，我们定义的这些 handler 会组成一个 pipeline，用于处理 IO 事件，这个和我们平时接触的 Filter 或 Interceptor 表达的差不多是一个意思。\n每个 Channel 内部都有一个 pipeline，pipeline 由多个 handler 组成，handler 之间的顺序是很重要的，因为 IO 事件将按照顺序顺次经过 pipeline 上的 handler，这样每个 handler 可以专注于做一点点小事，由多个 handler 组合来完成一些复杂的逻辑。\n\n从图中，我们知道这是一个双向链表。\n\nIO 事件：Inbound &amp; Outbound首先，我们看两个重要的概念：Inbound 和 Outbound。在 Netty 中，IO 事件被分为 Inbound 事件和 Outbound 事件。\nOutbound 的 out 指的是 出去，有哪些 IO 事件属于此类呢？比如 connect、write、flush 这些 IO 操作是往外部方向进行的，它们就属于 Outbound 事件。\n其他的，诸如 accept、read 这种就属于 Inbound 事件。\n比如客户端在发起请求的时候，需要下面几步：\n\nconnect 到服务器;\nwrite 数据传到服务器\nread 服务器返回的数据\n\nconnect 和 write 就是 out 事件，后面的 read 就是 in 事件。\n比如很多初学者看不懂下面的这段代码，这段代码用于服务端的 childHandler 中：\n1. pipeline.addLast(new StringDecoder());\n2. pipeline.addLast(new StringEncoder());\n3. pipeline.addLast(new BizHandler());\n\n初学者肯定都纳闷，以为这个顺序写错了，应该是先 decode 客户端过来的数据，然后用 BizHandler 处理业务逻辑，最后再 encode 数据然后返回给客户端，所以添加的顺序应该是 1 -&gt; 3 -&gt; 2 才对。\n其实这里的三个 handler 是分组的，分为 Inbound（1 和 3） 和 Outbound（2）：\n1. pipeline.addLast(new StringDecoder());\n2. pipeline.addLast(new StringEncoder());\n3. pipeline.addLast(new BizHandler());\n\n\n客户端连接进来的时候，读取（read）客户端请求数据的操作是 Inbound 的，所以会先使用 1，然后是 3 对处理进行处理；\n处理完数据后，返回给客户端数据的 write 操作是 Outbound 的，此时使用的是 2。\n\n所以虽然添加顺序有点怪，但是执行顺序其实是按照 1 -&gt; 3 -&gt; 2 进行的。\n\n\n\n\n\n\n\n\n\n如果我们在上面的基础上，加上下面的第四行，这是一个 OutboundHandler：\n那么执行顺序是不是就是 1 -&gt; 3 -&gt; 2 -&gt; 4 呢？答案是：不是的。\n**对于 Inbound 操作，按照添加顺序执行每个 Inbound 类型的 ****handler****；而对于 Outbound 操作，是反着来的，从后往前，顺次执行 Outbound 类型的 ****handler**。\n所以，上面的顺序应该是先 1 后 3，它们是 Inbound 的，然后是 4，最后才是 2，它们两个是 Outbound 的。说实话，这种组织方式对新手应该很是头疼。\n那我们在开发的时候怎么写呢？其实也很简单，从最外层开始写，一步步写到业务处理层，把 Inbound 和 Outbound 混写在一起。比如 encode 和 decode 是属于最外层的处理逻辑，先写它们。假设 decode 以后是字符串，那再进来一层应该可以写进来和出去的日志。再进来一层可以写 字符串 &lt;&#x3D;&gt; 对象 的相互转换。然后就应该写业务层了。\n4. pipeline.addLast(new OutboundHandlerA());\n\n到这里，我想大家应该都知道 Inbound 和 Outbound 了吧？下面我们来介绍它们的接口使用。\n\n定义处理 Inbound 事件的 handler 需要实现 ChannelInboundHandler，定义处理 Outbound 事件的 handler 需要实现 ChannelOutboundHandler。最下面的三个类，是 Netty 提供的适配器，特别的，如果我们希望定义一个 handler 能同时处理 Inbound 和 Outbound 事件，可以通过继承中间的 **ChannelDuplexHandler** 的方式，比如 **LoggingHandler** 这种既可以用来处理 Inbound 也可以用来处理 Outbound 事件的 handler。\n下图来源于 Netty ChannelPipeline 。\n\n有了 Inbound 和 Outbound 的概念以后，我们来开始介绍 Pipeline 的源码。\n\nChannelPipeline 源码解读我们说过，一个 Channel 关联一个 pipeline，NioSocketChannel 和 NioServerSocketChannel 在执行构造方法的时候，都会走到它们的父类 AbstractChannel 的构造方法中：\nprotected AbstractChannel(Channel parent) &#123;\n    this.parent = parent;\n    // 给每个 channel 分配一个唯一 id\n    id = newId();\n    // 每个 channel 内部需要一个 Unsafe 的实例\n    unsafe = newUnsafe();\n    // 每个 channel 内部都会创建一个 pipeline\n    pipeline = newChannelPipeline();\n&#125;\n\n上面的三行代码中，id 比较不重要，Netty 中的 Unsafe 实例其实挺重要的，这里简单介绍一下。\n在 JDK 的源码中，sun.misc.Unsafe 类提供了一些底层操作的能力，它设计出来是给 JDK 中的源码使用的，比如 AQS、ConcurrentHashMap 等，我们在之前的并发包的源码分析中也看到了很多它们使用 Unsafe 的场景，这个 Unsafe 类不是给我们的代码使用的，是给 JDK 源码使用的（需要的话，我们也是可以获取它的实例的）。\n\n\n\n\n\n\n\n\n\nUnsafe 类的构造方法是 private 的，但是它提供了 getUnsafe() 这个静态方法：\n大家可以试一下，上面这行代码编译没有问题，但是执行的时候会抛 java.lang.SecurityException 异常，因为它就不是给我们的代码用的。\n但是如果你就是想获取 Unsafe 的实例，可以通过下面这个代码获取到:\nUnsafe unsafe = Unsafe.getUnsafe();\n\nField f = Unsafe.class.getDeclaredField(\"theUnsafe\");\nf.setAccessible(true);\nUnsafe unsafe = (Unsafe) f.get(null);\n\nNetty 中的 Unsafe 也是同样的意思，它封装了 Netty 中会使用到的 JDK 提供的 NIO 接口，比如将 channel 注册到 selector 上，比如 bind 操作，比如 connect 操作等，这些操作都是稍微偏底层一些。Netty 同样也是不希望我们的业务代码使用 Unsafe 的实例，它是提供给 Netty 中的源码使用的。\n\n\n\n\n\n\n\n\n\n不过，对于我们源码分析来说，我们还是会有很多时候需要分析 Unsafe 中的源码的\n关于 Unsafe，我们后面用到了再说，这里只要知道，它封装了大部分需要访问 JDK 的 NIO 接口的操作就好了。这里我们继续将焦点放在实例化 pipeline 上：\nprotected DefaultChannelPipeline newChannelPipeline() &#123;\n    return new DefaultChannelPipeline(this);\n&#125;\n\n这里开始调用 DefaultChannelPipeline 的构造方法，并把当前 channel 的引用传入：\nprotected DefaultChannelPipeline(Channel channel) &#123;\n    this.channel = ObjectUtil.checkNotNull(channel, \"channel\");\n    succeededFuture = new SucceededChannelFuture(channel, null);\n    voidPromise =  new VoidChannelPromise(channel, true);\n\n    tail = new TailContext(this);\n    head = new HeadContext(this);\n\n    head.next = tail;\n    tail.prev = head;\n&#125;\n\n这里实例化了 tail 和 head 这两个 handler。tail 实现了 ChannelInboundHandler 接口，而 head 实现了 ChannelOutboundHandler 和 ChannelInboundHandler 两个接口，并且最后两行代码将 tail 和 head 连接起来:\n\n\n\n\n\n\n\n\n\n\n注意，在不同的版本中，源码也略有差异，head 不一定是 in + out，大家知道这点就好了。\n还有，从上面的 head 和 tail 我们也可以看到，其实 pipeline 中的每个元素是 **ChannelHandlerContext** 的实例，而不是 ChannelHandler 的实例，context 包装了一下 handler，但是，后面我们都会用 handler 来描述一个 pipeline 上的节点，而不是使用 context，希望读者知道这一点。\nChannelHandlerContext 可以说是 ChannelPipeline 的核心，它代表了 ChannelHandler 和 ChannelPipeline 之间的关联，我们首先要知道一个 ChannelPipeline 内部会维护一个双向链表，每当一个 ChannelHandler 被添加到 ChannelPipeline 中时，它都会被包装成为一个 ChannelHandlerContext，组成链表的各个节点。\n\n这里只是构造了 pipeline，并且添加了两个固定的 handler 到其中（head + tail），还不涉及到自定义的 handler 代码执行。我们回过头来看下面这段代码：\n\n\n\n\n\n\n\n\n\n\n我们说过 childHandler 中指定的 handler 不是给 NioServerSocketChannel 使用的，是给 NioSocketChannel 使用的，所以这里我们不看它。\n这里调用 handler(…) 方法指定了一个 LoggingHandler 的实例，然后我们再进去下面的 bind(…) 方法中看看这个 LoggingHandler 实例是怎么进入到我们之前构造的 pipeline 内的。\n顺着 bind() 一直往前走，bind() -&gt; doBind() -&gt; initAndRegister()：\nfinal ChannelFuture initAndRegister() &#123;\n    Channel channel = null;\n    try &#123;\n        // 1. 构造 channel 实例，同时会构造 pipeline 实例，\n        // 现在 pipeline 中有 head 和 tail 两个 handler 了\n        channel = channelFactory.newChannel();\n        // 2. 看这里\n        init(channel);\n    &#125; catch (Throwable t) &#123;\n    ......\n&#125;\n\n上面的两行代码，第一行实现了构造 channel 和 channel 内部的 pipeline，我们来看第二行 init 代码：\nServerBootstrap：\n@Override\nvoid init(Channel channel) throws Exception &#123;\n    ......\n    // 拿到刚刚创建的 channel 内部的 pipeline 实例\n    ChannelPipeline p = channel.pipeline();\n    ...\n    // 开始往 pipeline 中添加一个 handler，这个 handler 是 ChannelInitializer 的实例\n    p.addLast(new ChannelInitializer&lt;Channel>() &#123;\n\n        // 我们以后会看到，下面这个 initChannel 方法何时会被调用\n        @Override\n        public void initChannel(final Channel ch) throws Exception &#123;\n            final ChannelPipeline pipeline = ch.pipeline();\n            // 这个方法返回我们最开始指定的 LoggingHandler 实例\n            ChannelHandler handler = config.handler();\n            if (handler != null) &#123;\n                // 添加 LoggingHandler\n                pipeline.addLast(handler);\n            &#125;\n\n            // 先不用管这里的 eventLoop\n            ch.eventLoop().execute(new Runnable() &#123;\n                @Override\n                public void run() &#123;\n                    // 添加一个 handler 到 pipeline 中：ServerBootstrapAcceptor\n                    // 从名字可以看到，这个 handler 的目的是用于接收客户端请求\n                    pipeline.addLast(new ServerBootstrapAcceptor(\n                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));\n                &#125;\n            &#125;);\n        &#125;\n    &#125;);\n&#125;\n\n这里涉及到 pipeline 中的辅助类 ChannelInitializer，我们看到，它本身是一个 handler（Inbound 类型），但是它的作用和普通 handler 有点不一样，它纯碎是用来辅助将其他的 handler 加入到 pipeline 中的。\n大家可以稍微看一下 ChannelInitializer 的 initChannel 方法，有个简单的认识就好，此时的 pipeline 应该是这样的：\n\nChannelInitializer 的 initChannel(channel) 方法被调用的时候，会往 pipeline 中添加我们最开始指定的 **LoggingHandler** 和添加一个 **ServerBootstrapAcceptor**。但是我们现在还不知道这个 initChannel 方法何时会被调用。\n上面我们说的是作为服务端的 NioServerSocketChannel 的 pipeline，NioSocketChannel 也是差不多的，我们可以看一下 Bootstrap 类的 init(channel) 方法：\nvoid init(Channel channel) throws Exception &#123;\n    ChannelPipeline p = channel.pipeline();\n    p.addLast(config.handler());\n    ...\n&#125;\n\n\n它和服务端 ServerBootstrap 要添加 ServerBootstrapAcceptor 不一样，它只需要将 EchoClient 类中的 ChannelInitializer 实例加进来就可以了，它的 ChannelInitializer 中添加了两个 handler，LoggingHandler 和 EchoClientHandler：\n\n很显然，我们需要的是像 LoggingHandler 和 EchoClientHandler 这样的 handler，但是，它们现在还不在 pipeline 中，那么它们什么时候会真正进入到 pipeline 中呢？以后我们再揭晓。\n还有，为什么 Server 端我们指定的是一个 handler 实例，而 Client 指定的是一个 ChannelInitializer 实例？其实它们是可以随意搭配使用的，你甚至可以在 ChannelInitializer 实例中添加 ChannelInitializer 的实例。\n大家要记住 pipeline 现在的样子，head + channelInitializer + tail。\n本节没有介绍 handler 的向后传播，就是一个 handler 处理完了以后，怎么传递给下一个 handler 来处理？比如我们熟悉的 JavaEE 中的 Filter 是采用在一个 Filter 实例中调用 chain.doFilter(request, response) 来传递给下一个 Filter 这种方式的。\n我们用下面这张图结束本节。下图展示了传播的方法，但我其实是更想让大家看一下，哪些事件是 Inbound 类型的，哪些是 Outbound 类型的：\n\nOutbound 类型的几个事件大家应该比较好认，注意 bind 也是 Outbound 类型的。\n3.异步操作：Future 和 PromiseNetty 中非常多的异步调用，所以在介绍更多 NIO 相关的内容之前，我们来看看它的异步接口是怎么使用的。\n前面我们在介绍 Echo 例子的时候，已经用过了 ChannelFuture 这个接口了：\n\n争取在看完本节后，读者能搞清楚上面的这几行划线部分是怎么走的。\n关于 Future 接口，我想大家应该都很熟悉，用得最多的就是在使用 Java 的线程池 ThreadPoolExecutor 的时候了。在 submit 一个任务到线程池中的时候，返回的就是一个 **Future** 实例，通过它来获取提交的任务的执行状态和最终的执行结果，我们最常用它的 isDone() 和 get() 方法。\n下面是 JDK  中的 Future 接口 java.util.concurrent.Future ：\npublic interface Future&lt;V> &#123;\n    // 取消该任务\n    boolean cancel(boolean mayInterruptIfRunning);\n    // 任务是否已取消\n    boolean isCancelled();\n    // 任务是否已完成\n    boolean isDone();\n    // 阻塞获取任务执行结果\n    V get() throws InterruptedException, ExecutionException;\n    // 带超时参数的获取任务执行结果\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n&#125;\n\nNetty 中的 Future 接口（同名）继承了 JDK 中的 Future 接口，然后添加了一些方法：\nio.netty.util.concurrent.Future\npublic interface Future&lt;V> extends java.util.concurrent.Future&lt;V> &#123;\n\n    // 是否成功\n    boolean isSuccess();\n\n    // 是否可取消\n    boolean isCancellable();\n\n    // 如果任务执行失败，这个方法返回异常信息\n    Throwable cause();\n\n    // 添加 Listener 来进行回调\n    Future&lt;V> addListener(GenericFutureListener&lt;? extends Future&lt;? super V>> listener);\n    Future&lt;V> addListeners(GenericFutureListener&lt;? extends Future&lt;? super V>>... listeners);\n\n    Future&lt;V> removeListener(GenericFutureListener&lt;? extends Future&lt;? super V>> listener);\n    Future&lt;V> removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V>>... listeners);\n\n    // 阻塞等待任务结束，如果任务失败，将“导致失败的异常”重新抛出来\n    Future&lt;V> sync() throws InterruptedException;\n    // 不响应中断的 sync()，这个大家应该都很熟了\n    Future&lt;V> syncUninterruptibly();\n\n    // 阻塞等待任务结束，和 sync() 功能是一样的，不过如果任务失败，它不会抛出执行过程中的异常\n    Future&lt;V> await() throws InterruptedException;\n    Future&lt;V> awaitUninterruptibly();\n    boolean await(long timeout, TimeUnit unit) throws InterruptedException;\n    boolean await(long timeoutMillis) throws InterruptedException;\n    boolean awaitUninterruptibly(long timeout, TimeUnit unit);\n    boolean awaitUninterruptibly(long timeoutMillis);\n\n    // 获取执行结果，不阻塞。我们都知道 java.util.concurrent.Future 中的 get() 是阻塞的\n    V getNow();\n\n    // 取消任务执行，如果取消成功，任务会因为 CancellationException 异常而导致失败\n    //      也就是 isSuccess()==false，同时上面的 cause() 方法返回 CancellationException 的实例。\n    // mayInterruptIfRunning 说的是：是否对正在执行该任务的线程进行中断(这样才能停止该任务的执行)，\n    //       似乎 Netty 中 Future 接口的各个实现类，都没有使用这个参数\n    @Override\n    boolean cancel(boolean mayInterruptIfRunning);\n&#125;\n\n看完上面的 Netty 的 Future 接口，我们可以发现，它加了 sync() 和 await() 用于阻塞等待，还加了 Listeners，只要任务结束去回调 Listener 们就可以了，那么我们就不一定要主动调用 isDone() 来获取状态，或通过 get() 阻塞方法来获取值。\n\n\n\n\n\n\n\n\n\n所以它其实有两种使用范式\n顺便说下 sync() 和 await() 的区别：sync() 内部会先调用 await() 方法，等 await() 方法返回后，会检查下这个任务是否失败，如果失败，重新将导致失败的异常抛出来。也就是说，如果使用 await()，任务抛出异常后，await() 方法会返回，但是不会抛出异常，而 sync() 方法返回的同时会抛出异常。\n\n\n\n\n\n\n\n\n\n我们也可以看到，Future 接口没有和 IO 操作关联在一起，还是比较_纯净_的接口。\n接下来，我们来看 Future 接口的子接口 ChannelFuture，这个接口用得最多，它将和 IO 操作中的 Channel 关联在一起了，用于异步处理 Channel 中的事件。\npublic interface ChannelFuture extends Future&lt;Void> &#123;\n\n    // ChannelFuture 关联的 Channel\n    Channel channel();\n\n    // 覆写以下几个方法，使得它们返回值为 ChannelFuture 类型 \n    @Override\n    ChannelFuture addListener(GenericFutureListener&lt;? extends Future&lt;? super Void>> listener);\n    @Override\n    ChannelFuture addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void>>... listeners);\n    @Override\n    ChannelFuture removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void>> listener);\n    @Override\n    ChannelFuture removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void>>... listeners);\n\n    @Override\n    ChannelFuture sync() throws InterruptedException;\n    @Override\n    ChannelFuture syncUninterruptibly();\n\n    @Override\n    ChannelFuture await() throws InterruptedException;\n    @Override\n    ChannelFuture awaitUninterruptibly();\n\n    // 用来标记该 future 是 void 的，\n    // 这样就不允许使用 addListener(...), sync(), await() 以及它们的几个重载方法\n    boolean isVoid();\n&#125;\n\n我们看到，ChannelFuture 接口相对于 Future 接口，除了将 channel 关联进来，没有增加什么东西。还有个 isVoid() 方法算是不那么重要的存在吧。其他几个都是方法覆写，为了让返回值类型变为 ChannelFuture，而不是原来的 Future。\n这里有点跳，我们来介绍下 Promise 接口，它和 ChannelFuture 接口无关，而是和前面的 Future 接口相关，Promise 这个接口非常重要。\nPromise 接口和 ChannelFuture 一样，也继承了 Netty 的 Future 接口，然后加了一些 Promise 的内容：\npublic interface Promise&lt;V> extends Future&lt;V> &#123;\n\n    // 标记该 future 成功及设置其执行结果，并且会通知所有的 listeners。\n    // 如果该操作失败，将抛出异常(失败指的是该 future 已经有了结果了，成功的结果，或者失败的结果)\n    Promise&lt;V> setSuccess(V result);\n\n    // 和 setSuccess 方法一样，只不过如果失败，它不抛异常，返回 false\n    boolean trySuccess(V result);\n\n    // 标记该 future 失败，及其失败原因。\n    // 如果失败，将抛出异常(失败指的是已经有了结果了)\n    Promise&lt;V> setFailure(Throwable cause);\n\n    // 标记该 future 失败，及其失败原因。\n    // 如果已经有结果，返回 false，不抛出异常\n    boolean tryFailure(Throwable cause);\n\n    // 标记该 future 不可以被取消\n    boolean setUncancellable();\n\n    // 这里和 ChannelFuture 一样，对这几个方法进行覆写，目的是为了返回 Promise 类型的实例\n    @Override\n    Promise&lt;V> addListener(GenericFutureListener&lt;? extends Future&lt;? super V>> listener);\n    @Override\n    Promise&lt;V> addListeners(GenericFutureListener&lt;? extends Future&lt;? super V>>... listeners);\n\n    @Override\n    Promise&lt;V> removeListener(GenericFutureListener&lt;? extends Future&lt;? super V>> listener);\n    @Override\n    Promise&lt;V> removeListeners(GenericFutureListener&lt;? extends Future&lt;? super V>>... listeners);\n\n    @Override\n    Promise&lt;V> await() throws InterruptedException;\n    @Override\n    Promise&lt;V> awaitUninterruptibly();\n\n    @Override\n    Promise&lt;V> sync() throws InterruptedException;\n    @Override\n    Promise&lt;V> syncUninterruptibly();\n&#125;\n\n可能有些读者对 Promise 的概念不是很熟悉，这里简单说两句。\n我觉得只要明白一点，Promise 实例内部是一个任务，任务的执行往往是异步的，通常是一个线程池来处理任务。Promise 提供的 setSuccess(V result) 或 setFailure(Throwable t)将来会被某个执行任务的线程在执行完成以后调用，同时那个线程在调用 setSuccess(result) 或 setFailure(t) 后会回调 listeners 的回调函数（当然，回调的具体内容不一定要由执行任务的线程自己来执行，它可以创建新的线程来执行，也可以将回调任务提交到某个线程池来执行）。而且，一旦 setSuccess(...) 或 setFailure(...) 后，那些 await() 或 sync() 的线程就会从等待中返回。\n**所以这里就有两种编程方式，一种是用 ****await()**，等 **await()** 方法返回后，得到 **promise** 的执行结果，然后处理它；另一种就是提供 **Listener** 实例，我们不太关心任务什么时候会执行完，只要它执行完了以后会去执行 listener 中的处理方法就行。\n接下来，我们再来看下 **ChannelPromise**，它继承了前面介绍的 ChannelFuture 和 Promise 接口。\n\nChannelPromise 接口在 Netty 中使用得比较多，因为它综合了 ChannelFuture 和 Promise 两个接口：\n/**\n * Special &#123;@link ChannelFuture&#125; which is writable.\n */\npublic interface ChannelPromise extends ChannelFuture, Promise&lt;Void> &#123;\n\n    // 覆写 ChannelFuture 中的 channel() 方法，其实这个方法一点没变\n    @Override\n    Channel channel();\n\n    // 下面几个方法是覆写 Promise 中的接口，为了返回值类型是 ChannelPromise\n    @Override\n    ChannelPromise setSuccess(Void result);\n    ChannelPromise setSuccess();\n    boolean trySuccess();\n    @Override\n    ChannelPromise setFailure(Throwable cause);\n\n    // 到这里大家应该都熟悉了，下面几个方法的覆写也是为了得到 ChannelPromise 类型的实例\n    @Override\n    ChannelPromise addListener(GenericFutureListener&lt;? extends Future&lt;? super Void>> listener);\n    @Override\n    ChannelPromise addListeners(GenericFutureListener&lt;? extends Future&lt;? super Void>>... listeners);\n    @Override\n    ChannelPromise removeListener(GenericFutureListener&lt;? extends Future&lt;? super Void>> listener);\n    @Override\n    ChannelPromise removeListeners(GenericFutureListener&lt;? extends Future&lt;? super Void>>... listeners);\n\n    @Override\n    ChannelPromise sync() throws InterruptedException;\n    @Override\n    ChannelPromise syncUninterruptibly();\n    @Override\n    ChannelPromise await() throws InterruptedException;\n    @Override\n    ChannelPromise awaitUninterruptibly();\n\n    /**\n     * Returns a new &#123;@link ChannelPromise&#125; if &#123;@link #isVoid()&#125; returns &#123;@code true&#125; otherwise itself.\n     */\n    // 我们忽略这个方法吧。\n    ChannelPromise unvoid();\n&#125;\n\n我们可以看到，它综合了 ChannelFuture 和 Promise 中的方法，只不过通过覆写将返回值都变为 ChannelPromise 了而已，没有增加什么新的功能。\n小结一下，我们上面介绍了几个接口，Future 以及它的子接口 ChannelFuture 和 Promise，然后是 ChannelPromise 接口同时继承了 ChannelFuture 和 Promise。\n我把这几个接口的主要方法列在一起，这样大家看得清晰些：\n\n接下来，我们需要来一个实现类，这样才能比较直观地看出它们是怎么使用的，因为上面的这些都是接口定义，具体还得看实现类是怎么工作的。\n下面，我们来介绍下 DefaultPromise 这个实现类，这个类很常用，它的源码也不短，我们先介绍几个关键的内容，然后介绍一个示例使用。\n首先，我们看下它有哪些属性：\npublic class DefaultPromise&lt;V> extends AbstractFuture&lt;V> implements Promise&lt;V> &#123;\n      // 保存执行结果\n    private volatile Object result;\n    // 执行任务的线程池，promise 持有 executor 的引用，这个其实有点奇怪了\n    // 因为“任务”其实没必要知道自己在哪里被执行的\n    private final EventExecutor executor;\n      // 监听者，回调函数，任务结束后（正常或异常结束）执行\n    private Object listeners;\n\n    // 等待这个 promise 的线程数(调用sync()/await()进行等待的线程数量)\n    private short waiters;\n\n    // 是否正在唤醒等待线程，用于防止重复执行唤醒，不然会重复执行 listeners 的回调方法\n    private boolean notifyingListeners;\n    ......\n&#125;\n\n\n\n\n\n\n\n\n\n\n可以看出，此类实现了 Promise，但是没有实现 ChannelFuture，所以它和 Channel 联系不起来。\n别急，我们后面会碰到另一个类 DefaultChannelPromise 的使用，这个类是综合了 ChannelFuture 和 Promise 的，但是它的实现其实大部分都是继承自这里的 DefaultPromise 类的。\n说完上面的属性以后，大家可以看下 setSuccess(V result) 、trySuccess(V result) 和 setFailure(Throwable cause) 、 tryFailure(Throwable cause) 这几个方法：\n\n\n\n\n\n\n\n\n\n\n看出 setSuccess(result) 和 trySuccess(result) 的区别了吗？\n上面几个方法都非常简单，先设置好值，然后执行监听者们的回调方法。notifyListeners() 方法感兴趣的读者也可以看一看，不过它还涉及到 Netty 线程池的一些内容，我们还没有介绍到线程池，这里就不展开了。上面的代码，在 setSuccess0 或 setFailure0 方法中都会唤醒阻塞在 sync() 或 await() 的线程\n另外，就是可以看下 sync() 和 await() 的区别，其他的我觉得随便看看就好了。\n@Override\npublic Promise&lt;V> sync() throws InterruptedException &#123;\n    await();\n    // 如果任务是失败的，重新抛出相应的异常\n    rethrowIfFailed();\n    return this;\n&#125;\n\n接下来，我们来写个实例代码吧：\npublic static void main(String[] args) &#123;\n\n    // 构造线程池\n    EventExecutor executor = new DefaultEventExecutor();\n\n    // 创建 DefaultPromise 实例\n    Promise promise = new DefaultPromise(executor);\n\n    // 下面给这个 promise 添加两个 listener\n    promise.addListener(new GenericFutureListener&lt;Future&lt;Integer>>() &#123;\n        @Override\n        public void operationComplete(Future future) throws Exception &#123;\n            if (future.isSuccess()) &#123;\n                System.out.println(\"任务结束，结果：\" + future.get());\n            &#125; else &#123;\n                System.out.println(\"任务失败，异常：\" + future.cause());\n            &#125;\n        &#125;\n    &#125;).addListener(new GenericFutureListener&lt;Future&lt;Integer>>() &#123;\n        @Override\n        public void operationComplete(Future future) throws Exception &#123;\n            System.out.println(\"任务结束，balabala...\");\n        &#125;\n    &#125;);\n\n    // 提交任务到线程池，五秒后执行结束，设置执行 promise 的结果\n    executor.submit(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            try &#123;\n                Thread.sleep(5000);\n            &#125; catch (InterruptedException e) &#123;\n            &#125;\n            // 设置 promise 的结果\n            // promise.setFailure(new RuntimeException());\n            promise.setSuccess(123456);\n        &#125;\n    &#125;);\n\n    // main 线程阻塞等待执行结果\n    try &#123;\n        promise.sync();\n    &#125; catch (InterruptedException e) &#123;\n    &#125;\n&#125;\n\n运行代码，两个 listener 将在 5 秒后将输出：\n任务结束，结果：123456\n任务结束，balabala...\n\n\n\n\n\n\n\n\n\n\n读者这里可以试一下 sync() 和 await() 的区别，在任务中调用 promise.setFailure(new RuntimeException()) 试试看。\n上面的代码中，大家可能会对线程池 executor 和 promise 之间的关系感到有点迷惑。读者应该也要清楚，具体的任务不一定就要在这个 executor 中被执行。任务结束以后，需要调用 promise.setSuccess(result) 作为通知。\n通常来说，promise 代表的 future 是不需要和线程池搅在一起的，future 只关心任务是否结束以及任务的执行结果，至于是哪个线程或哪个线程池执行的任务，future 其实是不关心的。\n不过 Netty 毕竟不是要创建一个通用的线程池实现，而是和它要处理的 IO 息息相关的，所以我们只不过要理解它就好了。\n这节就说这么多吧，我们回过头来再看一下这张图，看看大家是不是看懂了这节内容：\n\n我们就说说上图左边的部分吧，虽然我们还不知道 bind() 操作中具体会做什么工作，但是我们应该可以猜出一二。\n显然，main 线程调用 b.bind(port) 这个方法会返回一个 ChannelFuture，bind() 是一个异步方法，当某个执行线程执行了真正的绑定操作后，那个执行线程一定会标记这个 future 为成功（我们假定 bind 会成功），然后这里的 sync() 方法（main 线程）就会返回了。\n\n\n\n\n\n\n\n\n\n如果 bind(port) 失败，我们知道，sync() 方法会将异常抛出来，然后就会执行到 finally 块了。\n一旦绑定端口 bind 成功，进入下面一行，f.channel() 方法会返回该 future 关联的 channel。\nchannel.closeFuture() 也会返回一个 ChannelFuture，然后调用了 sync() 方法，这个 sync() 方法返回的条件是：**有其他的线程关闭了 ****NioServerSocketChannel**，往往是因为需要停掉服务了，然后那个线程会设置 future 的状态（ setSuccess(result) 或 setFailure(cause) ），这个 sync() 方法才会返回。\n4.线程池：EventLoopGroup接下来，我们来分析 Netty 中的线程池。Netty 中的线程池比较不好理解，因为它的类比较多，而且它们之间的关系错综复杂。看下图，感受下 NioEventLoop 类和 NioEventLoopGroup 类的继承结构：\n\n这张图我按照继承关系整理而来，大家仔细看一下就会发现，涉及到的类确实挺多的。本节来给大家理理清楚这部分内容。\n首先，我们说的 Netty 的线程池，指的就是 **NioEventLoopGroup** 的实例；线程池中的单个线程，指的是右边 **NioEventLoop** 的实例。\n回顾下我们第一节介绍的 Echo 例子，客户端和服务端的启动代码中，最开始我们总是先实例化 NioEventLoopGroup：\n// EchoClient 代码最开始：\nEventLoopGroup group = new NioEventLoopGroup();\n\n// EchoServer 代码最开始：\nEventLoopGroup bossGroup = new NioEventLoopGroup(1);\nEventLoopGroup workerGroup = new NioEventLoopGroup();\n\n下面，我们就从 NioEventLoopGroup 的源码开始进行分析。\n\nNioEventLoopGroup 的创建我们打开 NioEventLoopGroup 的源码，可以看到，NioEventLoopGroup 有多个构造方法用于参数设置，最简单地，我们采用无参构造函数，或仅仅设置线程数量就可以了，其他的参数采用默认值。\n\n\n\n\n\n\n\n\n\n比如上面的代码中，我们只在实例化 bossGroup 的时候指定了参数，代表该线程池需要一个线程。\npublic NioEventLoopGroup() &#123;\n    this(0);\n&#125;\npublic NioEventLoopGroup(int nThreads) &#123;\n    this(nThreads, (Executor) null);\n&#125;\n\n...\n\n// 参数最全的构造方法\npublic NioEventLoopGroup(int nThreads, Executor executor, EventExecutorChooserFactory chooserFactory,\n                         final SelectorProvider selectorProvider,\n                         final SelectStrategyFactory selectStrategyFactory,\n                         final RejectedExecutionHandler rejectedExecutionHandler) &#123;\n    // 调用父类的构造方法\n    super(nThreads, executor, chooserFactory, selectorProvider, selectStrategyFactory, rejectedExecutionHandler);\n&#125;\n\n我们来稍微看一下构造方法中的各个参数：\n\nnThreads：这个最简单，就是线程池中的线程数，也就是 NioEventLoop 的实例数量。\nexecutor：我们知道，我们本身就是要构造一个线程池（Executor），为什么这里传一个 executor 实例呢？它其实不是给线程池用的，而是给 NioEventLoop 用的，以后再说。\nchooserFactory：当我们提交一个任务到线程池的时候，线程池需要选择（choose）其中的一个线程来执行这个任务，这个就是用来实现选择策略的。\nselectorProvider：这个简单，我们需要通过它来实例化 JDK 的 Selector，可以看到每个线程池都持有一个 selectorProvider 实例。\nselectStrategyFactory：这个涉及到的是线程池中线程的工作流程，在介绍 NioEventLoop 的时候会说。\nrejectedExecutionHandler：这个也是线程池的好朋友了，用于处理线程池中没有可用的线程来执行任务的情况。在 Netty 中稍微有一点点不一样，这个是给 NioEventLoop 实例用的，以后我们再详细介绍。\n\n这里介绍这些参数是希望大家有个印象而已，大家发现没有，在构造 NioEventLoopGroup 实例时的好几个参数，都是用来构造 NioEventLoop 用的。\n下面，我们从 NioEventLoopGroup 的无参构造方法开始，跟着源码走：\npublic NioEventLoopGroup() &#123;\n    this(0);\n&#125;\n\n然后一步步走下去，到这个构造方法：\npublic NioEventLoopGroup(int nThreads, ThreadFactory threadFactory, final SelectorProvider selectorProvider, final SelectStrategyFactory selectStrategyFactory) &#123;\n\n    super(nThreads, threadFactory, selectorProvider, selectStrategyFactory, RejectedExecutionHandlers.reject());\n&#125;\n\n大家自己要去跟一下源码，这样才知道中间设置了哪些默认值，下面这几个参数都被设置了默认值：\n\nselectorProvider = SelectorProvider.provider()\n\n\n\n\n\n\n\n\n\n\n这个没什么好说的，调用了 JDK 提供的方法\n\nselectStrategyFactory = DefaultSelectStrategyFactory.INSTANCE\n\n\n\n\n\n\n\n\n\n\n这个涉及到的是线程在做 select 操作和执行任务过程中的策略选择问题，在介绍 NioEventLoop 的时候会用到。\n\nrejectedExecutionHandler = RejectedExecutionHandlers.reject()\n\n\n\n\n\n\n\n\n\n\n大家进去看一下 reject() 方法，也就是说，Netty 选择的默认拒绝策略是：抛出异常\n跟着源码走，我们会来到父类 MultithreadEventLoopGroup 的构造方法中：\nprotected MultithreadEventLoopGroup(int nThreads, ThreadFactory threadFactory, Object... args) &#123;\n    super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, threadFactory, args);\n&#125;\n\n这里我们发现，如果采用无参构造函数，那么到这里的时候，默认地 nThreads 会被设置为 **CPU 核心数 *2**。大家可以看下 DEFAULT_EVENT_LOOP_THREADS 的默认值，以及 static 代码块的设值逻辑。\n我们继续往下走：\nprotected MultithreadEventExecutorGroup(int nThreads, ThreadFactory threadFactory, Object...args) &#123;\n    this(nThreads, threadFactory == null ? null : new ThreadPerTaskExecutor(threadFactory), args);\n&#125;\n\n到这一步的时候，new ThreadPerTaskExecutor(threadFactory) 会构造一个 executor。\n\n\n\n\n\n\n\n\n\n我们现在还不知道这个 executor 怎么用。这里我们先看下它的源码：\nExecutor 作为线程池的最顶层接口， 我们知道，它只有一个 execute(runnable) 方法，从上面我们可以看到，实现类 ThreadPerTaskExecutor 的逻辑就是每来一个任务，新建一个线程。\n我们先记住这个，前面也说了，它是给 NioEventLoop 用的，不是给 NioEventLoopGroup 用的。\npublic final class ThreadPerTaskExecutor implements Executor &#123;\n     private final ThreadFactory threadFactory;\n\n     public ThreadPerTaskExecutor(ThreadFactory threadFactory) &#123;\n           if (threadFactory == null) &#123;\n               throw new NullPointerException(\"threadFactory\");\n           &#125;\n           this.threadFactory = threadFactory;\n     &#125;\n\n     @Override\n     public void execute(Runnable command) &#123;\n           // 为每个任务新建一个线程\n           threadFactory.newThread(command).start();\n     &#125;\n&#125;\n\n上一步设置完了 executor，我们继续往下看：\nprotected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object...args) &#123;\n    this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);\n&#125;\n\n这一步设置了 chooserFactory，用来实现从线程池中选择一个线程的选择策略。\n\n\n\n\n\n\n\n\n\nChooserFactory 的逻辑比较简单，我们看下 DefaultEventExecutorChooserFactory 的实现：\n这里设置的策略也很简单：\n1、如果线程池的线程数量是 2^n，采用下面的方式会高效一些：\n2、如果不是，用取模的方式：\n@Override\npublic EventExecutorChooser newChooser(EventExecutor[] executors) &#123;\n     if (isPowerOfTwo(executors.length)) &#123;\n           return new PowerOfTwoEventExecutorChooser(executors);\n     &#125; else &#123;\n           return new GenericEventExecutorChooser(executors);\n     &#125;\n&#125;\n\n@Override\npublic EventExecutor next() &#123;\n     return executors[idx.getAndIncrement() &amp; executors.length - 1];\n&#125;\n\n@Override\npublic EventExecutor next() &#123;\n     return executors[Math.abs(idx.getAndIncrement() % executors.length)];\n&#125;\n\n走了这么久，我们终于到了一个干实事的构造方法中了。\nio.netty.util.concurrent.MultithreadEventExecutorGroup\nprotected MultithreadEventExecutorGroup(int nThreads, Executor executor,\n                                        EventExecutorChooserFactory chooserFactory, Object... args) &#123;\n    if (nThreads &lt;= 0) &#123;\n        throw new IllegalArgumentException(String.format(\"nThreads: %d (expected: > 0)\", nThreads));\n    &#125;\n\n    // executor 如果是 null，做一次和前面一样的默认设置。\n    if (executor == null) &#123;\n        executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());\n    &#125;\n\n    // 这里的 children 数组非常重要，它就是线程池中的线程数组，这么说不太严谨，但是就大概这个意思\n    children = new EventExecutor[nThreads];\n\n    // 下面这个 for 循环将实例化 children 数组中的每一个元素\n    for (int i = 0; i &lt; nThreads; i ++) &#123;\n        boolean success = false;\n        try &#123;\n            // 实例化！！！！！！\n            children[i] = newChild(executor, args);\n            success = true;\n        &#125; catch (Exception e) &#123;\n            // TODO: Think about if this is a good exception type\n            throw new IllegalStateException(\"failed to create a child event loop\", e);\n        &#125; finally &#123;\n            // 如果有一个 child 实例化失败，那么 success 就会为 false，然后进入下面的失败处理逻辑\n            if (!success) &#123;\n                // 把已经成功实例化的“线程” shutdown，shutdown 是异步操作\n                for (int j = 0; j &lt; i; j ++) &#123;\n                    children[j].shutdownGracefully();\n                &#125;\n\n                // 等待这些线程成功 shutdown\n                for (int j = 0; j &lt; i; j ++) &#123;\n                    EventExecutor e = children[j];\n                    try &#123;\n                        while (!e.isTerminated()) &#123;\n                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);\n                        &#125;\n                    &#125; catch (InterruptedException interrupted) &#123;\n                        // 把中断状态设置回去，交给关心的线程来处理.\n                        Thread.currentThread().interrupt();\n                        break;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    // ================================================\n    // === 到这里，就是代表上面的实例化所有线程已经成功结束 ===\n    // ================================================\n\n    // 通过之前设置的 chooserFactory 来实例化 Chooser，把线程池数组传进去，\n    //     这就不必再说了吧，实现线程选择策略\n    chooser = chooserFactory.newChooser(children);\n\n    // 设置一个 Listener 用来监听该线程池的 termination 事件\n    // 下面的代码逻辑是：给池中每一个线程都设置这个 listener，当监听到所有线程都 terminate 以后，这个线程池就算真正的 terminate 了。\n    final FutureListener&lt;Object> terminationListener = new FutureListener&lt;Object>() &#123;\n        @Override\n        public void operationComplete(Future&lt;Object> future) throws Exception &#123;\n            if (terminatedChildren.incrementAndGet() == children.length) &#123;\n                terminationFuture.setSuccess(null);\n            &#125;\n        &#125;\n    &#125;;\n    for (EventExecutor e: children) &#123;\n        e.terminationFuture().addListener(terminationListener);\n    &#125;\n\n    // 设置 readonlyChildren，它是只读集合，以后用到再说\n    Set&lt;EventExecutor> childrenSet = new LinkedHashSet&lt;EventExecutor>(children.length);\n    Collections.addAll(childrenSet, children);\n    readonlyChildren = Collections.unmodifiableSet(childrenSet);\n&#125;\n\n上面的代码非常简单吧，没有什么需要特别说的，接下来，我们来看看 newChild() 这个方法，这个方法非常重要，它将创建线程池中的线程。\n\n\n\n\n\n\n\n\n\n我上面已经用过很多次”线程”这个词了，它可不是 Thread 的意思，而是指池中的个体，后面我们会看到每个”线程”在什么时候会真正创建 Thread 实例。反正每个 NioEventLoop 实例内部都会有一个自己的 Thread 实例，所以把这两个概念混在一起也无所谓吧。\nnewChild(…) 方法在 NioEventLoopGroup 中覆写了，上面说的”线程”其实就是 NioEventLoop：\n@Override\nprotected EventLoop newChild(Executor executor, Object... args) throws Exception &#123;\n    return new NioEventLoop(this, executor, (SelectorProvider) args[0],\n        ((SelectStrategyFactory) args[1]).newSelectStrategy(), (RejectedExecutionHandler) args[2]);\n&#125;\n\n它调用了 NioEventLoop 的构造方法：\nNioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,\n             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;\n    // 调用父类构造器\n    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);\n    if (selectorProvider == null) &#123;\n        throw new NullPointerException(\"selectorProvider\");\n    &#125;\n    if (strategy == null) &#123;\n        throw new NullPointerException(\"selectStrategy\");\n    &#125;\n    provider = selectorProvider;\n    // 开启 NIO 中最重要的组件：Selector\n    final SelectorTuple selectorTuple = openSelector();\n    selector = selectorTuple.selector;\n    unwrappedSelector = selectorTuple.unwrappedSelector;\n    selectStrategy = strategy;\n&#125;\n\n我们先粗略观察一下，然后再往下看：\n\n在 Netty 中，NioEventLoopGroup 代表线程池，NioEventLoop 就是其中的线程。\n线程池 NioEventLoopGroup 是池中的线程 NioEventLoop 的 parent，从上面的代码中的取名可以看出。\n每个 NioEventLoop 都有自己的 Selector，上面的代码也反应了这一点，这和 Tomcat 中的 NIO 模型有点区别。\nexecutor、selectStrategy 和 rejectedExecutionHandler 从 NioEventLoopGroup 中一路传到了 NioEventLoop 中。\n\n这个时候，我们来看一下 NioEventLoop 类的属性都有哪些，我们先忽略它继承自父类的属性，单单看它自己的：\nprivate Selector selector;\nprivate Selector unwrappedSelector;\nprivate SelectedSelectionKeySet selectedKeys;\n\nprivate final SelectorProvider provider;\n\nprivate final AtomicBoolean wakenUp = new AtomicBoolean();\n\nprivate final SelectStrategy selectStrategy;\n\nprivate volatile int ioRatio = 50;\nprivate int cancelledKeys;\nprivate boolean needsToSelectAgain;\n\n结合它的构造方法我们来总结一下：\n\nprovider：它由 NioEventLoopGroup 传进来，前面我们说了一个线程池有一个 selectorProvider，用于创建 Selector 实例 \nselector：虽然我们还没看创建 selector 的代码，但我们已经知道，在 Netty 中 Selector 是跟着线程池中的线程走的。也就是说，并非一个线程池一个 Selector 实例，而是线程池中每一个线程都有一个 Selector 实例。\n\n\n\n\n\n\n\n\n\n\n在无参构造过程中，我们发现，Netty 设置线程个数是 CPU 核心数的两倍，假设我们的机器 CPU 是 4 核，那么对应的就会有 8 个 Selector 实例。\n\nselectStrategy：select 操作的策略，这个不急。 \nioRatio：这是 IO 任务的执行时间比例，因为每个线程既有 IO 任务执行，也有非 IO 任务需要执行，所以该参数为了保证有足够时间是给 IO 的。这里也不需要急着去理解什么 IO 任务、什么非 IO 任务。\n\n然后我们继续走它的构造方法，我们看到上面的构造方法调用了父类的构造器，它的父类是 SingleThreadEventLoop。\nio.netty.channel.SingleThreadEventLoop :\nprotected static final int DEFAULT_MAX_PENDING_TASKS = Math.max(16,\n        SystemPropertyUtil.getInt(\"io.netty.eventLoop.maxPendingTasks\", Integer.MAX_VALUE));\n\nprotected SingleThreadEventLoop(EventLoopGroup parent, ThreadFactory threadFactory,\n                                boolean addTaskWakesUp, int maxPendingTasks,\n                                RejectedExecutionHandler rejectedExecutionHandler) &#123;\n    super(parent, threadFactory, addTaskWakesUp, maxPendingTasks, rejectedExecutionHandler);\n    tailTasks = newTaskQueue(maxPendingTasks);\n&#125;\n\nSingleThreadEventLoop 这个名字很诡异有没有？然后它的构造方法又调用了父类 SingleThreadEventExecutor 的构造方法。\nio.netty.util.concurrent.SingleThreadEventExecutor ：\nprotected SingleThreadEventExecutor(EventExecutorGroup parent, Executor executor,\n                                    boolean addTaskWakesUp, int maxPendingTasks,\n                                    RejectedExecutionHandler rejectedHandler) &#123;\n    super(parent);\n    this.addTaskWakesUp = addTaskWakesUp;\n    this.maxPendingTasks = Math.max(16, maxPendingTasks);\n    this.executor = ObjectUtil.checkNotNull(executor, \"executor\");\n    // taskQueue，这个东西很重要，提交给 NioEventLoop 的任务都会进入到这个 taskQueue 中等待被执行\n    // 这个 queue 的默认容量是 16\n    taskQueue = newTaskQueue(this.maxPendingTasks);\n    rejectedExecutionHandler = ObjectUtil.checkNotNull(rejectedHandler, \"rejectedHandler\");\n&#125;\n\nprotected Queue&lt;Runnable> newTaskQueue(int maxPendingTasks) &#123;\n  \treturn new LinkedBlockingQueue&lt;Runnable>(maxPendingTasks);\n&#125;\n\n\n到这里就更加诡异了，NioEventLoop 的父类是 SingleThreadEventLoop，而 SingleThreadEventLoop 的父类是 **SingleThreadEventExecutor**，它的名字告诉我们，它是一个 Executor，是一个线程池，而且是 Single Thread 单线程的。\n也就是说，线程池 NioEventLoopGroup 中的每一个线程 NioEventLoop 也可以当做一个线程池来用，只不过它只有一个线程。这种设计虽然看上去很巧妙，不过有点反人类的样子。\n上面这个构造函数比较简单：\n\n设置了 parent，也就是之前创建的线程池 NioEventLoopGroup 实例 \nexecutor：它是我们之前实例化的 ThreadPerTaskExecutor，我们说过，这个东西在线程池中没有用，它是给 NioEventLoop 用的，马上我们就要看到它了。提前透露一下，它用来开启 NioEventLoop 中的线程（Thread 实例）。 \ntaskQueue：这算是该构造方法中新的东西，它是任务队列。我们前面说过，NioEventLoop 需要负责 IO 事件和非 IO 事件，通常它都在执行 selector 的 select 方法或者正在处理 selectedKeys，如果我们要 submit 一个任务给它，任务就会被放到 taskQueue 中，等它来轮询。 \nrejectedExecutionHandler：taskQueue 的默认容量是 16，所以，如果 submit 的任务堆积了到了 16，再往里面提交任务会触发 rejectedExecutionHandler 的执行策略。\n\n\n\n\n\n\n\n\n\n\n还记得默认策略吗：抛出 RejectedExecutionException 异常。\n在 NioEventLoopGroup 的默认构造中，它的实现是这样的：\nprivate static final RejectedExecutionHandler REJECT = new RejectedExecutionHandler() &#123;\n    @Override\n    public void rejected(Runnable task, SingleThreadEventExecutor executor) &#123;\n        throw new RejectedExecutionException();\n    &#125;\n&#125;;\n\n\n然后，我们再回到 NioEventLoop 的构造方法：\nNioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider,\n             SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler) &#123;\n    // 我们刚刚说完了这个\n    super(parent, executor, false, DEFAULT_MAX_PENDING_TASKS, rejectedExecutionHandler);\n    if (selectorProvider == null) &#123;\n        throw new NullPointerException(\"selectorProvider\");\n    &#125;\n    if (strategy == null) &#123;\n        throw new NullPointerException(\"selectStrategy\");\n    &#125;\n    provider = selectorProvider;\n    // 创建 selector 实例\n    final SelectorTuple selectorTuple = openSelector();\n    selector = selectorTuple.selector;\n    unwrappedSelector = selectorTuple.unwrappedSelector;\n\n    selectStrategy = strategy;\n&#125;\n\n\n可以看到，最重要的方法其实就是 openSelector() 方法，它将创建 NIO 中最重要的一个组件 **Selector**。在这个方法中，Netty 也做了一些优化，这部分我们就不去分析它了。\n到这里，我们的线程池 NioEventLoopGroup 创建完成了，并且实例化了池中的所有 NioEventLoop 实例。\n同时，大家应该已经看到，上面并没有真正创建 NioEventLoop 中的线程（没有创建 Thread 实例）。\n提前透露一下，创建线程的时机在第一个任务提交过来的时候，那么第一个任务是什么呢？就是我们前面说的 channel 的 **register** 操作。\n\nNioEventLoop 的工作流程前面，我们在分析线程池的实例化的时候说过，NioEventLoop 中并没有启动 Java 线程。这里我们来仔细分析下在 register 过程中调用的 **eventLoop.execute(runnable)** 这个方法，这个代码在父类 SingleThreadEventExecutor 中。\nio.netty.util.concurrent.SingleThreadEventExecutor#execute\n@Override\npublic void execute(Runnable task) &#123;\n    if (task == null) &#123;\n        throw new NullPointerException(\"task\");\n    &#125;\n    // 判断添加任务的线程是否就是当前 EventLoop 中的线程\n    boolean inEventLoop = inEventLoop();\n\n    // 添加任务到之前介绍的 taskQueue 中，\n    //     如果 taskQueue 满了(默认大小 16)，根据我们之前说的，默认的策略是抛出异常\n    addTask(task);\n\n    if (!inEventLoop) &#123;\n        // 如果不是 NioEventLoop 内部线程提交的 task，那么判断下线程是否已经启动，没有的话，就启动线程\n        startThread();\n        if (isShutdown() &amp;&amp; removeTask(task)) &#123;\n            reject();\n        &#125;\n    &#125;\n\n    if (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;\n        wakeup(inEventLoop);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n\n原来启动 NioEventLoop 中的线程的方法在这里。\n另外，上节我们说的 register 操作进到了 taskQueue 中，所以它其实是被归类到了非 IO 操作的范畴。\n下面是 startThread 的源码，判断线程是否已经启动来决定是否要进行启动操作。\nio.netty.util.concurrent.SingleThreadEventExecutor#startThread\nprivate void startThread() &#123;\n    if (state == ST_NOT_STARTED) &#123;\n        if (STATE_UPDATER.compareAndSet(this, ST_NOT_STARTED, ST_STARTED)) &#123;\n            try &#123;\n                doStartThread();\n            &#125; catch (Throwable cause) &#123;\n                STATE_UPDATER.set(this, ST_NOT_STARTED);\n                PlatformDependent.throwException(cause);\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n\n我们按照前面的思路，根据线程没有启动的情况，来看看 doStartThread() 方法：\nio.netty.util.concurrent.SingleThreadEventExecutor#doStartThread\nprivate void doStartThread() &#123;\n    assert thread == null;\n    // 这里的 executor 大家是不是有点熟悉的感觉，它就是一开始我们实例化 NioEventLoop 的时候传进来的 ThreadPerTaskExecutor 的实例。它是每次来一个任务，创建一个线程的那种 executor。\n    // 一旦我们调用它的 execute 方法，它就会创建一个新的线程，所以这里终于会创建 Thread 实例\n    executor.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n            // 看这里，将 “executor” 中创建的这个线程设置为 NioEventLoop 的线程！！！\n            thread = Thread.currentThread();\n\n            if (interrupted) &#123;\n                thread.interrupt();\n            &#125;\n\n            boolean success = false;\n            updateLastExecutionTime();\n            try &#123;\n                // 执行 SingleThreadEventExecutor 的 run() 方法，它在 NioEventLoop 中实现了\n                SingleThreadEventExecutor.this.run();\n                success = true;\n            &#125; catch (Throwable t) &#123;\n                logger.warn(\"Unexpected exception from an event executor: \", t);\n            &#125; finally &#123;\n                // ... 我们直接忽略掉这里的代码\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n\n\n上面线程启动以后，会执行 NioEventLoop 中的 run() 方法，这是一个非常重要的方法，这个方法肯定是没那么容易结束的，必然是像 JDK 线程池的 Worker 那样，不断地循环获取新的任务的。它需要不断地做 select 操作和轮询 taskQueue 这个队列。\n我们先来简单地看一下它的源码，这里先不做深入地介绍。\nio.netty.channel.nio.NioEventLoop#run\n@Override\nprotected void run() &#123;\n    // 代码嵌套在 for 循环中\n    for (;;) &#123;\n        try &#123;\n            // selectStrategy 终于要派上用场了\n            // 它有两个值，一个是 CONTINUE 一个是 SELECT\n            // 针对这块代码，我们分析一下。\n            // 1. 如果 taskQueue 不为空，也就是 hasTasks() 返回 true，\n            //         那么执行一次 selectNow()，该方法不会阻塞\n            // 2. 如果 hasTasks() 返回 false，那么执行 SelectStrategy.SELECT 分支，\n            //    进行 select(...)，这块是带阻塞的\n            // 这个很好理解，就是按照是否有任务在排队来决定是否可以进行阻塞\n            switch (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;\n                case SelectStrategy.CONTINUE:\n                    continue;\n                case SelectStrategy.SELECT:\n                    // 如果 !hasTasks()，那么进到这个 select 分支，这里 select 带阻塞的\n                    select(wakenUp.getAndSet(false));\n                    if (wakenUp.get()) &#123;\n                        selector.wakeup();\n                    &#125;\n                default:\n            &#125;\n\n\n            cancelledKeys = 0;\n            needsToSelectAgain = false;\n            // 默认地，ioRatio 的值是 50\n            final int ioRatio = this.ioRatio;\n\n            if (ioRatio == 100) &#123;\n                // 如果 ioRatio 设置为 100，那么先执行 IO 操作，然后在 finally 块中执行 taskQueue 中的任务\n                try &#123;\n                    // 1. 执行 IO 操作。因为前面 select 以后，可能有些 channel 是需要处理的。\n                    processSelectedKeys();\n                &#125; finally &#123;\n                    // 2. 执行非 IO 任务，也就是 taskQueue 中的任务\n                    runAllTasks();\n                &#125;\n            &#125; else &#123;\n                // 如果 ioRatio 不是 100，那么根据 IO 操作耗时，限制非 IO 操作耗时\n                final long ioStartTime = System.nanoTime();\n                try &#123;\n                    // 执行 IO 操作\n                    processSelectedKeys();\n                &#125; finally &#123;\n                    // 根据 IO 操作消耗的时间，计算执行非 IO 操作（runAllTasks）可以用多少时间.\n                    final long ioTime = System.nanoTime() - ioStartTime;\n                    runAllTasks(ioTime * (100 - ioRatio) / ioRatio);\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n        // Always handle shutdown even if the loop processing threw an exception.\n        try &#123;\n            if (isShuttingDown()) &#123;\n                closeAll();\n                if (confirmShutdown()) &#123;\n                    return;\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            handleLoopException(t);\n        &#125;\n    &#125;\n&#125;\n\n\n上面这段代码是 NioEventLoop 的核心，这里介绍两点：\n\n首先，会根据 hasTasks() 的结果来决定是执行 selectNow() 还是 select(oldWakenUp)，这个应该好理解。如果有任务正在等待，那么应该使用无阻塞的 selectNow()，如果没有任务在等待，那么就可以使用带阻塞的 select 操作。\nioRatio 控制 IO 操作所占的时间比重： \n如果设置为 100%，那么先执行 IO 操作，然后再执行任务队列中的任务。\n如果不是 100%，那么先执行 IO 操作，然后执行 taskQueue 中的任务，但是需要控制执行任务的总时间。也就是说，非 IO 操作可以占用的时间，通过 ioRatio 以及这次 IO 操作耗时计算得出。\n\n\n\n我们这里先不要去关心 select(oldWakenUp) 、processSelectedKeys() 方法和 runAllTasks(…) 方法的细节，只要先理解它们分别做什么事情就可以了。\n回过神来，我们前面在 register 的时候提交了 register 任务给 NioEventLoop，这是 NioEventLoop 接收到的第一个任务，所以这里会实例化 Thread 并且启动，然后进入到 NioEventLoop 中的 run 方法。\n\n\n\n\n\n\n\n\n\n当然了，实际情况可能是，Channel 实例被 register 到一个已经启动线程的 NioEventLoop 实例中。\n","slug":"Netty源码分析","date":"2022-06-11T08:38:37.855Z","categories_index":"源码","tags_index":"java,Netty,源码","author_index":"小李不在_"},{"id":"0cb8b12f38f1e4c52cf2229e17b82a90","title":"Dubbo源码分析","content":"准备什么是 Dubbo?Apache Dubbo (incubating) |ˈdʌbəʊ|  是一款高性能、轻量级的开源 Java RPC 框架。\n根据 Dubbo 官方文档的介绍，Dubbo 提供了六大核心能力\n\n面向接口代理的高性能RPC调用。\n智能容错和负载均衡。\n服务自动注册和发现。\n高度可扩展能力。\n运行期流量调度。\n可视化的服务治理与运维。\n\n\n简单来说就是： Dubbo 不光可以帮助我们调用远程服务，还提供了一些其他开箱即用的功能比如智能负载均衡。\nDubbo 目前已经有接近 34.4 k 的 Star  。\n在 2020 年度 OSC 中国开源项目 评选活动中，Dubbo 位列开发框架和基础组件类项目的第7名。想比几年前来说，热度和排名有所下降。\n\nDubbo 是由阿里开源，后来加入了 Apache 。正式由于 Dubbo 的出现，才使得越来越多的公司开始使用以及接受分布式架构。\n\n为什么要用 Dubbo?随着互联网的发展，网站的规模越来越大，用户数量越来越多。单一应用架构 、垂直应用架构无法满足我们的需求，这个时候分布式服务架构就诞生了。\n分布式服务架构下，系统被拆分成不同的服务比如短信服务、安全服务，每个服务独立提供系统的某个核心服务。\n我们可以使用 Java RMI（Java Remote Method Invocation）、Hessian这种支持远程调用的框架来简单地暴露和引用远程服务。但是！当服务越来越多之后，服务调用关系越来越复杂。当应用访问压力越来越大后，负载均衡以及服务监控的需求也迫在眉睫。我们可以用 F5 这类硬件来做负载均衡，但这样增加了成本，并且存在单点故障的风险。\n不过，Dubbo 的出现让上述问题得到了解决。Dubbo 帮助我们解决了什么问题呢？\n\n负载均衡 ： 同一个服务部署在不同的机器时该调用那一台机器上的服务。\n服务调用链路生成  ： 随着系统的发展，服务越来越多，服务间依赖关系变得错踪复杂，甚至分不清哪个应用要在哪个应用之前启动，架构师都不能完整的描述应用的架构关系。Dubbo 可以为我们解决服务之间互相是如何调用的。\n服务访问压力以及时长统计、资源调度和治理 ：基于访问压力实时管理集群容量，提高集群利用率。\n……\n\n\n另外，Dubbo 除了能够应用在分布式系统中，也可以应用在现在比较火的微服务系统中。不过，由于 Spring Cloud 在微服务中应用更加广泛，所以，我觉得一般我们提 Dubbo 的话，大部分是分布式系统的情况。\n\nDubbo 的架构设计官方文档中的框架设计章节 已经介绍的非常详细了，我这里把两个比较重要的点再提一下。\n\n核心角色\n上述节点简单介绍以及他们之间的关系：\n\nContainer： 服务运行容器，负责加载、运行服务提供者。必须。\nProvider： 暴露服务的服务提供方，会向注册中心注册自己提供的服务。必须。\nConsumer： 调用远程服务的服务消费方，会向注册中心订阅自己所需的服务。必须。\nRegistry： 服务注册与发现的注册中心。注册中心会返回服务提供者地址列表给消费者。非必须。\nMonitor： 统计服务的调用次数和调用时间的监控中心。服务消费者和提供者会定时发送统计数据到监控中心。 非必须。\n\n一些用于自测的小问题（面试中可能会遇到）：\n\n注册中心的作用？ 注册中心负责服务地址的注册与查找，相当于目录服务，服务提供者和消费者只在启动时与注册中心交互。\n监控中心的作用？ 监控中心负责统计各服务调用次数，调用时间等。\n服务提供者宕机后，注册中心会做什么？  注册中心会立即推送事件通知消费者。\n注册中心和监控中心都宕机的话，服务都会挂掉吗？ 不会。两者都宕机也不影响已运行的提供者和消费者，消费者在本地缓存了提供者列表。注册中心和监控中心都是可选的，服务消费者可以直连服务提供者。\n\n\n整体设计下图是 Dubbo 的整体设计，从下至上分为十层，各层均为单向依赖。\n\n\n\n\n\n\n\n\n\n左边淡蓝背景的为服务消费方使用的接口，右边淡绿色背景的为服务提供方使用的接口，位于中轴线上的为双方都用到的接口。\n\n\nconfig 配置层：Dubbo相关的配置。支持代码配置，同时也支持基于 Spring  来做配置，以 ServiceConfig, ReferenceConfig 为中心\nproxy 服务代理层：调用远程方法像调用本地的方法一样简单的一个关键，真实调用过程依赖代理类，以 ServiceProxy 为中心。\nregistry 注册中心层：封装服务地址的注册与发现。\ncluster 路由层：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心。\nmonitor 监控层：RPC 调用次数和调用时间监控，以 Statistics 为中心。\nprotocol 远程调用层：封装 RPC 调用，以 Invocation, Result 为中心。\nexchange 信息交换层：封装请求响应模式，同步转异步，以 Request, Response 为中心。\ntransport 网络传输层：抽象 mina 和 netty 为统一接口，以 Message 为中心。\nserialize 数据序列化层 ：对需要在网络传输的数据进行序列化。\n\n\n基本设计原则\n微内核架构Dubbo 采用微内核（Microkernel） + 插件（Plugin） 模式，简单来说就是微内核架构。微内核只负责组装插件。\n何为微内核架构呢？ 《软件架构模式》 这本书是这样介绍的：\n\n\n\n\n\n\n\n\n\n微内核架构模式（有时被称为插件架构模式）是实现基于产品应用程序的一种自然模式。基于产品的应用程序是已经打包好并且拥有不同版本，可作为第三方插件下载的。然后，很多公司也在开发、发布自己内部商业应用像有版本号、说明及可加载插件式的应用软件（这也是这种模式的特征）。微内核系统可让用户添加额外的应用如插件，到核心应用，继而提供了可扩展性和功能分离的用法。\n微内核架构包含两类组件：核心系统（core system） 和 插件模块（plug-in modules）。\n\n核心系统提供系统所需核心能力，插件模块可以扩展系统的功能。因此， 基于微内核架构的系统，非常易于扩展功能。\n我们常见的一些IDE，都可以看作是基于微内核架构设计的。绝大多数 IDE比如IDEA、VSCode都提供了插件来丰富自己的功能。\n正是因为Dubbo基于微内核架构，才使得我们可以随心所欲替换Dubbo的功能点。比如你觉得Dubbo 的序列化模块实现的不满足自己要求，没关系啊！你自己实现一个序列化模块就好了啊！\n通常情况下，微核心都会采用 Factory、IoC、OSGi 等方式管理插件生命周期。Dubbo 不想依赖 Spring 等 IoC 容器，也不想自已造一个小的 IoC 容器（过度设计），因此采用了一种最简单的 Factory 方式管理插件 ：JDK 标准的 SPI 扩展机制 （java.util.ServiceLoader）。\n\nURL 传递配置信息采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。有什么好处呢？  形成规范，提升代码可读性，降低代码理解成本。\n\n模块分包\n\n\n\n\n\n\n\n\n以下内容来自官方文档：https://dubbo.apache.org/zh/docs/v2.7/dev/design/ 。\n\n模块说明：\n\ndubbo-common 公共逻辑模块：包括 Util 类和通用模型。\ndubbo-remoting 远程通讯模块：相当于 Dubbo 协议的实现，如果 RPC 用 RMI协议则不需要使用此包。\ndubbo-rpc 远程调用模块：抽象各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\ndubbo-cluster 集群模块：将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\ndubbo-registry 注册中心模块：基于注册中心下发地址的集群方式，以及对各种注册中心的抽象。\ndubbo-monitor 监控模块：统计服务调用次数，调用时间的，调用链跟踪的服务。\ndubbo-config 配置模块：是 Dubbo 对外的 API，用户通过 Config 使用Dubbo，隐藏 Dubbo 所有细节。\ndubbo-container 容器模块：是一个 Standlone 的容器，以简单的 Main 加载 Spring 启动，因为服务通常不需要 Tomcat&#x2F;JBoss 等 Web 容器的特性，没必要用 Web 容器去加载服务。\n\n\n前言在《如何自己实现一个 RPC框架》中我们介绍到一个最基本的 RPC 框架应该包括下面几部分:\n\n注册中心 ：注册中心负责服务地址的注册与查找，相当于目录服务。\n网络传输 ：既然我们要调用远程的方法，就要发送网络请求来传递目标类和方法的信息以及方法的参数等数据到服务提供端。\n序列化和反序列化 ：要在网络传输数据就要涉及到序列化。\n动态代理 ：屏蔽程方法调用的底层细节。\n负载均衡  ： 避免单个服务器响应同一请求，容易造成服务器宕机、崩溃等问题。\n传输协议 ：这个协议是客户端（服务消费方）和服务端（服务提供方）交流的基础。\n\n更完善的一点的 RPC 框架可能还有监控模块。\nDubbo 是比较成熟的 RPC 框架了，它当然满足我们所说的这些要求，我们看一下 Dubbo 源码的模块结构就可以看出来了。\n\nDubbo 核心模块介绍\ndubbo-common(公共逻辑模块)\n这部分主要是一些通用工具类（Util）比如Dubbo 对 SPI（org.apache.dubbo.common.extension）、时间轮算法(org.apache.dubbo.common.timer)的实现都放在这个模块下。\n除了工具类之外，dubbo-common 还包括一些通用模型比如 URL（Dubbo 通过URL 传递配置信息）。\n\ndubbo-remoting (网络传输模块)\n想要调用远程方法，必然涉及到网络传输。网络传输模块很大程度决定了Dubbo的性能和稳定性，所以，这块的设计非常重要。\ndubbo-remoting-api 模块是整个网络传输模块的抽象，定义了一些网络传输模块必须要实现的接口以及通用的一些实现，dubbo-remoting 模块下的其他模块都要对其进行实现。\n从上图可以看出，Dubbo 的网络传输模块有多种实现方式。除了我们比较熟悉的 Netty 实现方式之外，还有Grizzly、Mina等实现方式。\nNetty、Grizzly、Mina三者都是基于 Java NIO，并且Netty相比于其他两者封装和设计的要更好一些。\n\ndubbo-registry (注册中心模块)\n注册中心相当于服务提供者和消费者中间的桥梁，负责服务地址的注册与查找，相当于目录服务。\ndubbo-registry-api 模块是整个注册中心传输模块的抽象，定义了一些注册中心模块必须要实现的接口以及通用的一些实现。\nDubbo 的注册中心输模块也有多种实现方式。除了我们比较熟悉的 zookeeper、nacos 实现方式之外，还有mutilcast、redis等实现方式。\n一般情况下，我们都是使用zookeeper作为注册中心，这也是 Dubbo 官方推荐的一种方式。\n\n\ndubbo-config(配置模块)\n我们在源码环境那一节中提到： dubbo-demo 模块下，包含了 3 种不同类型（xml、api、annotation）配置方式使用 Dubbo 的demo。\ndubbo-config  就是对这些配置方式的实现。\n\ndubbo-config-api ：API配置方式的实现（纯代码使用）。\ndubbo-config-spring ：XML和注解方式的实现。\n\n\ndubbo-monitor (监控模块)监控模块主要统计服务调用次数，调用时间的，调用链跟踪的服务。\n从上图可以看出，监控模块只有一个默认实现。\n\ndubbo-rpc(远程调用模块)\ndubbo-rpc 模块抽象了各种协议，以及动态代理，只包含一对一的调用，不关心集群的管理。\n从“远程调用模块” 这个名字中，我们大概就能推断出 dubbo-rpc 模块依赖了网络传输模块（dubbo-remoting）。\ndubbo-rpc-api 模块是整个远程调用模块的抽象，定义了一些远程调用模块必须要实现的接口以及通用的一些实现。\nDubbo 本身就提供了多种协议实现比如 dubbo协议、hession协议、gRPC协议，不过官方更推荐使用dubbo协议。并且，还给出了一份性能测试报告。\n\ndubbo-cluster(集群模块)\ndubbo-cluster 模块将多个服务提供方伪装为一个提供方，包括：负载均衡, 容错，路由等，集群的地址列表可以是静态配置的，也可以是由注册中心下发。\n\n前言你给面试官说：“我阅读过 Dubbo 的源码，觉得那块设计的比较好”。结果，你自己连Dubbo 源码阅读环境都没搭建过的话，尴尬不？\nDubbo官方也有对应的源码环境搭建教程（@源码构建），不过我的更详细完善一点。并且，更清晰易懂。一些你们可能我踩的坑，我都提前指了出来，避免没有必要的时间浪费。\n\n环境准备\nIDEA：建议使用 IDEA 作为 IDE。\nMaven 3.6.5 ：Dubbo 使用 maven 作为构建工具。\nJDK 1.8  ：JDK 1.8 版本即可。\n\n\nDubbo 源码阅读环境搭建\n克隆项目到本地我们先克隆项目到本地(建议 fork 一份项目到自己的仓库中再克隆，版本建议 dubbo-2.6.4)。\ngit clone https://github.com/apache/dubbo.git dubbo\n\n\n使用 IDEA 打开项目项目克隆完成之后，推荐使用 IDEA 打开。打开之后，可能需要一会时间下载项目所依赖的 jar包，我们喝杯咖啡，耐心等待即可。\n\n\n\n\n\n\n\n\n\n下载jar包的过程中，很可能会遇到某些 jar 包出现问题的情况，导致项目多处报红，显示相关依赖导入错误。解决的办法就是：你去自己本地的 Maven仓库找到对应的  jar 包，将其删除，然后重新导入项目下载即可。\n\n构建项目如果我们的项目相关的 jar 包下载完成，我们就可以开始构建项目了。你可以使用下面两种方式的任意一种：\n（1）使用下面的命令构建项目了：\nmvn install -Dmaven.test.skip #构建并跳过单元测试\n\n（2）不同过命令的方式：\n首先点击跳过测试，然后点击clean 和 install。\n\n\n验证源码环境是否搭建成功这些事情做完之后，我们需要验证一下 Dubbo 源码阅读环境是否真的搭建成功了。怎么来验证呢？\n非常简单，不需要自己手动写 Demo 了。项目源码已经自带了一些使用 Dubbo 的Demo，我们直接运行即可。\n我们找到 dubbo-demo 这个文件夹，里面包含了 3 种不同类型（xml、api、annotation）使用方式的 demo，可以帮助我们节省掉大量写 Demo 的时间。\n\n这些 Demo 都是使用 zookeepeer 作为注册中心的，所以我们还需要提前下载 zookeeper 到本地。\n我这里建议下载 3.4.12 版本的 zookeeper ,避免出现其他问题。我们直接使用 Docker 进行下载就行了，方便简单。\ndocker pull zookeeper:3.4.12\n\n然后，使用下面的命令运行。\ndocker run -d --name zookeeper3.4.12 -p 2181:2181 zookeeper:3.4.12\n\n我们随便找到一个 Demo ，我这里以 api 使用的方式来说明一下。\n我们找到 dubbo-demo-api 这个文件夹，然后先启动服务提供者，再启动服务生产者：\n\n启动服务提供者 ：直接运行 dubbo-demo-api-provider （服务提供者）下的 Application  即可。服务提供者启动成功之后，控制台会打印出服务被注册的一些信息。\n启动服务消费者 ：直接运行 dubbo-demo-api-consumer （服务提供者）下的 Application  即可。服务消费者启动成功之后，控制台会打印出调用服务提供者的sayHello()方法返回的结果。\n\n启动过程中可能会出现的问题：java.nio.channels.UnresolvedAddressException 。\n出现这种问题的原因大概是你的 JDK 版本是 JDK14,你只需要将 JDK 版本调整到对应的 JDK 8 即可。\n\n源码分析\nDubbo SPI1.简介SPI 全称为 Service Provider Interface，是一种服务发现机制。SPI 的本质是将接口实现类的全限定名配置在文件中，并由服务加载器读取配置文件，加载实现类。这样可以在运行时，动态为接口替换实现类。正因此特性，我们可以很容易的通过 SPI 机制为我们的程序提供拓展功能。SPI 机制在第三方框架中也有所应用，比如 Dubbo 就是通过 SPI 机制加载所有的组件。不过，Dubbo 并未使用 Java 原生的 SPI 机制，而是对其进行了增强，使其能够更好的满足需求。在 Dubbo 中，SPI 是一个非常重要的模块。基于 SPI，我们可以很容易的对 Dubbo 进行拓展。如果大家想要学习 Dubbo 的源码，SPI 机制务必弄懂。接下来，我们先来了解一下 Java SPI 与 Dubbo SPI 的用法，然后再来分析 Dubbo SPI 的源码。\n需要特别说明的是，本篇文章以及本系列其他文章所分析的源码版本均为 dubbo-2.6.4。因此大家在阅读文章的过程中，需注意将代码版本切换到 dubbo-2.6.4 tag 上。\n\n2.SPI 示例\n2.1 Java SPI 示例前面简单介绍了 SPI 机制的原理，本节通过一个示例演示 Java SPI 的使用方法。首先，我们定义一个接口，名称为 Robot。\npublic interface Robot &#123;\n    void sayHello();\n&#125;\n\n接下来定义两个实现类，分别为 OptimusPrime 和 Bumblebee。\npublic class OptimusPrime implements Robot &#123;\n    \n    @Override\n    public void sayHello() &#123;\n        System.out.println(\"Hello, I am Optimus Prime.\");\n    &#125;\n&#125;\n\npublic class Bumblebee implements Robot &#123;\n\n    @Override\n    public void sayHello() &#123;\n        System.out.println(\"Hello, I am Bumblebee.\");\n    &#125;\n&#125;\n\n接下来 META-INF/services 文件夹下创建一个文件，名称为 Robot 的全限定名  org.apache.spi.Robot。文件内容为实现类的全限定的类名，如下：\norg.apache.spi.OptimusPrime\norg.apache.spi.Bumblebee\n\n做好所需的准备工作，接下来编写代码进行测试。\npublic class JavaSPITest &#123;\n\n    @Test\n    public void sayHello() throws Exception &#123;\n        ServiceLoader&lt;Robot> serviceLoader = ServiceLoader.load(Robot.class);\n        System.out.println(\"Java SPI\");\n        serviceLoader.forEach(Robot::sayHello);\n    &#125;\n&#125;\n\n最后来看一下测试结果，如下：\n\n从测试结果可以看出，我们的两个实现类被成功的加载，并输出了相应的内容。关于 Java SPI 的演示先到这里，接下来演示 Dubbo SPI。\n\n2.2 Dubbo SPI 示例Dubbo 并未使用 Java SPI，而是重新实现了一套功能更强的 SPI 机制。Dubbo SPI 的相关逻辑被封装在了 ExtensionLoader 类中，通过 ExtensionLoader，我们可以加载指定的实现类。Dubbo SPI 所需的配置文件需放置在 META-INF/dubbo 路径下，配置内容如下。\noptimusPrime &#x3D; org.apache.spi.OptimusPrime\nbumblebee &#x3D; org.apache.spi.Bumblebee\n\n与 Java SPI 实现类配置不同，Dubbo SPI 是通过键值对的方式进行配置，这样我们可以按需加载指定的实现类。另外，在测试 Dubbo SPI 时，需要在 Robot 接口上标注 @SPI 注解。下面来演示 Dubbo SPI 的用法：\npublic class DubboSPITest &#123;\n\n    @Test\n    public void sayHello() throws Exception &#123;\n        ExtensionLoader&lt;Robot> extensionLoader = \n            ExtensionLoader.getExtensionLoader(Robot.class);\n        Robot optimusPrime = extensionLoader.getExtension(\"optimusPrime\");\n        optimusPrime.sayHello();\n        Robot bumblebee = extensionLoader.getExtension(\"bumblebee\");\n        bumblebee.sayHello();\n    &#125;\n&#125;\n\n测试结果如下：\n\nDubbo SPI 除了支持按需加载接口实现类，还增加了 IOC 和 AOP 等特性，这些特性将会在接下来的源码分析章节中一一进行介绍。\n\n3. Dubbo SPI 源码分析上面简单演示了 Dubbo SPI 的使用方法。我们首先通过 ExtensionLoader 的 getExtensionLoader 方法获取一个 ExtensionLoader 实例，然后再通过 ExtensionLoader 的 getExtension 方法获取拓展类对象。这其中，getExtensionLoader 方法用于从缓存中获取与拓展类对应的 ExtensionLoader，若缓存未命中，则创建一个新的实例。该方法的逻辑比较简单，本章就不进行分析了。下面我们从 ExtensionLoader 的 getExtension 方法作为入口，对拓展类对象的获取过程进行详细的分析。\npublic T getExtension(String name) &#123;\n    if (name == null || name.length() == 0)\n        throw new IllegalArgumentException(\"Extension name == null\");\n    if (\"true\".equals(name)) &#123;\n        // 获取默认的拓展实现类\n        return getDefaultExtension();\n    &#125;\n    // Holder，顾名思义，用于持有目标对象\n    Holder&lt;Object> holder = cachedInstances.get(name);\n    if (holder == null) &#123;\n        cachedInstances.putIfAbsent(name, new Holder&lt;Object>());\n        holder = cachedInstances.get(name);\n    &#125;\n    Object instance = holder.get();\n    // 双重检查\n    if (instance == null) &#123;\n        synchronized (holder) &#123;\n            instance = holder.get();\n            if (instance == null) &#123;\n                // 创建拓展实例\n                instance = createExtension(name);\n                // 设置实例到 holder 中\n                holder.set(instance);\n            &#125;\n        &#125;\n    &#125;\n    return (T) instance;\n&#125;\n\n上面代码的逻辑比较简单，首先检查缓存，缓存未命中则创建拓展对象。下面我们来看一下创建拓展对象的过程是怎样的。\nprivate T createExtension(String name) &#123;\n    // 从配置文件中加载所有的拓展类，可得到“配置项名称”到“配置类”的映射关系表\n    Class&lt;?> clazz = getExtensionClasses().get(name);\n    if (clazz == null) &#123;\n        throw findException(name);\n    &#125;\n    try &#123;\n        T instance = (T) EXTENSION_INSTANCES.get(clazz);\n        if (instance == null) &#123;\n            // 通过反射创建实例\n            EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());\n            instance = (T) EXTENSION_INSTANCES.get(clazz);\n        &#125;\n        // 向实例中注入依赖\n        injectExtension(instance);\n        Set&lt;Class&lt;?>> wrapperClasses = cachedWrapperClasses;\n        if (wrapperClasses != null &amp;&amp; !wrapperClasses.isEmpty()) &#123;\n            // 循环创建 Wrapper 实例\n            for (Class&lt;?> wrapperClass : wrapperClasses) &#123;\n                // 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例。\n                // 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量\n                instance = injectExtension(\n                    (T) wrapperClass.getConstructor(type).newInstance(instance));\n            &#125;\n        &#125;\n        return instance;\n    &#125; catch (Throwable t) &#123;\n        throw new IllegalStateException(\"...\");\n    &#125;\n&#125;\n\ncreateExtension 方法的逻辑稍复杂一下，包含了如下的步骤：\n\n通过 getExtensionClasses 获取所有的拓展类\n通过反射创建拓展对象\n向拓展对象中注入依赖\n将拓展对象包裹在相应的 Wrapper 对象中\n\n以上步骤中，第一个步骤是加载拓展类的关键，第三和第四个步骤是 Dubbo IOC 与 AOP 的具体实现。在接下来的章节中，将会重点分析 getExtensionClasses 方法的逻辑，以及简单介绍 Dubbo IOC 的具体实现。\n\n3.1 获取所有的拓展类我们在通过名称获取拓展类之前，首先需要根据配置文件解析出拓展项名称到拓展类的映射关系表（Map&lt;名称, 拓展类&gt;），之后再根据拓展项名称从映射关系表中取出相应的拓展类即可。相关过程的代码分析如下：\nprivate Map&lt;String, Class&lt;?>> getExtensionClasses() &#123;\n    // 从缓存中获取已加载的拓展类\n    Map&lt;String, Class&lt;?>> classes = cachedClasses.get();\n    // 双重检查\n    if (classes == null) &#123;\n        synchronized (cachedClasses) &#123;\n            classes = cachedClasses.get();\n            if (classes == null) &#123;\n                // 加载拓展类\n                classes = loadExtensionClasses();\n                cachedClasses.set(classes);\n            &#125;\n        &#125;\n    &#125;\n    return classes;\n&#125;\n\n这里也是先检查缓存，若缓存未命中，则通过 synchronized 加锁。加锁后再次检查缓存，并判空。此时如果 classes 仍为 null，则通过 loadExtensionClasses 加载拓展类。下面分析 loadExtensionClasses 方法的逻辑。\nprivate Map&lt;String, Class&lt;?>> loadExtensionClasses() &#123;\n    // 获取 SPI 注解，这里的 type 变量是在调用 getExtensionLoader 方法时传入的\n    final SPI defaultAnnotation = type.getAnnotation(SPI.class);\n    if (defaultAnnotation != null) &#123;\n        String value = defaultAnnotation.value();\n        if ((value = value.trim()).length() > 0) &#123;\n            // 对 SPI 注解内容进行切分\n            String[] names = NAME_SEPARATOR.split(value);\n            // 检测 SPI 注解内容是否合法，不合法则抛出异常\n            if (names.length > 1) &#123;\n                throw new IllegalStateException(\"more than 1 default extension name on extension...\");\n            &#125;\n\n            // 设置默认名称，参考 getDefaultExtension 方法\n            if (names.length == 1) &#123;\n                cachedDefaultName = names[0];\n            &#125;\n        &#125;\n    &#125;\n\n    Map&lt;String, Class&lt;?>> extensionClasses = new HashMap&lt;String, Class&lt;?>>();\n    // 加载指定文件夹下的配置文件\n    loadDirectory(extensionClasses, DUBBO_INTERNAL_DIRECTORY);\n    loadDirectory(extensionClasses, DUBBO_DIRECTORY);\n    loadDirectory(extensionClasses, SERVICES_DIRECTORY);\n    return extensionClasses;\n&#125;\n\nloadExtensionClasses 方法总共做了两件事情，一是对 SPI 注解进行解析，二是调用 loadDirectory 方法加载指定文件夹配置文件。SPI 注解解析过程比较简单，无需多说。下面我们来看一下 loadDirectory 做了哪些事情。\nprivate void loadDirectory(Map&lt;String, Class&lt;?>> extensionClasses, String dir) &#123;\n    // fileName = 文件夹路径 + type 全限定名 \n    String fileName = dir + type.getName();\n    try &#123;\n        Enumeration&lt;java.net.URL> urls;\n        ClassLoader classLoader = findClassLoader();\n        // 根据文件名加载所有的同名文件\n        if (classLoader != null) &#123;\n            urls = classLoader.getResources(fileName);\n        &#125; else &#123;\n            urls = ClassLoader.getSystemResources(fileName);\n        &#125;\n        if (urls != null) &#123;\n            while (urls.hasMoreElements()) &#123;\n                java.net.URL resourceURL = urls.nextElement();\n                // 加载资源\n                loadResource(extensionClasses, classLoader, resourceURL);\n            &#125;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        logger.error(\"...\");\n    &#125;\n&#125;\n\nloadDirectory 方法先通过 classLoader 获取所有资源链接，然后再通过 loadResource 方法加载资源。我们继续跟下去，看一下 loadResource 方法的实现。\nprivate void loadResource(Map&lt;String, Class&lt;?>> extensionClasses, \n\tClassLoader classLoader, java.net.URL resourceURL) &#123;\n    try &#123;\n        BufferedReader reader = new BufferedReader(\n            new InputStreamReader(resourceURL.openStream(), \"utf-8\"));\n        try &#123;\n            String line;\n            // 按行读取配置内容\n            while ((line = reader.readLine()) != null) &#123;\n                // 定位 # 字符\n                final int ci = line.indexOf('#');\n                if (ci >= 0) &#123;\n                    // 截取 # 之前的字符串，# 之后的内容为注释，需要忽略\n                    line = line.substring(0, ci);\n                &#125;\n                line = line.trim();\n                if (line.length() > 0) &#123;\n                    try &#123;\n                        String name = null;\n                        int i = line.indexOf('=');\n                        if (i > 0) &#123;\n                            // 以等于号 = 为界，截取键与值\n                            name = line.substring(0, i).trim();\n                            line = line.substring(i + 1).trim();\n                        &#125;\n                        if (line.length() > 0) &#123;\n                            // 加载类，并通过 loadClass 方法对类进行缓存\n                            loadClass(extensionClasses, resourceURL, \n                                      Class.forName(line, true, classLoader), name);\n                        &#125;\n                    &#125; catch (Throwable t) &#123;\n                        IllegalStateException e = new IllegalStateException(\"Failed to load extension class...\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125; finally &#123;\n            reader.close();\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        logger.error(\"Exception when load extension class...\");\n    &#125;\n&#125;\n\nloadResource 方法用于读取和解析配置文件，并通过反射加载类，最后调用 loadClass 方法进行其他操作。loadClass 方法用于主要用于操作缓存，该方法的逻辑如下：\nprivate void loadClass(Map&lt;String, Class&lt;?>> extensionClasses, java.net.URL resourceURL, \n    Class&lt;?> clazz, String name) throws NoSuchMethodException &#123;\n    \n    if (!type.isAssignableFrom(clazz)) &#123;\n        throw new IllegalStateException(\"...\");\n    &#125;\n\n    // 检测目标类上是否有 Adaptive 注解\n    if (clazz.isAnnotationPresent(Adaptive.class)) &#123;\n        if (cachedAdaptiveClass == null) &#123;\n            // 设置 cachedAdaptiveClass缓存\n            cachedAdaptiveClass = clazz;\n        &#125; else if (!cachedAdaptiveClass.equals(clazz)) &#123;\n            throw new IllegalStateException(\"...\");\n        &#125;\n        \n    // 检测 clazz 是否是 Wrapper 类型\n    &#125; else if (isWrapperClass(clazz)) &#123;\n        Set&lt;Class&lt;?>> wrappers = cachedWrapperClasses;\n        if (wrappers == null) &#123;\n            cachedWrapperClasses = new ConcurrentHashSet&lt;Class&lt;?>>();\n            wrappers = cachedWrapperClasses;\n        &#125;\n        // 存储 clazz 到 cachedWrapperClasses 缓存中\n        wrappers.add(clazz);\n        \n    // 程序进入此分支，表明 clazz 是一个普通的拓展类\n    &#125; else &#123;\n        // 检测 clazz 是否有默认的构造方法，如果没有，则抛出异常\n        clazz.getConstructor();\n        if (name == null || name.length() == 0) &#123;\n            // 如果 name 为空，则尝试从 Extension 注解中获取 name，或使用小写的类名作为 name\n            name = findAnnotationName(clazz);\n            if (name.length() == 0) &#123;\n                throw new IllegalStateException(\"...\");\n            &#125;\n        &#125;\n        // 切分 name\n        String[] names = NAME_SEPARATOR.split(name);\n        if (names != null &amp;&amp; names.length > 0) &#123;\n            Activate activate = clazz.getAnnotation(Activate.class);\n            if (activate != null) &#123;\n                // 如果类上有 Activate 注解，则使用 names 数组的第一个元素作为键，\n                // 存储 name 到 Activate 注解对象的映射关系\n                cachedActivates.put(names[0], activate);\n            &#125;\n            for (String n : names) &#123;\n                if (!cachedNames.containsKey(clazz)) &#123;\n                    // 存储 Class 到名称的映射关系\n                    cachedNames.put(clazz, n);\n                &#125;\n                Class&lt;?> c = extensionClasses.get(n);\n                if (c == null) &#123;\n                    // 存储名称到 Class 的映射关系\n                    extensionClasses.put(n, clazz);\n                &#125; else if (c != clazz) &#123;\n                    throw new IllegalStateException(\"...\");\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n如上，loadClass 方法操作了不同的缓存，比如 cachedAdaptiveClass、cachedWrapperClasses 和 cachedNames 等等。除此之外，该方法没有其他什么逻辑了。\n到此，关于缓存类加载的过程就分析完了。整个过程没什么特别复杂的地方，大家按部就班的分析即可，不懂的地方可以调试一下。接下来，我们来聊聊 Dubbo IOC 方面的内容。\n\n3.2 Dubbo IOCDubbo IOC 是通过 setter 方法注入依赖。Dubbo 首先会通过反射获取到实例的所有方法，然后再遍历方法列表，检测方法名是否具有 setter 方法特征。若有，则通过 ObjectFactory 获取依赖对象，最后通过反射调用 setter 方法将依赖设置到目标对象中。整个过程对应的代码如下：\nprivate T injectExtension(T instance) &#123;\n    try &#123;\n        if (objectFactory != null) &#123;\n            // 遍历目标类的所有方法\n            for (Method method : instance.getClass().getMethods()) &#123;\n                // 检测方法是否以 set 开头，且方法仅有一个参数，且方法访问级别为 public\n                if (method.getName().startsWith(\"set\")\n                    &amp;&amp; method.getParameterTypes().length == 1\n                    &amp;&amp; Modifier.isPublic(method.getModifiers())) &#123;\n                    // 获取 setter 方法参数类型\n                    Class&lt;?> pt = method.getParameterTypes()[0];\n                    try &#123;\n                        // 获取属性名，比如 setName 方法对应属性名 name\n                        String property = method.getName().length() > 3 ? \n                            method.getName().substring(3, 4).toLowerCase() + \n                            \tmethod.getName().substring(4) : \"\";\n                        // 从 ObjectFactory 中获取依赖对象\n                        Object object = objectFactory.getExtension(pt, property);\n                        if (object != null) &#123;\n                            // 通过反射调用 setter 方法设置依赖\n                            method.invoke(instance, object);\n                        &#125;\n                    &#125; catch (Exception e) &#123;\n                        logger.error(\"fail to inject via method...\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125; catch (Exception e) &#123;\n        logger.error(e.getMessage(), e);\n    &#125;\n    return instance;\n&#125;\n\n在上面代码中，objectFactory 变量的类型为 AdaptiveExtensionFactory，AdaptiveExtensionFactory 内部维护了一个 ExtensionFactory 列表，用于存储其他类型的 ExtensionFactory。Dubbo 目前提供了两种 ExtensionFactory，分别是 SpiExtensionFactory 和 SpringExtensionFactory。前者用于创建自适应的拓展，后者是用于从 Spring 的 IOC 容器中获取所需的拓展。这两个类的类的代码不是很复杂，这里就不一一分析了。\nDubbo IOC 目前仅支持 setter 方式注入，总的来说，逻辑比较简单易懂。\n\n4.总结本篇文章简单分别介绍了 Java SPI 与 Dubbo SPI 用法，并对 Dubbo SPI 的加载拓展类的过程进行了分析。另外，在 Dubbo SPI 中还有一块重要的逻辑这里没有进行分析，即 Dubbo SPI 的扩展点自适应机制。该机制的逻辑较为复杂，我们将会在下一篇文章中进行详细的分析。\n好了，本篇文章就先到这里了。如果文章中有错误不妥之处，欢迎大家提 issue 进行反馈，或者提 pull request 进行修正。让我们携手共建 Dubbo 社区。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/adaptive-extension/\n作者： Dubbo 官方\n\nDubbo SPI自适应性扩展1.原理在 Dubbo 中，很多拓展都是通过 SPI 机制进行加载的，比如 Protocol、Cluster、LoadBalance 等。有时，有些拓展并不想在框架启动阶段被加载，而是希望在拓展方法被调用时，根据运行时参数进行加载。这听起来有些矛盾。拓展未被加载，那么拓展方法就无法被调用（静态方法除外）。拓展方法未被调用，拓展就无法被加载。对于这个矛盾的问题，Dubbo 通过自适应拓展机制很好的解决了。自适应拓展机制的实现逻辑比较复杂，首先 Dubbo 会为拓展接口生成具有代理功能的代码。然后通过 javassist 或 jdk 编译这段代码，得到 Class 类。最后再通过反射创建代理类，整个过程比较复杂。为了让大家对自适应拓展有一个感性的认识，下面我们通过一个示例进行演示。这是一个与汽车相关的例子，我们有一个车轮制造厂接口 WheelMaker：\npublic interface WheelMaker &#123;\n    Wheel makeWheel(URL url);\n&#125;\n\nWheelMaker 接口的自适应实现类如下：\npublic class AdaptiveWheelMaker implements WheelMaker &#123;\n    public Wheel makeWheel(URL url) &#123;\n        if (url == null) &#123;\n            throw new IllegalArgumentException(\"url == null\");\n        &#125;\n        \n    \t// 1.从 URL 中获取 WheelMaker 名称\n        String wheelMakerName = url.getParameter(\"Wheel.maker\");\n        if (wheelMakerName == null) &#123;\n            throw new IllegalArgumentException(\"wheelMakerName == null\");\n        &#125;\n        \n        // 2.通过 SPI 加载具体的 WheelMaker\n        WheelMaker wheelMaker = ExtensionLoader\n            .getExtensionLoader(WheelMaker.class).getExtension(wheelMakerName);\n        \n        // 3.调用目标方法\n        return wheelMaker.makeWheel(url);\n    &#125;\n&#125;\n\nAdaptiveWheelMaker 是一个代理类，与传统的代理逻辑不同，AdaptiveWheelMaker 所代理的对象是在 makeWheel 方法中通过 SPI 加载得到的。makeWheel 方法主要做了三件事情：\n\n从 URL 中获取 WheelMaker 名称\n通过 SPI 加载具体的 WheelMaker 实现类\n调用目标方法\n\n接下来，我们来看看汽车制造厂 CarMaker 接口与其实现类。\npublic interface CarMaker &#123;\n    Car makeCar(URL url);\n&#125;\n\npublic class RaceCarMaker implements CarMaker &#123;\n    WheelMaker wheelMaker;\n \n    // 通过 setter 注入 AdaptiveWheelMaker\n    public setWheelMaker(WheelMaker wheelMaker) &#123;\n        this.wheelMaker = wheelMaker;\n    &#125;\n \n    public Car makeCar(URL url) &#123;\n        Wheel wheel = wheelMaker.makeWheel(url);\n        return new RaceCar(wheel, ...);\n    &#125;\n&#125;\n\nRaceCarMaker 持有一个 WheelMaker 类型的成员变量，在程序启动时，我们可以将 AdaptiveWheelMaker 通过 setter 方法注入到 RaceCarMaker 中。在运行时，假设有这样一个 url 参数传入：\ndubbo:&#x2F;&#x2F;192.168.0.101:20880&#x2F;XxxService?wheel.maker&#x3D;MichelinWheelMaker\n\nRaceCarMaker 的 makeCar 方法将上面的 url 作为参数传给 AdaptiveWheelMaker 的 makeWheel 方法，makeWheel 方法从 url 中提取 wheel.maker 参数，得到 MichelinWheelMaker。之后再通过 SPI 加载配置名为 MichelinWheelMaker 的实现类，得到具体的 WheelMaker 实例。\n上面的示例展示了自适应拓展类的核心实现 —- 在拓展接口的方法被调用时，通过 SPI 加载具体的拓展实现类，并调用拓展对象的同名方法。接下来，我们深入到源码中，探索自适应拓展类生成的过程。\n\n2.源码分析在对自适应拓展生成过程进行深入分析之前，我们先来看一下与自适应拓展息息相关的一个注解，即 Adaptive 注解。该注解的定义如下：\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)\npublic @interface Adaptive &#123;\n    String[] value() default &#123;&#125;;\n&#125;\n\n从上面的代码中可知，Adaptive 可注解在类或方法上。当 Adaptive 注解在类上时，Dubbo 不会为该类生成代理类。注解在方法（接口方法）上时，Dubbo 则会为该方法生成代理逻辑。Adaptive 注解在类上的情况很少，在 Dubbo 中，仅有两个类被 Adaptive 注解了，分别是 AdaptiveCompiler 和 AdaptiveExtensionFactory。此种情况，表示拓展的加载逻辑由人工编码完成。更多时候，Adaptive 是注解在接口方法上的，表示拓展的加载逻辑需由框架自动生成。Adaptive 注解的地方不同，相应的处理逻辑也是不同的。注解在类上时，处理逻辑比较简单，本文就不分析了。注解在接口方法上时，处理逻辑较为复杂，本章将会重点分析此块逻辑。\n\n2.1 获取自适应拓展getAdaptiveExtension 方法是获取自适应拓展的入口方法，因此下面我们从这个方法进行分析。相关代码如下：\npublic T getAdaptiveExtension() &#123;\n    // 从缓存中获取自适应拓展\n    Object instance = cachedAdaptiveInstance.get();\n    if (instance == null) &#123;    // 缓存未命中\n        if (createAdaptiveInstanceError == null) &#123;\n            synchronized (cachedAdaptiveInstance) &#123;\n                instance = cachedAdaptiveInstance.get();\n                if (instance == null) &#123;\n                    try &#123;\n                        // 创建自适应拓展\n                        instance = createAdaptiveExtension();\n                        // 设置自适应拓展到缓存中\n                        cachedAdaptiveInstance.set(instance);\n                    &#125; catch (Throwable t) &#123;\n                        createAdaptiveInstanceError = t;\n                        throw new IllegalStateException(\"fail to create adaptive instance: ...\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            throw new IllegalStateException(\"fail to create adaptive instance:  ...\");\n        &#125;\n    &#125;\n\n    return (T) instance;\n&#125;\n\ngetAdaptiveExtension 方法首先会检查缓存，缓存未命中，则调用 createAdaptiveExtension 方法创建自适应拓展。下面，我们看一下 createAdaptiveExtension 方法的代码。\nprivate T createAdaptiveExtension() &#123;\n    try &#123;\n        // 获取自适应拓展类，并通过反射实例化\n        return injectExtension((T) getAdaptiveExtensionClass().newInstance());\n    &#125; catch (Exception e) &#123;\n        throw new IllegalStateException(\"Can not create adaptive extension ...\");\n    &#125;\n&#125;\n\ncreateAdaptiveExtension 方法的代码比较少，但却包含了三个逻辑，分别如下：\n\n调用 getAdaptiveExtensionClass 方法获取自适应拓展 Class 对象\n通过反射进行实例化\n调用 injectExtension 方法向拓展实例中注入依赖\n\n前两个逻辑比较好理解，第三个逻辑用于向自适应拓展对象中注入依赖。这个逻辑看似多余，但有存在的必要，这里简单说明一下。前面说过，Dubbo 中有两种类型的自适应拓展，一种是手工编码的，一种是自动生成的。手工编码的自适应拓展中可能存在着一些依赖，而自动生成的 Adaptive 拓展则不会依赖其他类。这里调用 injectExtension 方法的目的是为手工编码的自适应拓展注入依赖，这一点需要大家注意一下。关于 injectExtension 方法，前文已经分析过了，这里不再赘述。接下来，分析 getAdaptiveExtensionClass 方法的逻辑。\nprivate Class&lt;?> getAdaptiveExtensionClass() &#123;\n    // 通过 SPI 获取所有的拓展类\n    getExtensionClasses();\n    // 检查缓存，若缓存不为空，则直接返回缓存\n    if (cachedAdaptiveClass != null) &#123;\n        return cachedAdaptiveClass;\n    &#125;\n    // 创建自适应拓展类\n    return cachedAdaptiveClass = createAdaptiveExtensionClass();\n&#125;\n\ngetAdaptiveExtensionClass 方法同样包含了三个逻辑，如下：\n\n调用 getExtensionClasses 获取所有的拓展类\n检查缓存，若缓存不为空，则返回缓存\n若缓存为空，则调用 createAdaptiveExtensionClass 创建自适应拓展类\n\n这三个逻辑看起来平淡无奇，似乎没有多讲的必要。但是这些平淡无奇的代码中隐藏了着一些细节，需要说明一下。首先从第一个逻辑说起，getExtensionClasses 这个方法用于获取某个接口的所有实现类。比如该方法可以获取 Protocol 接口的 DubboProtocol、HttpProtocol、InjvmProtocol 等实现类。在获取实现类的过程中，如果某个实现类被 Adaptive 注解修饰了，那么该类就会被赋值给 cachedAdaptiveClass 变量。此时，上面步骤中的第二步条件成立（缓存不为空），直接返回 cachedAdaptiveClass 即可。如果所有的实现类均未被 Adaptive 注解修饰，那么执行第三步逻辑，创建自适应拓展类。相关代码如下：\nprivate Class&lt;?> createAdaptiveExtensionClass() &#123;\n    // 构建自适应拓展代码\n    String code = createAdaptiveExtensionClassCode();\n    ClassLoader classLoader = findClassLoader();\n    // 获取编译器实现类\n    com.alibaba.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(com.alibaba.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();\n    // 编译代码，生成 Class\n    return compiler.compile(code, classLoader);\n&#125;\n\ncreateAdaptiveExtensionClass 方法用于生成自适应拓展类，该方法首先会生成自适应拓展类的源码，然后通过 Compiler 实例（Dubbo 默认使用 javassist 作为编译器）编译源码，得到代理类 Class 实例。接下来，我们把重点放在代理类代码生成的逻辑上，其他逻辑大家自行分析。\n\n2.2 自适应拓展类代码生成createAdaptiveExtensionClassCode 方法代码略多，约有两百行代码。因此本节将会对该方法的代码进行拆分分析，以帮助大家更好的理解代码逻辑。\n\n2.2.1 Adaptive 注解检测在生成代理类源码之前，createAdaptiveExtensionClassCode 方法首先会通过反射检测接口方法是否包含 Adaptive 注解。对于要生成自适应拓展的接口，Dubbo 要求该接口至少有一个方法被 Adaptive 注解修饰。若不满足此条件，就会抛出运行时异常。相关代码如下：\n// 通过反射获取所有的方法\nMethod[] methods = type.getMethods();\nboolean hasAdaptiveAnnotation = false;\n// 遍历方法列表\nfor (Method m : methods) &#123;\n    // 检测方法上是否有 Adaptive 注解\n    if (m.isAnnotationPresent(Adaptive.class)) &#123;\n        hasAdaptiveAnnotation = true;\n        break;\n    &#125;\n&#125;\n\nif (!hasAdaptiveAnnotation)\n    // 若所有的方法上均无 Adaptive 注解，则抛出异常\n    throw new IllegalStateException(\"No adaptive method on extension ...\");\n\n\n2.2.2 生成类通过 Adaptive 注解检测后，即可开始生成代码。代码生成的顺序与 Java 文件内容顺序一致，首先会生成 package 语句，然后生成 import 语句，紧接着生成类名等代码。整个逻辑如下：\n// 生成 package 代码：package + type 所在包\ncodeBuilder.append(\"package \").append(type.getPackage().getName()).append(\";\");\n// 生成 import 代码：import + ExtensionLoader 全限定名\ncodeBuilder.append(\"\\nimport \").append(ExtensionLoader.class.getName()).append(\";\");\n// 生成类代码：public class + type简单名称 + $Adaptive + implements + type全限定名 + &#123;\ncodeBuilder.append(\"\\npublic class \")\n    .append(type.getSimpleName())\n    .append(\"$Adaptive\")\n    .append(\" implements \")\n    .append(type.getCanonicalName())\n    .append(\" &#123;\");\n\n// $&#123;生成方法&#125;\n\ncodeBuilder.append(\"\\n&#125;\");\n\n这里使用 ${…} 占位符代表其他代码的生成逻辑，该部分逻辑将在随后进行分析。上面代码不是很难理解，下面直接通过一个例子展示该段代码所生成的内容。以 Dubbo 的 Protocol 接口为例，生成的代码如下：\npackage com.alibaba.dubbo.rpc;\nimport com.alibaba.dubbo.common.extension.ExtensionLoader;\npublic class Protocol$Adaptive implements com.alibaba.dubbo.rpc.Protocol &#123;\n    // 省略方法代码\n&#125;\n\n\n2.2.3 生成方法一个方法可以被 Adaptive 注解修饰，也可以不被修饰。这里将未被 Adaptive 注解修饰的方法称为“无 Adaptive 注解方法”，下面我们先来看看此种方法的代码生成逻辑是怎样的。\n\n2.2.3.1 无 Adaptive 注解方法代码生成逻辑对于接口方法，我们可以按照需求标注 Adaptive 注解。以 Protocol 接口为例，该接口的 destroy 和 getDefaultPort 未标注 Adaptive 注解，其他方法均标注了 Adaptive 注解。Dubbo 不会为没有标注 Adaptive 注解的方法生成代理逻辑，对于该种类型的方法，仅会生成一句抛出异常的代码。生成逻辑如下：\nfor (Method method : methods) &#123;\n    \n    // 省略无关逻辑\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    // 如果方法上无 Adaptive 注解，则生成 throw new UnsupportedOperationException(...) 代码\n    if (adaptiveAnnotation == null) &#123;\n        // 生成的代码格式如下：\n        // throw new UnsupportedOperationException(\n        //     \"method \" + 方法签名 + of interface + 全限定接口名 + is not adaptive method!”)\n        code.append(\"throw new UnsupportedOperationException(\\\"method \")\n            .append(method.toString()).append(\" of interface \")\n            .append(type.getName()).append(\" is not adaptive method!\\\");\");\n    &#125; else &#123;\n        // 省略无关逻辑\n    &#125;\n    \n    // 省略无关逻辑\n&#125;\n\n以 Protocol 接口的 destroy 方法为例，上面代码生成的内容如下：\nthrow new UnsupportedOperationException(\n            \"method public abstract void com.alibaba.dubbo.rpc.Protocol.destroy() of interface com.alibaba.dubbo.rpc.Protocol is not adaptive method!\");\n\n\n2.2.3.2 获取 URL 数据前面说过方法代理逻辑会从 URL 中提取目标拓展的名称，因此代码生成逻辑的一个重要的任务是从方法的参数列表或者其他参数中获取 URL 数据。举例说明一下，我们要为 Protocol 接口的 refer 和 export 方法生成代理逻辑。在运行时，通过反射得到的方法定义大致如下：\nInvoker refer(Class&lt;T> arg0, URL arg1) throws RpcException;\nExporter export(Invoker&lt;T> arg0) throws RpcException;\n\n对于 refer 方法，通过遍历 refer 的参数列表即可获取 URL 数据，这个还比较简单。对于 export 方法，获取 URL 数据则要麻烦一些。export 参数列表中没有 URL 参数，因此需要从 Invoker 参数中获取 URL 数据。获取方式是调用 Invoker 中可返回 URL 的 getter 方法，比如 getUrl。如果 Invoker 中无相关 getter 方法，此时则会抛出异常。整个逻辑如下：\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $&#123;无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n    \tint urlTypeIndex = -1;\n        // 遍历参数列表，确定 URL 参数位置\n        for (int i = 0; i &lt; pts.length; ++i) &#123;\n            if (pts[i].equals(URL.class)) &#123;\n                urlTypeIndex = i;\n                break;\n            &#125;\n        &#125;\n        \n        // urlTypeIndex != -1，表示参数列表中存在 URL 参数\n        if (urlTypeIndex != -1) &#123;\n            // 为 URL 类型参数生成判空代码，格式如下：\n            // if (arg + urlTypeIndex == null) \n            //     throw new IllegalArgumentException(\"url == null\");\n            String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"url == null\\\");\",\n                                     urlTypeIndex);\n            code.append(s);\n\n            // 为 URL 类型参数生成赋值代码，形如 URL url = arg1\n            s = String.format(\"\\n%s url = arg%d;\", URL.class.getName(), urlTypeIndex);\n            code.append(s);\n            \n        // 参数列表中不存在 URL 类型参数\n        &#125; else &#123;\n            String attribMethod = null;\n\n            LBL_PTS:\n            // 遍历方法的参数类型列表\n            for (int i = 0; i &lt; pts.length; ++i) &#123;\n                // 获取某一类型参数的全部方法\n                Method[] ms = pts[i].getMethods();\n                // 遍历方法列表，寻找可返回 URL 的 getter 方法\n                for (Method m : ms) &#123;\n                    String name = m.getName();\n                    // 1. 方法名以 get 开头，或方法名大于3个字符\n                    // 2. 方法的访问权限为 public\n                    // 3. 非静态方法\n                    // 4. 方法参数数量为0\n                    // 5. 方法返回值类型为 URL\n                    if ((name.startsWith(\"get\") || name.length() > 3)\n                        &amp;&amp; Modifier.isPublic(m.getModifiers())\n                        &amp;&amp; !Modifier.isStatic(m.getModifiers())\n                        &amp;&amp; m.getParameterTypes().length == 0\n                        &amp;&amp; m.getReturnType() == URL.class) &#123;\n                        urlTypeIndex = i;\n                        attribMethod = name;\n                        \n                        // 结束 for (int i = 0; i &lt; pts.length; ++i) 循环\n                        break LBL_PTS;\n                    &#125;\n                &#125;\n            &#125;\n            if (attribMethod == null) &#123;\n                // 如果所有参数中均不包含可返回 URL 的 getter 方法，则抛出异常\n                throw new IllegalStateException(\"fail to create adaptive class for interface ...\");\n            &#125;\n\n            // 为可返回 URL 的参数生成判空代码，格式如下：\n            // if (arg + urlTypeIndex == null) \n            //     throw new IllegalArgumentException(\"参数全限定名 + argument == null\");\n            String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"%s argument == null\\\");\",\n                                     urlTypeIndex, pts[urlTypeIndex].getName());\n            code.append(s);\n\n            // 为 getter 方法返回的 URL 生成判空代码，格式如下：\n            // if (argN.getter方法名() == null) \n            //     throw new IllegalArgumentException(参数全限定名 + argument getUrl() == null);\n            s = String.format(\"\\nif (arg%d.%s() == null) throw new IllegalArgumentException(\\\"%s argument %s() == null\\\");\",\n                              urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);\n            code.append(s);\n\n            // 生成赋值语句，格式如下：\n            // URL全限定名 url = argN.getter方法名()，比如 \n            // com.alibaba.dubbo.common.URL url = invoker.getUrl();\n            s = String.format(\"%s url = arg%d.%s();\", URL.class.getName(), urlTypeIndex, attribMethod);\n            code.append(s);\n        &#125;\n        \n        // 省略无关代码\n    &#125;\n    \n    // 省略无关代码\n&#125;\n\n上面代码有点多，需要耐心看一下。这段代码主要目的是为了获取 URL 数据，并为之生成判空和赋值代码。以 Protocol 的 refer 和 export 方法为例，上面的代码为它们生成如下内容（代码已格式化）：\nrefer:\nif (arg1 == null) \n    throw new IllegalArgumentException(\"url == null\");\ncom.alibaba.dubbo.common.URL url = arg1;\n\nexport:\nif (arg0 == null) \n    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument == null\");\nif (arg0.getUrl() == null) \n    throw new IllegalArgumentException(\"com.alibaba.dubbo.rpc.Invoker argument getUrl() == null\");\ncom.alibaba.dubbo.common.URL url = arg0.getUrl();\n\n\n\n2.2.3.3 获取 Adaptive 注解值Adaptive 注解值 value 类型为 String[]，可填写多个值，默认情况下为空数组。若 value 为非空数组，直接获取数组内容即可。若 value 为空数组，则需进行额外处理。处理过程是将类名转换为字符数组，然后遍历字符数组，并将字符放入 StringBuilder 中。若字符为大写字母，则向 StringBuilder 中添加点号，随后将字符变为小写存入 StringBuilder 中。比如 LoadBalance 经过处理后，得到 load.balance。\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $&#123;无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n        // $&#123;获取 URL 数据&#125;\n        \n        String[] value = adaptiveAnnotation.value();\n        // value 为空数组\n        if (value.length == 0) &#123;\n            // 获取类名，并将类名转换为字符数组\n            char[] charArray = type.getSimpleName().toCharArray();\n            StringBuilder sb = new StringBuilder(128);\n            // 遍历字节数组\n            for (int i = 0; i &lt; charArray.length; i++) &#123;\n                // 检测当前字符是否为大写字母\n                if (Character.isUpperCase(charArray[i])) &#123;\n                    if (i != 0) &#123;\n                        // 向 sb 中添加点号\n                        sb.append(\".\");\n                    &#125;\n                    // 将字符变为小写，并添加到 sb 中\n                    sb.append(Character.toLowerCase(charArray[i]));\n                &#125; else &#123;\n                    // 添加字符到 sb 中\n                    sb.append(charArray[i]);\n                &#125;\n            &#125;\n            value = new String[]&#123;sb.toString()&#125;;\n        &#125;\n        \n        // 省略无关代码\n    &#125;\n    \n    // 省略无关逻辑\n&#125;\n\n\n\n2.2.3.4 检测 Invocation 参数此段逻辑是检测方法列表中是否存在 Invocation 类型的参数，若存在，则为其生成判空代码和其他一些代码。相应的逻辑如下：\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();    // 获取参数类型列表\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $&#123;无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n        // $&#123;获取 URL 数据&#125;\n        \n        // $&#123;获取 Adaptive 注解值&#125;\n        \n        boolean hasInvocation = false;\n        // 遍历参数类型列表\n        for (int i = 0; i &lt; pts.length; ++i) &#123;\n            // 判断当前参数名称是否等于 com.alibaba.dubbo.rpc.Invocation\n            if (pts[i].getName().equals(\"com.alibaba.dubbo.rpc.Invocation\")) &#123;\n                // 为 Invocation 类型参数生成判空代码\n                String s = String.format(\"\\nif (arg%d == null) throw new IllegalArgumentException(\\\"invocation == null\\\");\", i);\n                code.append(s);\n                // 生成 getMethodName 方法调用代码，格式为：\n                //    String methodName = argN.getMethodName();\n                s = String.format(\"\\nString methodName = arg%d.getMethodName();\", i);\n                code.append(s);\n                \n                // 设置 hasInvocation 为 true\n                hasInvocation = true;\n                break;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 省略无关逻辑\n&#125;\n\n\n\n2.2.3.5 生成拓展名获取逻辑本段逻辑用于根据 SPI 和 Adaptive 注解值生成“获取拓展名逻辑”，同时生成逻辑也受 Invocation 类型参数影响，综合因素导致本段逻辑相对复杂。本段逻辑可能会生成但不限于下面的代码：\nString extName = (url.getProtocol() == null ? \"dubbo\" : url.getProtocol());\n\n\n或\nString extName = url.getMethodParameter(methodName, \"loadbalance\", \"random\");\n\n\n亦或是\nString extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty\"));\n\n\n本段逻辑复杂之处在于条件分支比较多，大家在阅读源码时需要知道每个条件分支的意义是什么，否则不太容易看懂相关代码。下面开始分析本段逻辑。\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n        // $&#123;获取 URL 数据&#125;\n        \n        // $&#123;获取 Adaptive 注解值&#125;\n        \n        // $&#123;检测 Invocation 参数&#125;\n        \n        // 设置默认拓展名，cachedDefaultName 源于 SPI 注解值，默认情况下，\n        // SPI 注解值为空串，此时 cachedDefaultName = null\n        String defaultExtName = cachedDefaultName;\n        String getNameCode = null;\n        \n        // 遍历 value，这里的 value 是 Adaptive 的注解值，2.2.3.3 节分析过 value 变量的获取过程。\n        // 此处循环目的是生成从 URL 中获取拓展名的代码，生成的代码会赋值给 getNameCode 变量。注意这\n        // 个循环的遍历顺序是由后向前遍历的。\n        for (int i = value.length - 1; i >= 0; --i) &#123;\n            // 当 i 为最后一个元素的坐标时\n            if (i == value.length - 1) &#123;\n                // 默认拓展名非空\n                if (null != defaultExtName) &#123;\n                    // protocol 是 url 的一部分，可通过 getProtocol 方法获取，其他的则是从\n                    // URL 参数中获取。因为获取方式不同，所以这里要判断 value[i] 是否为 protocol\n                    if (!\"protocol\".equals(value[i]))\n                    \t// hasInvocation 用于标识方法参数列表中是否有 Invocation 类型参数\n                        if (hasInvocation)\n                            // 生成的代码功能等价于下面的代码：\n                            //   url.getMethodParameter(methodName, value[i], defaultExtName)\n                            // 以 LoadBalance 接口的 select 方法为例，最终生成的代码如下：\n                            //   url.getMethodParameter(methodName, \"loadbalance\", \"random\")\n                            getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                    \telse\n                    \t\t// 生成的代码功能等价于下面的代码：\n\t                        //   url.getParameter(value[i], defaultExtName)\n\t                        getNameCode = String.format(\"url.getParameter(\\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n                    else\n                    \t// 生成的代码功能等价于下面的代码：\n                        //   ( url.getProtocol() == null ? defaultExtName : url.getProtocol() )\n                        getNameCode = String.format(\"( url.getProtocol() == null ? \\\"%s\\\" : url.getProtocol() )\", defaultExtName);\n                    \n                // 默认拓展名为空\n                &#125; else &#123;\n                    if (!\"protocol\".equals(value[i]))\n                        if (hasInvocation)\n                        \t// 生成代码格式同上\n                            getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t                    else\n\t                    \t// 生成的代码功能等价于下面的代码：\n\t                        //   url.getParameter(value[i])\n\t                        getNameCode = String.format(\"url.getParameter(\\\"%s\\\")\", value[i]);\n                    else\n                    \t// 生成从 url 中获取协议的代码，比如 \"dubbo\"\n                        getNameCode = \"url.getProtocol()\";\n                &#125;\n            &#125; else &#123;\n                if (!\"protocol\".equals(value[i]))\n                    if (hasInvocation)\n                        // 生成代码格式同上\n                        getNameCode = String.format(\"url.getMethodParameter(methodName, \\\"%s\\\", \\\"%s\\\")\", value[i], defaultExtName);\n\t                else\n\t                \t// 生成的代码功能等价于下面的代码：\n\t                    //   url.getParameter(value[i], getNameCode)\n\t                    // 以 Transporter 接口的 connect 方法为例，最终生成的代码如下：\n\t                    //   url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty\"))\n\t                    getNameCode = String.format(\"url.getParameter(\\\"%s\\\", %s)\", value[i], getNameCode);\n                else\n                    // 生成的代码功能等价于下面的代码：\n                    //   url.getProtocol() == null ? getNameCode : url.getProtocol()\n                    // 以 Protocol 接口的 connect 方法为例，最终生成的代码如下：\n                    //   url.getProtocol() == null ? \"dubbo\" : url.getProtocol()\n                    getNameCode = String.format(\"url.getProtocol() == null ? (%s) : url.getProtocol()\", getNameCode);\n            &#125;\n        &#125;\n        // 生成 extName 赋值代码\n        code.append(\"\\nString extName = \").append(getNameCode).append(\";\");\n        // 生成 extName 判空代码\n        String s = String.format(\"\\nif(extName == null) \" +\n                                 \"throw new IllegalStateException(\\\"Fail to get extension(%s) name from url(\\\" + url.toString() + \\\") use keys(%s)\\\");\",\n                                 type.getName(), Arrays.toString(value));\n        code.append(s);\n    &#125;\n    \n    // 省略无关逻辑\n&#125;\n\n\n上面代码比较复杂，不是很好理解。对于这段代码，建议大家写点测试用例，对 Protocol、LoadBalance 以及 Transporter 等接口的自适应拓展类代码生成过程进行调试。这里我以 Transporter 接口的自适应拓展类代码生成过程举例说明。首先看一下 Transporter 接口的定义，如下：\n@SPI(\"netty\")\npublic interface Transporter &#123;\n\t// @Adaptive(&#123;server, transporter&#125;)\n    @Adaptive(&#123;Constants.SERVER_KEY, Constants.TRANSPORTER_KEY&#125;) \n    Server bind(URL url, ChannelHandler handler) throws RemotingException;\n\n    // @Adaptive(&#123;client, transporter&#125;)\n    @Adaptive(&#123;Constants.CLIENT_KEY, Constants.TRANSPORTER_KEY&#125;)\n    Client connect(URL url, ChannelHandler handler) throws RemotingException;\n&#125;\n\n\n下面对 connect 方法代理逻辑生成的过程进行分析，此时生成代理逻辑所用到的变量如下：\nString defaultExtName = \"netty\";\nboolean hasInvocation = false;\nString getNameCode = null;\nString[] value = [\"client\", \"transporter\"];\n\n\n下面对 value 数组进行遍历，此时 i &#x3D; 1, value[i] &#x3D; “transporter”，生成的代码如下：\ngetNameCode = url.getParameter(\"transporter\", \"netty\");\n\n\n接下来，for 循环继续执行，此时 i &#x3D; 0, value[i] &#x3D; “client”，生成的代码如下：\ngetNameCode = url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty\"));\n\n\nfor 循环结束运行，现在为 extName 变量生成赋值和判空代码，如下：\nString extName = url.getParameter(\"client\", url.getParameter(\"transporter\", \"netty\"));\nif (extName == null) &#123;\n    throw new IllegalStateException(\n        \"Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(\" + url.toString()\n        + \") use keys([client, transporter])\");\n&#125;\n\n\n\n2.2.3.6 生成拓展加载与目标方法调用逻辑本段代码逻辑用于根据拓展名加载拓展实例，并调用拓展实例的目标方法。相关逻辑如下：\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n        // $&#123;获取 URL 数据&#125;\n        \n        // $&#123;获取 Adaptive 注解值&#125;\n        \n        // $&#123;检测 Invocation 参数&#125;\n        \n        // $&#123;生成拓展名获取逻辑&#125;\n        \n        // 生成拓展获取代码，格式如下：\n        // type全限定名 extension = (type全限定名)ExtensionLoader全限定名\n        //     .getExtensionLoader(type全限定名.class).getExtension(extName);\n        // Tips: 格式化字符串中的 %&lt;s 表示使用前一个转换符所描述的参数，即 type 全限定名\n        s = String.format(\"\\n%s extension = (%&lt;s)%s.getExtensionLoader(%s.class).getExtension(extName);\",\n                        type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());\n        code.append(s);\n\n\t\t// 如果方法返回值类型非 void，则生成 return 语句。\n        if (!rt.equals(void.class)) &#123;\n            code.append(\"\\nreturn \");\n        &#125;\n\n        // 生成目标方法调用逻辑，格式为：\n        //     extension.方法名(arg0, arg2, ..., argN);\n        s = String.format(\"extension.%s(\", method.getName());\n        code.append(s);\n        for (int i = 0; i &lt; pts.length; i++) &#123;\n            if (i != 0)\n                code.append(\", \");\n            code.append(\"arg\").append(i);\n        &#125;\n        code.append(\");\");   \n    &#125;\n    \n    // 省略无关逻辑\n&#125;\n\n\n以 Protocol 接口举例说明，上面代码生成的内容如下：\ncom.alibaba.dubbo.rpc.Protocol extension = (com.alibaba.dubbo.rpc.Protocol) ExtensionLoader\n    .getExtensionLoader(com.alibaba.dubbo.rpc.Protocol.class).getExtension(extName);\nreturn extension.refer(arg0, arg1);\n\n\n\n2.2.3.7 生成完整的方法本节进行代码生成的收尾工作，主要用于生成方法定义的代码。相关逻辑如下：\nfor (Method method : methods) &#123;\n    Class&lt;?> rt = method.getReturnType();\n    Class&lt;?>[] pts = method.getParameterTypes();\n    Class&lt;?>[] ets = method.getExceptionTypes();\n\n    Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);\n    StringBuilder code = new StringBuilder(512);\n    if (adaptiveAnnotation == null) &#123;\n        // $无 Adaptive 注解方法代码生成逻辑&#125;\n    &#125; else &#123;\n        // $&#123;获取 URL 数据&#125;\n        \n        // $&#123;获取 Adaptive 注解值&#125;\n        \n        // $&#123;检测 Invocation 参数&#125;\n        \n        // $&#123;生成拓展名获取逻辑&#125;\n        \n        // $&#123;生成拓展加载与目标方法调用逻辑&#125;\n    &#125;\n&#125;\n    \n// public + 返回值全限定名 + 方法名 + (\ncodeBuilder.append(\"\\npublic \")\n    .append(rt.getCanonicalName())\n    .append(\" \")\n    .append(method.getName())\n    .append(\"(\");\n\n// 添加参数列表代码\nfor (int i = 0; i &lt; pts.length; i++) &#123;\n    if (i > 0) &#123;\n        codeBuilder.append(\", \");\n    &#125;\n    codeBuilder.append(pts[i].getCanonicalName());\n    codeBuilder.append(\" \");\n    codeBuilder.append(\"arg\").append(i);\n&#125;\ncodeBuilder.append(\")\");\n\n// 添加异常抛出代码\nif (ets.length > 0) &#123;\n    codeBuilder.append(\" throws \");\n    for (int i = 0; i &lt; ets.length; i++) &#123;\n        if (i > 0) &#123;\n            codeBuilder.append(\", \");\n        &#125;\n        codeBuilder.append(ets[i].getCanonicalName());\n    &#125;\n&#125;\ncodeBuilder.append(\" &#123;\");\ncodeBuilder.append(code.toString());\ncodeBuilder.append(\"\\n&#125;\");\n\n\n以 Protocol 的 refer 方法为例，上面代码生成的内容如下：\npublic com.alibaba.dubbo.rpc.Invoker refer(java.lang.Class arg0, com.alibaba.dubbo.common.URL arg1) &#123;\n    // 方法体\n&#125;\n\n\n\n3.总结到此，关于自适应拓展的原理，实现就分析完了。总的来说自适应拓展整个逻辑还是很复杂的，并不是很容易弄懂。因此，大家在阅读该部分源码时，耐心一些。同时多进行调试，也可以通过生成好的代码思考代码的生成逻辑。好了，本篇文章就分析到这里。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/directory/\n作者： Dubbo 官方\n本文介绍了服务目录的原理和实现细节。\n\n服务目录1. 简介本篇文章，将开始分析 Dubbo 集群容错方面的源码。集群容错源码包含四个部分，分别是:\n\n服务目录 Directory\n服务路由 Router\n集群 Cluster\n负载均衡 LoadBalance。\n\n这几个部分的源码逻辑相对比较独立，我们将会分四篇文章进行分析。\n本篇文章作为集群容错的开篇文章，将和大家一起分析服务目录相关的源码。在进行深入分析之前，我们先来了解一下：服务目录是什么？\n服务目录中存储了一些和服务提供者有关的信息，通过服务目录，服务消费者可获取到服务提供者的信息，比如 ip、端口、服务协议等。通过这些信息，服务消费者就可通过 Netty 等客户端进行远程调用。\n在一个服务集群中，服务提供者数量并不是一成不变的，如果集群中新增了一台机器，相应地在服务目录中就要新增一条服务提供者记录。或者，如果服务提供者的配置修改了，服务目录中的记录也要做相应的更新。如果这样说，服务目录和注册中心的功能不就雷同了吗？确实如此，这里这么说是为了方便大家理解。实际上服务目录在获取注册中心的服务配置信息后，会为每条配置信息生成一个 Invoker 对象，并把这个 Invoker 对象存储起来，这个 Invoker 才是服务目录最终持有的对象。Invoker 有什么用呢？看名字就知道了，这是一个具有远程调用功能的对象。讲到这大家应该知道了什么是服务目录了，它可以看做是 Invoker 集合，且这个集合中的元素会随注册中心的变化而进行动态调整。\n关于服务目录这里就先介绍这些，大家先有个大致印象。接下来我们通过继承体系图来了解一下服务目录的家族成员都有哪些。\n\n2. 继承体系服务目录目前内置的实现有两个，分别为 StaticDirectory 和 RegistryDirectory，它们均是 AbstractDirectory 的子类。AbstractDirectory 实现了 Directory 接口，这个接口包含了一个重要的方法定义，即 list(Invocation)，用于列举 Invoker。下面我们来看一下他们的继承体系图。\n\n如上，Directory 继承自 Node 接口，Node 这个接口继承者比较多，像 Registry、Monitor、Invoker 等均继承了这个接口。这个接口包含了一个获取配置信息的方法 getUrl，实现该接口的类可以向外提供配置信息。另外，大家注意看 RegistryDirectory 实现了 NotifyListener 接口，当注册中心节点信息发生变化后，RegistryDirectory 可以通过此接口方法得到变更信息，并根据变更信息动态调整内部 Invoker 列表。\n\n3. 源码分析本章将分析 AbstractDirectory 和它两个子类的源码。AbstractDirectory 封装了 Invoker 列举流程，具体的列举逻辑则由子类实现，这是典型的模板模式。所以，接下来我们先来看一下 AbstractDirectory 的源码。\npublic List&lt;Invoker&lt;T>> list(Invocation invocation) throws RpcException &#123;\n    if (destroyed) &#123;\n        throw new RpcException(\"Directory already destroyed...\");\n    &#125;\n    \n    // 调用 doList 方法列举 Invoker，doList 是模板方法，由子类实现\n    List&lt;Invoker&lt;T>> invokers = doList(invocation);\n    \n    // 获取路由 Router 列表\n    List&lt;Router> localRouters = this.routers;\n    if (localRouters != null &amp;&amp; !localRouters.isEmpty()) &#123;\n        for (Router router : localRouters) &#123;\n            try &#123;\n                // 获取 runtime 参数，并根据参数决定是否进行路由\n                if (router.getUrl() == null || router.getUrl().getParameter(Constants.RUNTIME_KEY, false)) &#123;\n                    // 进行服务路由\n                    invokers = router.route(invokers, getConsumerUrl(), invocation);\n                &#125;\n            &#125; catch (Throwable t) &#123;\n                logger.error(\"Failed to execute router: ...\");\n            &#125;\n        &#125;\n    &#125;\n    return invokers;\n&#125;\n\n// 模板方法，由子类实现\nprotected abstract List&lt;Invoker&lt;T>> doList(Invocation invocation) throws RpcException;\n\n上面就是 AbstractDirectory 的 list 方法源码，这个方法封装了 Invoker 的列举过程。如下：\n\n调用 doList 获取 Invoker 列表\n根据 Router 的 getUrl 返回值为空与否，以及 runtime 参数决定是否进行服务路由\n\n以上步骤中，doList 是模板方法，需由子类实现。Router 的 runtime 参数这里简单说明一下，这个参数决定了是否在每次调用服务时都执行路由规则。如果 runtime 为 true，那么每次调用服务前，都需要进行服务路由。这个对性能造成影响，配置时需要注意。\n关于 AbstractDirectory 就分析这么多，下面开始分析子类的源码。\n\n3.1 StaticDirectory:静态目录服务StaticDirectory 即静态服务目录，顾名思义，它内部存放的 Invoker 是不会变动的。所以，理论上它和不可变 List 的功能很相似。下面我们来看一下这个类的实现。\npublic class StaticDirectory&lt;T> extends AbstractDirectory&lt;T> &#123;\n\n    // Invoker 列表\n    private final List&lt;Invoker&lt;T>> invokers;\n    // 省略构造方法\n    @Override\n    public Class&lt;T> getInterface() &#123;\n        // 获取接口类\n        return invokers.get(0).getInterface();\n    &#125;\n    \n    // 检测服务目录是否可用\n    @Override\n    public boolean isAvailable() &#123;\n        if (isDestroyed()) &#123;\n            return false;\n        &#125;\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            if (invoker.isAvailable()) &#123;\n                // 只要有一个 Invoker 是可用的，就认为当前目录是可用的\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n\n    @Override\n    public void destroy() &#123;\n        if (isDestroyed()) &#123;\n            return;\n        &#125;\n        // 调用父类销毁逻辑\n        super.destroy();\n        // 遍历 Invoker 列表，并执行相应的销毁逻辑\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            invoker.destroy();\n        &#125;\n        invokers.clear();\n    &#125;\n\n    @Override\n    protected List&lt;Invoker&lt;T>> doList(Invocation invocation) throws RpcException &#123;\n        // 列举 Inovker，也就是直接返回 invokers 成员变量\n        return invokers;\n    &#125;\n&#125;\n\n以上就是 StaticDirectory 的代码逻辑，很简单，就不多说了。下面来看看 RegistryDirectory，这个类的逻辑比较复杂。\n\n3.2 RegistryDirectory:动态服务目录RegistryDirectory 是一种动态服务目录，实现了 NotifyListener 接口。当注册中心服务配置发生变化后，RegistryDirectory 可收到与当前服务相关的变化。收到变更通知后，RegistryDirectory 可根据配置变更信息刷新 Invoker 列表。RegistryDirectory 中有几个比较重要的逻辑，第一是 Invoker 的列举逻辑，第二是接收服务配置变更的逻辑，第三是 Invoker 列表的刷新逻辑。接下来按顺序对这三块逻辑进行分析。\n\n3.2.1 列举 InvokerInvoker 列举逻辑封装在 doList 方法中，相关代码如下：\npublic List&lt;Invoker&lt;T>> doList(Invocation invocation) &#123;\n    if (forbidden) &#123;\n        // 服务提供者关闭或禁用了服务，此时抛出 No provider 异常\n        throw new RpcException(RpcException.FORBIDDEN_EXCEPTION,\n            \"No provider available from registry ...\");\n    &#125;\n    List&lt;Invoker&lt;T>> invokers = null;\n    // 获取 Invoker 本地缓存\n    Map&lt;String, List&lt;Invoker&lt;T>>> localMethodInvokerMap = this.methodInvokerMap;\n    if (localMethodInvokerMap != null &amp;&amp; localMethodInvokerMap.size() > 0) &#123;\n        // 获取方法名和参数列表\n        String methodName = RpcUtils.getMethodName(invocation);\n        Object[] args = RpcUtils.getArguments(invocation);\n        // 检测参数列表的第一个参数是否为 String 或 enum 类型\n        if (args != null &amp;&amp; args.length > 0 &amp;&amp; args[0] != null\n                &amp;&amp; (args[0] instanceof String || args[0].getClass().isEnum())) &#123;\n            // 通过 方法名 + 第一个参数名称 查询 Invoker 列表，具体的使用场景暂时没想到\n            invokers = localMethodInvokerMap.get(methodName + \".\" + args[0]);\n        &#125;\n        if (invokers == null) &#123;\n            // 通过方法名获取 Invoker 列表\n            invokers = localMethodInvokerMap.get(methodName);\n        &#125;\n        if (invokers == null) &#123;\n            // 通过星号 * 获取 Invoker 列表\n            invokers = localMethodInvokerMap.get(Constants.ANY_VALUE);\n        &#125;\n        \n        // 冗余逻辑，pull request #2861 移除了下面的 if 分支代码\n        if (invokers == null) &#123;\n            Iterator&lt;List&lt;Invoker&lt;T>>> iterator = localMethodInvokerMap.values().iterator();\n            if (iterator.hasNext()) &#123;\n                invokers = iterator.next();\n            &#125;\n        &#125;\n    &#125;\n\n\t// 返回 Invoker 列表\n    return invokers == null ? new ArrayList&lt;Invoker&lt;T>>(0) : invokers;\n&#125;\n\n以上代码进行多次尝试，以期从 localMethodInvokerMap 中获取到 Invoker 列表。一般情况下，普通的调用可通过方法名获取到对应的 Invoker 列表，泛化调用可通过 * 获取到 Invoker 列表。localMethodInvokerMap 源自 RegistryDirectory 类的成员变量 methodInvokerMap。doList 方法可以看做是对 methodInvokerMap 变量的读操作，至于对 methodInvokerMap 变量的写操作，下一节进行分析。\n\n3.2.2 接收服务变更通知RegistryDirectory 是一个动态服务目录，会随注册中心配置的变化进行动态调整。因此 RegistryDirectory 实现了 NotifyListener 接口，通过这个接口获取注册中心变更通知。下面我们来看一下具体的逻辑。\npublic synchronized void notify(List&lt;URL> urls) &#123;\n    // 定义三个集合，分别用于存放服务提供者 url，路由 url，配置器 url\n    List&lt;URL> invokerUrls = new ArrayList&lt;URL>();\n    List&lt;URL> routerUrls = new ArrayList&lt;URL>();\n    List&lt;URL> configuratorUrls = new ArrayList&lt;URL>();\n    for (URL url : urls) &#123;\n        String protocol = url.getProtocol();\n        // 获取 category 参数\n        String category = url.getParameter(Constants.CATEGORY_KEY, Constants.DEFAULT_CATEGORY);\n        // 根据 category 参数将 url 分别放到不同的列表中\n        if (Constants.ROUTERS_CATEGORY.equals(category)\n                || Constants.ROUTE_PROTOCOL.equals(protocol)) &#123;\n            // 添加路由器 url\n            routerUrls.add(url);\n        &#125; else if (Constants.CONFIGURATORS_CATEGORY.equals(category)\n                || Constants.OVERRIDE_PROTOCOL.equals(protocol)) &#123;\n            // 添加配置器 url\n            configuratorUrls.add(url);\n        &#125; else if (Constants.PROVIDERS_CATEGORY.equals(category)) &#123;\n            // 添加服务提供者 url\n            invokerUrls.add(url);\n        &#125; else &#123;\n            // 忽略不支持的 category\n            logger.warn(\"Unsupported category ...\");\n        &#125;\n    &#125;\n    if (configuratorUrls != null &amp;&amp; !configuratorUrls.isEmpty()) &#123;\n        // 将 url 转成 Configurator\n        this.configurators = toConfigurators(configuratorUrls);\n    &#125;\n    if (routerUrls != null &amp;&amp; !routerUrls.isEmpty()) &#123;\n        // 将 url 转成 Router\n        List&lt;Router> routers = toRouters(routerUrls);\n        if (routers != null) &#123;\n            setRouters(routers);\n        &#125;\n    &#125;\n    List&lt;Configurator> localConfigurators = this.configurators;\n    this.overrideDirectoryUrl = directoryUrl;\n    if (localConfigurators != null &amp;&amp; !localConfigurators.isEmpty()) &#123;\n        for (Configurator configurator : localConfigurators) &#123;\n            // 配置 overrideDirectoryUrl\n            this.overrideDirectoryUrl = configurator.configure(overrideDirectoryUrl);\n        &#125;\n    &#125;\n\n    // 刷新 Invoker 列表\n    refreshInvoker(invokerUrls);\n&#125;\n\n如上，notify 方法首先是根据 url 的 category 参数对 url 进行分门别类存储，然后通过 toRouters 和 toConfigurators 将 url 列表转成 Router 和 Configurator 列表。最后调用 refreshInvoker 方法刷新 Invoker 列表。这里的 toRouters 和 toConfigurators 方法逻辑不复杂，大家自行分析。接下来，我们把重点放在 refreshInvoker 方法上。\n\n3.2.3 刷新 Invoker 列表refreshInvoker 方法是保证 RegistryDirectory 随注册中心变化而变化的关键所在。这一块逻辑比较多，接下来一一进行分析。\nprivate void refreshInvoker(List&lt;URL> invokerUrls) &#123;\n    // invokerUrls 仅有一个元素，且 url 协议头为 empty，此时表示禁用所有服务\n    if (invokerUrls != null &amp;&amp; invokerUrls.size() == 1 &amp;&amp; invokerUrls.get(0) != null\n            &amp;&amp; Constants.EMPTY_PROTOCOL.equals(invokerUrls.get(0).getProtocol())) &#123;\n        // 设置 forbidden 为 true\n        this.forbidden = true;\n        this.methodInvokerMap = null;\n        // 销毁所有 Invoker\n        destroyAllInvokers();\n    &#125; else &#123;\n        this.forbidden = false;\n        Map&lt;String, Invoker&lt;T>> oldUrlInvokerMap = this.urlInvokerMap;\n        if (invokerUrls.isEmpty() &amp;&amp; this.cachedInvokerUrls != null) &#123;\n            // 添加缓存 url 到 invokerUrls 中\n            invokerUrls.addAll(this.cachedInvokerUrls);\n        &#125; else &#123;\n            this.cachedInvokerUrls = new HashSet&lt;URL>();\n            // 缓存 invokerUrls\n            this.cachedInvokerUrls.addAll(invokerUrls);\n        &#125;\n        if (invokerUrls.isEmpty()) &#123;\n            return;\n        &#125;\n        // 将 url 转成 Invoker\n        Map&lt;String, Invoker&lt;T>> newUrlInvokerMap = toInvokers(invokerUrls);\n        // 将 newUrlInvokerMap 转成方法名到 Invoker 列表的映射\n        Map&lt;String, List&lt;Invoker&lt;T>>> newMethodInvokerMap = toMethodInvokers(newUrlInvokerMap);\n        // 转换出错，直接打印异常，并返回\n        if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123;\n            logger.error(new IllegalStateException(\"urls to invokers error ...\"));\n            return;\n        &#125;\n        // 合并多个组的 Invoker\n        this.methodInvokerMap = multiGroup ? toMergeMethodInvokerMap(newMethodInvokerMap) : newMethodInvokerMap;\n        this.urlInvokerMap = newUrlInvokerMap;\n        try &#123;\n            // 销毁无用 Invoker\n            destroyUnusedInvokers(oldUrlInvokerMap, newUrlInvokerMap);\n        &#125; catch (Exception e) &#123;\n            logger.warn(\"destroyUnusedInvokers error. \", e);\n        &#125;\n    &#125;\n&#125;\n\nrefreshInvoker 方法首先会根据入参 invokerUrls 的数量和协议头判断是否禁用所有的服务，如果禁用，则将 forbidden 设为 true，并销毁所有的 Invoker。若不禁用，则将 url 转成 Invoker，得到 &lt;url, Invoker&gt; 的映射关系。然后进一步进行转换，得到 &lt;methodName, Invoker 列表&gt; 映射关系。之后进行多组 Invoker 合并操作，并将合并结果赋值给 methodInvokerMap。methodInvokerMap 变量在 doList 方法中会被用到，doList 会对该变量进行读操作，在这里是写操作。当新的 Invoker 列表生成后，还要一个重要的工作要做，就是销毁无用的 Invoker，避免服务消费者调用已下线的服务的服务。\n接下来对 refreshInvoker 方法中涉及到的调用一一进行分析。按照顺序，先来分析 url 到 Invoker 的转换过程。\nprivate Map&lt;String, Invoker&lt;T>> toInvokers(List&lt;URL> urls) &#123;\n    Map&lt;String, Invoker&lt;T>> newUrlInvokerMap = new HashMap&lt;String, Invoker&lt;T>>();\n    if (urls == null || urls.isEmpty()) &#123;\n        return newUrlInvokerMap;\n    &#125;\n    Set&lt;String> keys = new HashSet&lt;String>();\n    // 获取服务消费端配置的协议\n    String queryProtocols = this.queryMap.get(Constants.PROTOCOL_KEY);\n    for (URL providerUrl : urls) &#123;\n        if (queryProtocols != null &amp;&amp; queryProtocols.length() > 0) &#123;\n            boolean accept = false;\n            String[] acceptProtocols = queryProtocols.split(\",\");\n            // 检测服务提供者协议是否被服务消费者所支持\n            for (String acceptProtocol : acceptProtocols) &#123;\n                if (providerUrl.getProtocol().equals(acceptProtocol)) &#123;\n                    accept = true;\n                    break;\n                &#125;\n            &#125;\n            if (!accept) &#123;\n                // 若服务提供者协议头不被消费者所支持，则忽略当前 providerUrl\n                continue;\n            &#125;\n        &#125;\n        // 忽略 empty 协议\n        if (Constants.EMPTY_PROTOCOL.equals(providerUrl.getProtocol())) &#123;\n            continue;\n        &#125;\n        // 通过 SPI 检测服务端协议是否被消费端支持，不支持则抛出异常\n        if (!ExtensionLoader.getExtensionLoader(Protocol.class).hasExtension(providerUrl.getProtocol())) &#123;\n            logger.error(new IllegalStateException(\"Unsupported protocol...\"));\n            continue;\n        &#125;\n        \n        // 合并 url\n        URL url = mergeUrl(providerUrl);\n\n        String key = url.toFullString();\n        if (keys.contains(key)) &#123;\n            // 忽略重复 url\n            continue;\n        &#125;\n        keys.add(key);\n        // 将本地 Invoker 缓存赋值给 localUrlInvokerMap\n        Map&lt;String, Invoker&lt;T>> localUrlInvokerMap = this.urlInvokerMap;\n        // 获取与 url 对应的 Invoker\n        Invoker&lt;T> invoker = localUrlInvokerMap == null ? null : localUrlInvokerMap.get(key);\n        // 缓存未命中\n        if (invoker == null) &#123;\n            try &#123;\n                boolean enabled = true;\n                if (url.hasParameter(Constants.DISABLED_KEY)) &#123;\n                    // 获取 disable 配置，取反，然后赋值给 enable 变量\n                    enabled = !url.getParameter(Constants.DISABLED_KEY, false);\n                &#125; else &#123;\n                    // 获取 enable 配置，并赋值给 enable 变量\n                    enabled = url.getParameter(Constants.ENABLED_KEY, true);\n                &#125;\n                if (enabled) &#123;\n                    // 调用 refer 获取 Invoker\n                    invoker = new InvokerDelegate&lt;T>(protocol.refer(serviceType, url), url, providerUrl);\n                &#125;\n            &#125; catch (Throwable t) &#123;\n                logger.error(\"Failed to refer invoker for interface...\");\n            &#125;\n            if (invoker != null) &#123;\n                // 缓存 Invoker 实例\n                newUrlInvokerMap.put(key, invoker);\n            &#125;\n            \n        // 缓存命中\n        &#125; else &#123;\n            // 将 invoker 存储到 newUrlInvokerMap 中\n            newUrlInvokerMap.put(key, invoker);\n        &#125;\n    &#125;\n    keys.clear();\n    return newUrlInvokerMap;\n&#125;\n\ntoInvokers 方法一开始会对服务提供者 url 进行检测，若服务消费端的配置不支持服务端的协议，或服务端 url 协议头为 empty 时，toInvokers 均会忽略服务提供方 url。必要的检测做完后，紧接着是合并 url，然后访问缓存，尝试获取与 url 对应的 invoker。如果缓存命中，直接将 Invoker 存入 newUrlInvokerMap 中即可。如果未命中，则需新建 Invoker。\ntoInvokers 方法返回的是 &lt;url, Invoker&gt; 映射关系表，接下来还要对这个结果进行进一步处理，得到方法名到 Invoker 列表的映射关系。这个过程由 toMethodInvokers 方法完成，如下：\nprivate Map&lt;String, List&lt;Invoker&lt;T>>> toMethodInvokers(Map&lt;String, Invoker&lt;T>> invokersMap) &#123;\n    // 方法名 -> Invoker 列表\n    Map&lt;String, List&lt;Invoker&lt;T>>> newMethodInvokerMap = new HashMap&lt;String, List&lt;Invoker&lt;T>>>();\n    List&lt;Invoker&lt;T>> invokersList = new ArrayList&lt;Invoker&lt;T>>();\n    if (invokersMap != null &amp;&amp; invokersMap.size() > 0) &#123;\n        for (Invoker&lt;T> invoker : invokersMap.values()) &#123;\n            // 获取 methods 参数\n            String parameter = invoker.getUrl().getParameter(Constants.METHODS_KEY);\n            if (parameter != null &amp;&amp; parameter.length() > 0) &#123;\n                // 切分 methods 参数值，得到方法名数组\n                String[] methods = Constants.COMMA_SPLIT_PATTERN.split(parameter);\n                if (methods != null &amp;&amp; methods.length > 0) &#123;\n                    for (String method : methods) &#123;\n                        // 方法名不为 *\n                        if (method != null &amp;&amp; method.length() > 0\n                                &amp;&amp; !Constants.ANY_VALUE.equals(method)) &#123;\n                            // 根据方法名获取 Invoker 列表\n                            List&lt;Invoker&lt;T>> methodInvokers = newMethodInvokerMap.get(method);\n                            if (methodInvokers == null) &#123;\n                                methodInvokers = new ArrayList&lt;Invoker&lt;T>>();\n                                newMethodInvokerMap.put(method, methodInvokers);\n                            &#125;\n                            // 存储 Invoker 到列表中\n                            methodInvokers.add(invoker);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            invokersList.add(invoker);\n        &#125;\n    &#125;\n    \n    // 进行服务级别路由，参考 pull request #749\n    List&lt;Invoker&lt;T>> newInvokersList = route(invokersList, null);\n    // 存储 &lt;*, newInvokersList> 映射关系\n    newMethodInvokerMap.put(Constants.ANY_VALUE, newInvokersList);\n    if (serviceMethods != null &amp;&amp; serviceMethods.length > 0) &#123;\n        for (String method : serviceMethods) &#123;\n            List&lt;Invoker&lt;T>> methodInvokers = newMethodInvokerMap.get(method);\n            if (methodInvokers == null || methodInvokers.isEmpty()) &#123;\n                methodInvokers = newInvokersList;\n            &#125;\n            // 进行方法级别路由\n            newMethodInvokerMap.put(method, route(methodInvokers, method));\n        &#125;\n    &#125;\n    // 排序，转成不可变列表\n    for (String method : new HashSet&lt;String>(newMethodInvokerMap.keySet())) &#123;\n        List&lt;Invoker&lt;T>> methodInvokers = newMethodInvokerMap.get(method);\n        Collections.sort(methodInvokers, InvokerComparator.getComparator());\n        newMethodInvokerMap.put(method, Collections.unmodifiableList(methodInvokers));\n    &#125;\n    return Collections.unmodifiableMap(newMethodInvokerMap);\n&#125;\n\n上面方法主要做了三件事情， 第一是对入参进行遍历，然后从 Invoker 的 url 成员变量中获取 methods 参数，并切分成数组。随后以方法名为键，Invoker 列表为值，将映射关系存储到 newMethodInvokerMap 中。第二是分别基于类和方法对 Invoker 列表进行路由操作。第三是对 Invoker 列表进行排序，并转成不可变列表。关于 toMethodInvokers 方法就先分析到这，我们继续向下分析，这次要分析的多组服务的合并逻辑。\nprivate Map&lt;String, List&lt;Invoker&lt;T>>> toMergeMethodInvokerMap(Map&lt;String, List&lt;Invoker&lt;T>>> methodMap) &#123;\n    Map&lt;String, List&lt;Invoker&lt;T>>> result = new HashMap&lt;String, List&lt;Invoker&lt;T>>>();\n    // 遍历入参\n    for (Map.Entry&lt;String, List&lt;Invoker&lt;T>>> entry : methodMap.entrySet()) &#123;\n        String method = entry.getKey();\n        List&lt;Invoker&lt;T>> invokers = entry.getValue();\n        // group -> Invoker 列表\n        Map&lt;String, List&lt;Invoker&lt;T>>> groupMap = new HashMap&lt;String, List&lt;Invoker&lt;T>>>();\n        // 遍历 Invoker 列表\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            // 获取分组配置\n            String group = invoker.getUrl().getParameter(Constants.GROUP_KEY, \"\");\n            List&lt;Invoker&lt;T>> groupInvokers = groupMap.get(group);\n            if (groupInvokers == null) &#123;\n                groupInvokers = new ArrayList&lt;Invoker&lt;T>>();\n                // 缓存 &lt;group, List&lt;Invoker>> 到 groupMap 中\n                groupMap.put(group, groupInvokers);\n            &#125;\n            // 存储 invoker 到 groupInvokers\n            groupInvokers.add(invoker);\n        &#125;\n        if (groupMap.size() == 1) &#123;\n            // 如果 groupMap 中仅包含一组键值对，此时直接取出该键值对的值即可\n            result.put(method, groupMap.values().iterator().next());\n        \n        // groupMap.size() > 1 成立，表示 groupMap 中包含多组键值对，比如：\n        // &#123;\n        //     \"dubbo\": [invoker1, invoker2, invoker3, ...],\n        //     \"hello\": [invoker4, invoker5, invoker6, ...]\n        // &#125;\n        &#125; else if (groupMap.size() > 1) &#123;\n            List&lt;Invoker&lt;T>> groupInvokers = new ArrayList&lt;Invoker&lt;T>>();\n            for (List&lt;Invoker&lt;T>> groupList : groupMap.values()) &#123;\n                // 通过集群类合并每个分组对应的 Invoker 列表\n                groupInvokers.add(cluster.join(new StaticDirectory&lt;T>(groupList)));\n            &#125;\n            // 缓存结果\n            result.put(method, groupInvokers);\n        &#125; else &#123;\n            result.put(method, invokers);\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n上面方法首先是生成 group 到 Invoker 列表的映射关系表，若关系表中的映射关系数量大于1，表示有多组服务。此时通过集群类合并每组 Invoker，并将合并结果存储到 groupInvokers 中。之后将方法名与 groupInvokers 存到到 result 中，并返回，整个逻辑结束。\n接下来我们再来看一下 Invoker 列表刷新逻辑的最后一个动作 — 删除无用 Invoker。如下：\nprivate void destroyUnusedInvokers(Map&lt;String, Invoker&lt;T>> oldUrlInvokerMap, Map&lt;String, Invoker&lt;T>> newUrlInvokerMap) &#123;\n    if (newUrlInvokerMap == null || newUrlInvokerMap.size() == 0) &#123;\n        destroyAllInvokers();\n        return;\n    &#125;\n   \n    List&lt;String> deleted = null;\n    if (oldUrlInvokerMap != null) &#123;\n        // 获取新生成的 Invoker 列表\n        Collection&lt;Invoker&lt;T>> newInvokers = newUrlInvokerMap.values();\n        // 遍历老的 &lt;url, Invoker> 映射表\n        for (Map.Entry&lt;String, Invoker&lt;T>> entry : oldUrlInvokerMap.entrySet()) &#123;\n            // 检测 newInvokers 中是否包含老的 Invoker\n            if (!newInvokers.contains(entry.getValue())) &#123;\n                if (deleted == null) &#123;\n                    deleted = new ArrayList&lt;String>();\n                &#125;\n                // 若不包含，则将老的 Invoker 对应的 url 存入 deleted 列表中\n                deleted.add(entry.getKey());\n            &#125;\n        &#125;\n    &#125;\n\n    if (deleted != null) &#123;\n        // 遍历 deleted 集合，并到老的 &lt;url, Invoker> 映射关系表查出 Invoker，销毁之\n        for (String url : deleted) &#123;\n            if (url != null) &#123;\n                // 从 oldUrlInvokerMap 中移除 url 对应的 Invoker\n                Invoker&lt;T> invoker = oldUrlInvokerMap.remove(url);\n                if (invoker != null) &#123;\n                    try &#123;\n                        // 销毁 Invoker\n                        invoker.destroy();\n                    &#125; catch (Exception e) &#123;\n                        logger.warn(\"destroy invoker...\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\ndestroyUnusedInvokers 方法的主要逻辑是通过 newUrlInvokerMap 找出待删除 Invoker 对应的 url，并将 url 存入到 deleted 列表中。然后再遍历 deleted 列表，并从 oldUrlInvokerMap 中移除相应的 Invoker，销毁之。整个逻辑大致如此，不是很难理解。\n到此关于 Invoker 列表的刷新逻辑就分析了，这里对整个过程进行简单总结。如下：\n\n检测入参是否仅包含一个 url，且 url 协议头为 empty\n若第一步检测结果为 true，表示禁用所有服务，此时销毁所有的 Invoker\n若第一步检测结果为 false，此时将入参转为 Invoker 列表\n对上一步逻辑生成的结果进行进一步处理，得到方法名到 Invoker 的映射关系表\n合并多组 Invoker\n销毁无用 Invoker\n\nInvoker 的刷新逻辑还是比较复杂的，大家在看的过程中多写点 demo 进行调试，以加深理解。\n\n4. 总结本篇文章对 Dubbo 服务目录进行了较为详细的分析，篇幅主要集中在 RegistryDirectory 的源码分析上。从代码量上可以看出，想让本地服务目录和注册中心保持一致还是需要做很多事情的，并不简单。服务目录是 Dubbo 集群容错的一部分，也是比较基础的部分，所以大家应尽量搞懂。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/router/\n作者： Dubbo 官方\n\n服务路由1. 简介上一篇文章分析了集群容错的第一部分 — 服务目录 Directory。服务目录在刷新 Invoker 列表的过程中，会通过 Router 进行服务路由，筛选出符合路由规则的服务提供者。在详细分析服务路由的源码之前，先来介绍一下服务路由是什么。服务路由包含一条路由规则，路由规则决定了服务消费者的调用目标，即规定了服务消费者可调用哪些服务提供者。Dubbo 目前提供了三种服务路由实现，分别为：\n\n条件路由 ConditionRouter\n脚本路由 ScriptRouter\n标签路由 TagRouter。\n\n条件路由是我们最常使用的，标签路由是一个新的实现，暂时还未发布，该实现预计会在 2.7.x 版本中发布。本篇文章将分析条件路由相关源码，脚本路由和标签路由这里就不分析了。\n\n2. 源码分析条件路由规则由两个条件组成，分别用于对服务消费者和提供者进行匹配。比如有这样一条规则：\nhost &#x3D; 10.20.153.10 &#x3D;&gt; host &#x3D; 10.20.153.11\n\n该条规则表示 IP 为 10.20.153.10 的服务消费者只可调用 IP 为 10.20.153.11 机器上的服务，不可调用其他机器上的服务。条件路由规则的格式如下：\n[服务消费者匹配条件] &#x3D;&gt; [服务提供者匹配条件]\n\n如果服务消费者匹配条件为空，表示不对服务消费者进行限制。如果服务提供者匹配条件为空，表示对某些服务消费者禁用服务。官方文档中对条件路由进行了比较详细的介绍，大家可以参考下，这里就不过多说明了。\n条件路由实现类 ConditionRouter 在进行工作前，需要先对用户配置的路由规则进行解析，得到一系列的条件。然后再根据这些条件对服务进行路由。本章将分两节进行说明，2.1节介绍表达式解析过程。2.2 节介绍服务路由的过程。下面，我们先从表达式解析过程看起。\n\n2.1 表达式解析条件路由规则是一条字符串，对于 Dubbo 来说，它并不能直接理解字符串的意思，需要将其解析成内部格式才行。条件表达式的解析过程始于 ConditionRouter 的构造方法，下面一起看一下：\npublic ConditionRouter(URL url) &#123;\n    this.url = url;\n    // 获取 priority 和 force 配置\n    this.priority = url.getParameter(Constants.PRIORITY_KEY, 0);\n    this.force = url.getParameter(Constants.FORCE_KEY, false);\n    try &#123;\n        // 获取路由规则\n        String rule = url.getParameterAndDecoded(Constants.RULE_KEY);\n        if (rule == null || rule.trim().length() == 0) &#123;\n            throw new IllegalArgumentException(\"Illegal route rule!\");\n        &#125;\n        rule = rule.replace(\"consumer.\", \"\").replace(\"provider.\", \"\");\n        // 定位 => 分隔符\n        int i = rule.indexOf(\"=>\");\n        // 分别获取服务消费者和提供者匹配规则\n        String whenRule = i &lt; 0 ? null : rule.substring(0, i).trim();\n        String thenRule = i &lt; 0 ? rule.trim() : rule.substring(i + 2).trim();\n        // 解析服务消费者匹配规则\n        Map&lt;String, MatchPair> when = \n            StringUtils.isBlank(whenRule) || \"true\".equals(whenRule) \n                ? new HashMap&lt;String, MatchPair>() : parseRule(whenRule);\n        // 解析服务提供者匹配规则\n        Map&lt;String, MatchPair> then = \n            StringUtils.isBlank(thenRule) || \"false\".equals(thenRule) \n                ? null : parseRule(thenRule);\n        // 将解析出的匹配规则分别赋值给 whenCondition 和 thenCondition 成员变量\n        this.whenCondition = when;\n        this.thenCondition = then;\n    &#125; catch (ParseException e) &#123;\n        throw new IllegalStateException(e.getMessage(), e);\n    &#125;\n&#125;\n\n如上，ConditionRouter 构造方法先是对路由规则做预处理，然后调用 parseRule 方法分别对服务提供者和消费者规则进行解析，最后将解析结果赋值给 whenCondition 和 thenCondition 成员变量。ConditionRouter 构造方法不是很复杂，这里就不多说了。下面我们把重点放在 parseRule 方法上，在详细介绍这个方法之前，我们先来看一个内部类。\nprivate static final class MatchPair &#123;\n    final Set&lt;String> matches = new HashSet&lt;String>();\n    final Set&lt;String> mismatches = new HashSet&lt;String>();\n&#125;\n\nMatchPair 内部包含了两个 Set 类型的成员变量，分别用于存放匹配和不匹配的条件。这个类两个成员变量会在 parseRule 方法中被用到，下面来看一下。\nprivate static Map&lt;String, MatchPair> parseRule(String rule)\n        throws ParseException &#123;\n    // 定义条件映射集合\n    Map&lt;String, MatchPair> condition = new HashMap&lt;String, MatchPair>();\n    if (StringUtils.isBlank(rule)) &#123;\n        return condition;\n    &#125;\n    MatchPair pair = null;\n    Set&lt;String> values = null;\n    // 通过正则表达式匹配路由规则，ROUTE_PATTERN = ([&amp;!=,]*)\\s*([^&amp;!=,\\s]+)\n    // 这个表达式看起来不是很好理解，第一个括号内的表达式用于匹配\"&amp;\", \"!\", \"=\" 和 \",\" 等符号。\n    // 第二括号内的用于匹配英文字母，数字等字符。举个例子说明一下：\n    //    host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello\n    // 匹配结果如下：\n    //     括号一      括号二\n    // 1.  null       host\n    // 2.   =         2.2.2.2\n    // 3.   &amp;         host\n    // 4.   !=        1.1.1.1 \n    // 5.   &amp;         method\n    // 6.   =         hello\n    final Matcher matcher = ROUTE_PATTERN.matcher(rule);\n    while (matcher.find()) &#123;\n       \t// 获取括号一内的匹配结果\n        String separator = matcher.group(1);\n        // 获取括号二内的匹配结果\n        String content = matcher.group(2);\n        // 分隔符为空，表示匹配的是表达式的开始部分\n        if (separator == null || separator.length() == 0) &#123;\n            // 创建 MatchPair 对象\n            pair = new MatchPair();\n            // 存储 &lt;匹配项, MatchPair> 键值对，比如 &lt;host, MatchPair>\n            condition.put(content, pair); \n        &#125; \n        \n        // 如果分隔符为 &amp;，表明接下来也是一个条件\n        else if (\"&amp;\".equals(separator)) &#123;\n            // 尝试从 condition 获取 MatchPair\n            if (condition.get(content) == null) &#123;\n                // 未获取到 MatchPair，重新创建一个，并放入 condition 中\n                pair = new MatchPair();\n                condition.put(content, pair);\n            &#125; else &#123;\n                pair = condition.get(content);\n            &#125;\n        &#125; \n        \n        // 分隔符为 =\n        else if (\"=\".equals(separator)) &#123;\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule ...\");\n\n            values = pair.matches;\n            // 将 content 存入到 MatchPair 的 matches 集合中\n            values.add(content);\n        &#125; \n        \n        //  分隔符为 != \n        else if (\"!=\".equals(separator)) &#123;\n            if (pair == null)\n                throw new ParseException(\"Illegal route rule ...\");\n\n            values = pair.mismatches;\n            // 将 content 存入到 MatchPair 的 mismatches 集合中\n            values.add(content);\n        &#125;\n        \n        // 分隔符为 ,\n        else if (\",\".equals(separator)) &#123;\n            if (values == null || values.isEmpty())\n                throw new ParseException(\"Illegal route rule ...\");\n            // 将 content 存入到上一步获取到的 values 中，可能是 matches，也可能是 mismatches\n            values.add(content);\n        &#125; else &#123;\n            throw new ParseException(\"Illegal route rule ...\");\n        &#125;\n    &#125;\n    return condition;\n&#125;\n\n以上就是路由规则的解析逻辑，该逻辑由正则表达式和一个 while 循环以及数个条件分支组成。下面通过一个示例对解析逻辑进行演绎。示例为 host = 2.2.2.2 &amp; host != 1.1.1.1 &amp; method = hello。正则解析结果如下：\n    括号一      括号二\n1.  null       host\n2.   &#x3D;         2.2.2.2\n3.   &amp;         host\n4.   !&#x3D;        1.1.1.1\n5.   &amp;         method\n6.   &#x3D;         hello\n\n现在线程进入 while 循环：\n第一次循环：分隔符 separator &#x3D; null，content &#x3D; “host”。此时创建 MatchPair 对象，并存入到 condition 中，condition &#x3D; {“host”: MatchPair@123}\n第二次循环：分隔符 separator &#x3D; “&#x3D;”，content &#x3D; “2.2.2.2”，pair &#x3D; MatchPair@123。此时将 2.2.2.2 放入到 MatchPair@123  对象的 matches 集合中。 \n第三次循环：分隔符 separator &#x3D; “&amp;”，content &#x3D; “host”。host 已存在于 condition 中，因此 pair &#x3D; MatchPair@123。\n第四次循环：分隔符 separator &#x3D; “!&#x3D;”，content &#x3D; “1.1.1.1”，pair &#x3D; MatchPair@123。此时将 1.1.1.1 放入到 MatchPair@123  对象的 mismatches 集合中。 \n第五次循环：分隔符 separator &#x3D; “&amp;”，content &#x3D; “method”。condition.get(“method”) &#x3D; null，因此新建一个 MatchPair 对象，并放入到 condition 中。此时 condition &#x3D; {“host”: MatchPair@123, “method”: MatchPair@ 456}\n第六次循环：分隔符 separator &#x3D; “&#x3D;”，content &#x3D; “2.2.2.2”，pair &#x3D; MatchPair@456。此时将 hello 放入到 MatchPair@456  对象的 matches 集合中。 \n循环结束，此时 condition 的内容如下：\n&#123;\n    \"host\": &#123;\n        \"matches\": [\"2.2.2.2\"],\n        \"mismatches\": [\"1.1.1.1\"]\n    &#125;,\n    \"method\": &#123;\n        \"matches\": [\"hello\"],\n        \"mismatches\": []\n    &#125;\n&#125;\n\n路由规则的解析过程稍微有点复杂，大家可通过 ConditionRouter 的测试类对该逻辑进行测试。并且找一个表达式，对照上面的代码走一遍，加深理解。\n\n2.2 服务路由服务路由的入口方法是 ConditionRouter 的 route 方法，该方法定义在 Router 接口中。实现代码如下：\npublic &lt;T> List&lt;Invoker&lt;T>> route(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) throws RpcException &#123;\n    if (invokers == null || invokers.isEmpty()) &#123;\n        return invokers;\n    &#125;\n    try &#123;\n        // 先对服务消费者条件进行匹配，如果匹配失败，表明服务消费者 url 不符合匹配规则，\n        // 无需进行后续匹配，直接返回 Invoker 列表即可。比如下面的规则：\n        //     host = 10.20.153.10 => host = 10.0.0.10\n        // 这条路由规则希望 IP 为 10.20.153.10 的服务消费者调用 IP 为 10.0.0.10 机器上的服务。\n        // 当消费者 ip 为 10.20.153.11 时，matchWhen 返回 false，表明当前这条路由规则不适用于\n        // 当前的服务消费者，此时无需再进行后续匹配，直接返回即可。\n        if (!matchWhen(url, invocation)) &#123;\n            return invokers;\n        &#125;\n        List&lt;Invoker&lt;T>> result = new ArrayList&lt;Invoker&lt;T>>();\n        // 服务提供者匹配条件未配置，表明对指定的服务消费者禁用服务，也就是服务消费者在黑名单中\n        if (thenCondition == null) &#123;\n            logger.warn(\"The current consumer in the service blacklist...\");\n            return result;\n        &#125;\n        // 这里可以简单的把 Invoker 理解为服务提供者，现在使用服务提供者匹配规则对 \n        // Invoker 列表进行匹配\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            // 若匹配成功，表明当前 Invoker 符合服务提供者匹配规则。\n            // 此时将 Invoker 添加到 result 列表中\n            if (matchThen(invoker.getUrl(), url)) &#123;\n                result.add(invoker);\n            &#125;\n        &#125;\n        \n        // 返回匹配结果，如果 result 为空列表，且 force = true，表示强制返回空列表，\n        // 否则路由结果为空的路由规则将自动失效\n        if (!result.isEmpty()) &#123;\n            return result;\n        &#125; else if (force) &#123;\n            logger.warn(\"The route result is empty and force execute ...\");\n            return result;\n        &#125;\n    &#125; catch (Throwable t) &#123;\n        logger.error(\"Failed to execute condition router rule: ...\");\n    &#125;\n    \n    // 原样返回，此时 force = false，表示该条路由规则失效\n    return invokers;\n&#125;\n\nroute 方法先是调用 matchWhen 对服务消费者进行匹配，如果匹配失败，直接返回 Invoker 列表。如果匹配成功，再对服务提供者进行匹配，匹配逻辑封装在了 matchThen 方法中。下面来看一下这两个方法的逻辑：\nboolean matchWhen(URL url, Invocation invocation) &#123;\n    // 服务消费者条件为 null 或空，均返回 true，比如：\n    //     => host != 172.22.3.91\n    // 表示所有的服务消费者都不得调用 IP 为 172.22.3.91 的机器上的服务\n    return whenCondition == null || whenCondition.isEmpty() \n        || matchCondition(whenCondition, url, null, invocation);  // 进行条件匹配\n&#125;\n\nprivate boolean matchThen(URL url, URL param) &#123;\n    // 服务提供者条件为 null 或空，表示禁用服务\n    return !(thenCondition == null || thenCondition.isEmpty()) \n        &amp;&amp; matchCondition(thenCondition, url, param, null);  // 进行条件匹配\n&#125;\n\n这两个方法长的有点像，不过逻辑上还是有差别的，大家注意看。这两个方法均调用了 matchCondition 方法，但它们所传入的参数是不同的。这个需要特别注意一下，不然后面的逻辑不好弄懂。下面我们对这几个参数进行溯源。matchWhen 方法向 matchCondition 方法传入的参数为 [whenCondition, url, null, invocation]，第一个参数 whenCondition 为服务消费者匹配条件，这个前面分析过。第二个参数 url 源自 route 方法的参数列表，该参数由外部类调用 route 方法时传入。比如：\nprivate List&lt;Invoker&lt;T>> route(List&lt;Invoker&lt;T>> invokers, String method) &#123;\n    Invocation invocation = new RpcInvocation(method, new Class&lt;?>[0], new Object[0]);\n    List&lt;Router> routers = getRouters();\n    if (routers != null) &#123;\n        for (Router router : routers) &#123;\n            if (router.getUrl() != null) &#123;\n                // 注意第二个参数\n                invokers = router.route(invokers, getConsumerUrl(), invocation);\n            &#125;\n        &#125;\n    &#125;\n    return invokers;\n&#125;\n\n上面这段代码来自 RegistryDirectory，第二个参数表示的是服务消费者 url。matchCondition 的 invocation 参数也是从这里传入的。\n接下来再来看看 matchThen 向 matchCondition 方法传入的参数 [thenCondition, url, param, null]。第一个参数不用解释了。第二个和第三个参数来自 matchThen 方法的参数列表，这两个参数分别为服务提供者 url 和服务消费者 url。搞清楚这些参数来源后，接下来就可以分析 matchCondition 方法了。\nprivate boolean matchCondition(Map&lt;String, MatchPair> condition, URL url, URL param, Invocation invocation) &#123;\n    // 将服务提供者或消费者 url 转成 Map\n    Map&lt;String, String> sample = url.toMap();\n    boolean result = false;\n    // 遍历 condition 列表\n    for (Map.Entry&lt;String, MatchPair> matchPair : condition.entrySet()) &#123;\n        // 获取匹配项名称，比如 host、method 等\n        String key = matchPair.getKey();\n        String sampleValue;\n        // 如果 invocation 不为空，且 key 为 method(s)，表示进行方法匹配\n        if (invocation != null &amp;&amp; (Constants.METHOD_KEY.equals(key) || Constants.METHODS_KEY.equals(key))) &#123;\n            // 从 invocation 获取被调用方法的名称\n            sampleValue = invocation.getMethodName();\n        &#125; else &#123;\n            // 从服务提供者或消费者 url 中获取指定字段值，比如 host、application 等\n            sampleValue = sample.get(key);\n            if (sampleValue == null) &#123;\n                // 尝试通过 default.xxx 获取相应的值\n                sampleValue = sample.get(Constants.DEFAULT_KEY_PREFIX + key);\n            &#125;\n        &#125;\n        \n        // --------------------✨ 分割线 ✨-------------------- //\n        \n        if (sampleValue != null) &#123;\n            // 调用 MatchPair 的 isMatch 方法进行匹配\n            if (!matchPair.getValue().isMatch(sampleValue, param)) &#123;\n                // 只要有一个规则匹配失败，立即返回 false 结束方法逻辑\n                return false;\n            &#125; else &#123;\n                result = true;\n            &#125;\n        &#125; else &#123;\n            // sampleValue 为空，表明服务提供者或消费者 url 中不包含相关字段。此时如果 \n            // MatchPair 的 matches 不为空，表示匹配失败，返回 false。比如我们有这样\n            // 一条匹配条件 loadbalance = random，假设 url 中并不包含 loadbalance 参数，\n            // 此时 sampleValue = null。既然路由规则里限制了 loadbalance 必须为 random，\n            // 但 sampleValue = null，明显不符合规则，因此返回 false\n            if (!matchPair.getValue().matches.isEmpty()) &#123;\n                return false;\n            &#125; else &#123;\n                result = true;\n            &#125;\n        &#125;\n    &#125;\n    return result;\n&#125;\n\n如上，matchCondition 方法看起来有点复杂，这里简单说明一下。分割线以上的代码实际上用于获取 sampleValue 的值，分割线以下才是进行条件匹配。条件匹配调用的逻辑封装在 isMatch 中，代码如下：\nprivate boolean isMatch(String value, URL param) &#123;\n    // 情况一：matches 非空，mismatches 为空\n    if (!matches.isEmpty() &amp;&amp; mismatches.isEmpty()) &#123;\n        // 遍历 matches 集合，检测入参 value 是否能被 matches 集合元素匹配到。\n        // 举个例子，如果 value = 10.20.153.11，matches = [10.20.153.*],\n        // 此时 isMatchGlobPattern 方法返回 true\n        for (String match : matches) &#123;\n            if (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;\n                return true;\n            &#125;\n        &#125;\n        \n        // 如果所有匹配项都无法匹配到入参，则返回 false\n        return false;\n    &#125;\n\n    // 情况二：matches 为空，mismatches 非空\n    if (!mismatches.isEmpty() &amp;&amp; matches.isEmpty()) &#123;\n        for (String mismatch : mismatches) &#123;\n            // 只要入参被 mismatches 集合中的任意一个元素匹配到，就返回 false\n            if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;\n                return false;\n            &#125;\n        &#125;\n        // mismatches 集合中所有元素都无法匹配到入参，此时返回 true\n        return true;\n    &#125;\n\n    // 情况三：matches 非空，mismatches 非空\n    if (!matches.isEmpty() &amp;&amp; !mismatches.isEmpty()) &#123;\n        // matches 和 mismatches 均为非空，此时优先使用 mismatches 集合元素对入参进行匹配。\n        // 只要 mismatches 集合中任意一个元素与入参匹配成功，就立即返回 false，结束方法逻辑\n        for (String mismatch : mismatches) &#123;\n            if (UrlUtils.isMatchGlobPattern(mismatch, value, param)) &#123;\n                return false;\n            &#125;\n        &#125;\n        // mismatches 集合元素无法匹配到入参，此时再使用 matches 继续匹配\n        for (String match : matches) &#123;\n            // 只要 matches 集合中任意一个元素与入参匹配成功，就立即返回 true\n            if (UrlUtils.isMatchGlobPattern(match, value, param)) &#123;\n                return true;\n            &#125;\n        &#125;\n        \n        // 全部失配，则返回 false\n        return false;\n    &#125;\n    \n    // 情况四：matches 和 mismatches 均为空，此时返回 false\n    return false;\n&#125;\n\nisMatch 方法逻辑比较清晰，由三个条件分支组成，用于处理四种情况。这里对四种情况下的匹配逻辑进行简单的总结，如下：\n\n\n\n\n条件\n过程\n\n\n\n情况一\nmatches 非空，mismatches 为空\n遍历 matches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，即可返回 true。若全部失配，则返回 false。\n\n\n情况二\nmatches 为空，mismatches 非空\n遍历 mismatches 集合元素，并与入参进行匹配。只要有一个元素成功匹配入参，立即 false。若全部失配，则返回 true。\n\n\n情况三\nmatches 非空，mismatches 非空\n优先使用 mismatches 集合元素对入参进行匹配，只要任一元素与入参匹配成功，就立即返回 false，结束方法逻辑。否则再使用 matches 中的集合元素进行匹配，只要有任意一个元素匹配成功，即可返回 true。若全部失配，则返回 false\n\n\n情况四\nmatches 为空，mismatches 为空\n直接返回 false\n\n\nisMatch 方法是通过 UrlUtils 的 isMatchGlobPattern 方法进行匹配，因此下面我们再来看看 isMatchGlobPattern 方法的逻辑。\npublic static boolean isMatchGlobPattern(String pattern, String value, URL param) &#123;\n    if (param != null &amp;&amp; pattern.startsWith(\"$\")) &#123;\n        // 引用服务消费者参数，param 参数为服务消费者 url\n        pattern = param.getRawParameter(pattern.substring(1));\n    &#125;\n    // 调用重载方法继续比较\n    return isMatchGlobPattern(pattern, value);\n&#125;\n\npublic static boolean isMatchGlobPattern(String pattern, String value) &#123;\n    // 对 * 通配符提供支持\n    if (\"*\".equals(pattern))\n        // 匹配规则为通配符 *，直接返回 true 即可\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            &amp;&amp; (value == null || value.length() == 0))\n        // pattern 和 value 均为空，此时可认为两者相等，返回 true\n        return true;\n    if ((pattern == null || pattern.length() == 0)\n            || (value == null || value.length() == 0))\n        // pattern 和 value 其中有一个为空，表明两者不相等，返回 false\n        return false;\n\n    // 定位 * 通配符位置\n    int i = pattern.lastIndexOf('*');\n    if (i == -1) &#123;\n        // 匹配规则中不包含通配符，此时直接比较 value 和 pattern 是否相等即可，并返回比较结果\n        return value.equals(pattern);\n    &#125;\n    // 通配符 \"*\" 在匹配规则尾部，比如 10.0.21.*\n    else if (i == pattern.length() - 1) &#123;\n        // 检测 value 是否以“不含通配符的匹配规则”开头，并返回结果。比如:\n        // pattern = 10.0.21.*，value = 10.0.21.12，此时返回 true\n        return value.startsWith(pattern.substring(0, i));\n    &#125;\n    // 通配符 \"*\" 在匹配规则头部\n    else if (i == 0) &#123;\n        // 检测 value 是否以“不含通配符的匹配规则”结尾，并返回结果\n        return value.endsWith(pattern.substring(i + 1));\n    &#125;\n    // 通配符 \"*\" 在匹配规则中间位置\n    else &#123;\n        // 通过通配符将 pattern 分成两半，得到 prefix 和 suffix\n        String prefix = pattern.substring(0, i);\n        String suffix = pattern.substring(i + 1);\n        // 检测 value 是否以 prefix 开头，且以 suffix 结尾，并返回结果\n        return value.startsWith(prefix) &amp;&amp; value.endsWith(suffix);\n    &#125;\n&#125;\n\n以上就是 isMatchGlobPattern 两个重载方法的全部逻辑，这两个方法分别对普通的匹配过程，以及”引用消费者参数“和通配符匹配等特性提供了支持。这两个方法的逻辑不是很复杂，且代码中也进行了比较详细的注释，因此就不多说了。\n\n3. 总结本篇文章对条件路由的表达式解析和服务路由过程进行了较为细致的分析。总的来说，条件路由的代码还是有一些复杂的，需要静下心来看。在阅读条件路由代码的过程中，要多调试。一般的框架都会有单元测试，Dubbo 也不例外，因此大家可以直接通过 ConditionRouterTest 对条件路由进行调试，无需重头构建测试用例。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/cluster/\n作者： Dubbo 官方\n本文介绍了集群的原理和实现细节\n\n集群1.简介为了避免单点故障，现在的应用通常至少会部署在两台服务器上。对于一些负载比较高的服务，会部署更多的服务器。这样，在同一环境下的服务提供者数量会大于1。对于服务消费者来说，同一环境下出现了多个服务提供者。这时会出现一个问题，服务消费者需要决定选择哪个服务提供者进行调用。另外服务调用失败时的处理措施也是需要考虑的，是重试呢，还是抛出异常，亦或是只打印异常等。为了处理这些问题，Dubbo 定义了集群接口 Cluster 以及 Cluster Invoker。集群 Cluster 用途是将多个服务提供者合并为一个 Cluster Invoker，并将这个 Invoker 暴露给服务消费者。这样一来，服务消费者只需通过这个 Invoker 进行远程调用即可，至于具体调用哪个服务提供者，以及调用失败后如何处理等问题，现在都交给集群模块去处理。集群模块是服务提供者和服务消费者的中间层，为服务消费者屏蔽了服务提供者的情况，这样服务消费者就可以专心处理远程调用相关事宜。比如发请求，接受服务提供者返回的数据等。这就是集群的作用。\nDubbo 提供了多种集群实现，包含但不限于 Failover Cluster、Failfast Cluster 和 Failsafe Cluster 等。每种集群实现类的用途不同，接下来会一一进行分析。\n\n2. 集群容错在对集群相关代码进行分析之前，这里有必要先来介绍一下集群容错的所有组件。包含 Cluster、Cluster Invoker、Directory、Router 和 LoadBalance 等。\n\n集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，集群 Cluster 实现类为服务消费者创建 Cluster Invoker 实例，即上图中的 merge 操作。第二个阶段是在服务消费者进行远程调用时。以 FailoverClusterInvoker 为例，该类型 Cluster Invoker 首先会调用 Directory 的 list 方法列举 Invoker 列表（可将 Invoker 简单理解为服务提供者）。Directory 的用途是保存 Invoker，可简单类比为 List。其实现类 RegistryDirectory 是一个动态服务目录，可感知注册中心配置的变化，它所持有的 Invoker 列表会随着注册中心内容的变化而变化。每次变化后，RegistryDirectory 会动态增删 Invoker，并调用 Router 的 route 方法进行路由，过滤掉不符合路由规则的 Invoker。当 FailoverClusterInvoker 拿到 Directory 返回的 Invoker 列表后，它会通过 LoadBalance 从 Invoker 列表中选择一个 Invoker。最后 FailoverClusterInvoker 会将参数传给 LoadBalance 选择出的 Invoker 实例的 invoke 方法，进行真正的远程调用。\n以上就是集群工作的整个流程，这里并没介绍集群是如何容错的。Dubbo 主要提供了这样几种容错方式：\n\nFailover Cluster - 失败自动切换\nFailfast Cluster - 快速失败\nFailsafe Cluster - 失败安全\nFailback Cluster - 失败自动恢复\nForking Cluster - 并行调用多个服务提供者\n\n下面开始分析源码。\n\n3.源码分析\n3.1 Cluster 实现类分析我们在上一章看到了两个概念，分别是集群接口 Cluster 和 Cluster Invoker，这两者是不同的。Cluster 是接口，而 Cluster Invoker 是一种 Invoker。服务提供者的选择逻辑，以及远程调用失败后的的处理逻辑均是封装在 Cluster Invoker 中。那么 Cluster 接口和相关实现类有什么用呢？用途比较简单，仅用于生成 Cluster Invoker。下面我们来看一下源码。\npublic class FailoverCluster implements Cluster &#123;\n\n    public final static String NAME = \"failover\";\n\n    @Override\n    public &lt;T> Invoker&lt;T> join(Directory&lt;T> directory) throws RpcException &#123;\n        // 创建并返回 FailoverClusterInvoker 对象\n        return new FailoverClusterInvoker&lt;T>(directory);\n    &#125;\n&#125;\n\n如上，FailoverCluster 总共就包含这几行代码，用于创建 FailoverClusterInvoker 对象，很简单。下面再看一个。\npublic class FailbackCluster implements Cluster &#123;\n\n    public final static String NAME = \"failback\";\n\n    @Override\n    public &lt;T> Invoker&lt;T> join(Directory&lt;T> directory) throws RpcException &#123;\n        // 创建并返回 FailbackClusterInvoker 对象\n        return new FailbackClusterInvoker&lt;T>(directory);\n    &#125;\n\n&#125;\n\n如上，FailbackCluster 的逻辑也是很简单，无需解释了。所以接下来，我们把重点放在各种 Cluster Invoker 上\n\n3.2 Cluster Invoker 分析我们首先从各种 Cluster Invoker 的父类 AbstractClusterInvoker 源码开始说起。前面说过，集群工作过程可分为两个阶段，第一个阶段是在服务消费者初始化期间，这个在服务引用那篇文章中分析过，就不赘述。第二个阶段是在服务消费者进行远程调用时，此时 AbstractClusterInvoker 的 invoke 方法会被调用。列举 Invoker，负载均衡等操作均会在此阶段被执行。因此下面先来看一下 invoke 方法的逻辑。\npublic Result invoke(final Invocation invocation) throws RpcException &#123;\n    checkWhetherDestroyed();\n    LoadBalance loadbalance = null;\n\n    // 绑定 attachments 到 invocation 中.\n    Map&lt;String, String> contextAttachments = RpcContext.getContext().getAttachments();\n    if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123;\n        ((RpcInvocation) invocation).addAttachments(contextAttachments);\n    &#125;\n\n    // 列举 Invoker\n    List&lt;Invoker&lt;T>> invokers = list(invocation);\n    if (invokers != null &amp;&amp; !invokers.isEmpty()) &#123;\n        // 加载 LoadBalance\n        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(invokers.get(0).getUrl()\n                .getMethodParameter(RpcUtils.getMethodName(invocation), Constants.LOADBALANCE_KEY, Constants.DEFAULT_LOADBALANCE));\n    &#125;\n    RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n    \n    // 调用 doInvoke 进行后续操作\n    return doInvoke(invocation, invokers, loadbalance);\n&#125;\n\n// 抽象方法，由子类实现\nprotected abstract Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T>> invokers,\n                                       LoadBalance loadbalance) throws RpcException;\n\nAbstractClusterInvoker 的 invoke 方法主要用于列举 Invoker，以及加载 LoadBalance。最后再调用模板方法 doInvoke 进行后续操作。下面我们来看一下 Invoker 列举方法 list(Invocation) 的逻辑，如下：\nprotected List&lt;Invoker&lt;T>> list(Invocation invocation) throws RpcException &#123;\n    // 调用 Directory 的 list 方法列举 Invoker\n    List&lt;Invoker&lt;T>> invokers = directory.list(invocation);\n    return invokers;\n&#125;\n\n如上，AbstractClusterInvoker 中的 list 方法做的事情很简单，只是简单的调用了 Directory 的 list 方法，没有其他更多的逻辑了。Directory 即相关实现类在前文已经分析过，这里就不多说了。接下来，我们把目光转移到 AbstractClusterInvoker 的各种实现类上，来看一下这些实现类是如何实现 doInvoke 方法逻辑的。\n\n3.2.1 FailoverClusterInvokerFailoverClusterInvoker 在调用失败时，会自动切换 Invoker 进行重试。默认配置下，Dubbo 会使用这个类作为缺省 Cluster Invoker。下面来看一下该类的逻辑。\npublic class FailoverClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n\n    // 省略部分代码\n\n    @Override\n    public Result doInvoke(Invocation invocation, final List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        List&lt;Invoker&lt;T>> copyinvokers = invokers;\n        checkInvokers(copyinvokers, invocation);\n        // 获取重试次数\n        int len = getUrl().getMethodParameter(invocation.getMethodName(), Constants.RETRIES_KEY, Constants.DEFAULT_RETRIES) + 1;\n        if (len &lt;= 0) &#123;\n            len = 1;\n        &#125;\n        RpcException le = null;\n        List&lt;Invoker&lt;T>> invoked = new ArrayList&lt;Invoker&lt;T>>(copyinvokers.size());\n        Set&lt;String> providers = new HashSet&lt;String>(len);\n        // 循环调用，失败重试\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (i > 0) &#123;\n                checkWhetherDestroyed();\n                // 在进行重试前重新列举 Invoker，这样做的好处是，如果某个服务挂了，\n                // 通过调用 list 可得到最新可用的 Invoker 列表\n                copyinvokers = list(invocation);\n                // 对 copyinvokers 进行判空检查\n                checkInvokers(copyinvokers, invocation);\n            &#125;\n\n            // 通过负载均衡选择 Invoker\n            Invoker&lt;T> invoker = select(loadbalance, invocation, copyinvokers, invoked);\n            // 添加到 invoker 到 invoked 列表中\n            invoked.add(invoker);\n            // 设置 invoked 到 RPC 上下文中\n            RpcContext.getContext().setInvokers((List) invoked);\n            try &#123;\n                // 调用目标 Invoker 的 invoke 方法\n                Result result = invoker.invoke(invocation);\n                return result;\n            &#125; catch (RpcException e) &#123;\n                if (e.isBiz()) &#123;\n                    throw e;\n                &#125;\n                le = e;\n            &#125; catch (Throwable e) &#123;\n                le = new RpcException(e.getMessage(), e);\n            &#125; finally &#123;\n                providers.add(invoker.getUrl().getAddress());\n            &#125;\n        &#125;\n        \n        // 若重试失败，则抛出异常\n        throw new RpcException(..., \"Failed to invoke the method ...\");\n    &#125;\n&#125;\n\n如上，FailoverClusterInvoker 的 doInvoke 方法首先是获取重试次数，然后根据重试次数进行循环调用，失败后进行重试。在 for 循环内，首先是通过负载均衡组件选择一个 Invoker，然后再通过这个 Invoker 的 invoke 方法进行远程调用。如果失败了，记录下异常，并进行重试。重试时会再次调用父类的 list 方法列举 Invoker。整个流程大致如此，不是很难理解。下面我们看一下 select 方法的逻辑。\nprotected Invoker&lt;T> select(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T>> invokers, List&lt;Invoker&lt;T>> selected) throws RpcException &#123;\n    if (invokers == null || invokers.isEmpty())\n        return null;\n    // 获取调用方法名\n    String methodName = invocation == null ? \"\" : invocation.getMethodName();\n\n    // 获取 sticky 配置，sticky 表示粘滞连接。所谓粘滞连接是指让服务消费者尽可能的\n    // 调用同一个服务提供者，除非该提供者挂了再进行切换\n    boolean sticky = invokers.get(0).getUrl().getMethodParameter(methodName, Constants.CLUSTER_STICKY_KEY, Constants.DEFAULT_CLUSTER_STICKY);\n    &#123;\n        // 检测 invokers 列表是否包含 stickyInvoker，如果不包含，\n        // 说明 stickyInvoker 代表的服务提供者挂了，此时需要将其置空\n        if (stickyInvoker != null &amp;&amp; !invokers.contains(stickyInvoker)) &#123;\n            stickyInvoker = null;\n        &#125;\n        \n        // 在 sticky 为 true，且 stickyInvoker != null 的情况下。如果 selected 包含 \n        // stickyInvoker，表明 stickyInvoker 对应的服务提供者可能因网络原因未能成功提供服务。\n        // 但是该提供者并没挂，此时 invokers 列表中仍存在该服务提供者对应的 Invoker。\n        if (sticky &amp;&amp; stickyInvoker != null &amp;&amp; (selected == null || !selected.contains(stickyInvoker))) &#123;\n            // availablecheck 表示是否开启了可用性检查，如果开启了，则调用 stickyInvoker 的 \n            // isAvailable 方法进行检查，如果检查通过，则直接返回 stickyInvoker。\n            if (availablecheck &amp;&amp; stickyInvoker.isAvailable()) &#123;\n                return stickyInvoker;\n            &#125;\n        &#125;\n    &#125;\n    \n    // 如果线程走到当前代码处，说明前面的 stickyInvoker 为空，或者不可用。\n    // 此时继续调用 doSelect 选择 Invoker\n    Invoker&lt;T> invoker = doSelect(loadbalance, invocation, invokers, selected);\n\n    // 如果 sticky 为 true，则将负载均衡组件选出的 Invoker 赋值给 stickyInvoker\n    if (sticky) &#123;\n        stickyInvoker = invoker;\n    &#125;\n    return invoker;\n&#125;\n\n如上，select 方法的主要逻辑集中在了对粘滞连接特性的支持上。首先是获取 sticky 配置，然后再检测 invokers 列表中是否包含 stickyInvoker，如果不包含，则认为该 stickyInvoker 不可用，此时将其置空。这里的 invokers 列表可以看做是存活着的服务提供者列表，如果这个列表不包含 stickyInvoker，那自然而然的认为 stickyInvoker 挂了，所以置空。如果 stickyInvoker 存在于 invokers 列表中，此时要进行下一项检测 — 检测 selected 中是否包含 stickyInvoker。如果包含的话，说明 stickyInvoker 在此之前没有成功提供服务（但其仍然处于存活状态）。此时我们认为这个服务不可靠，不应该在重试期间内再次被调用，因此这个时候不会返回该 stickyInvoker。如果 selected 不包含 stickyInvoker，此时还需要进行可用性检测，比如检测服务提供者网络连通性等。当可用性检测通过，才可返回 stickyInvoker，否则调用 doSelect 方法选择 Invoker。如果 sticky 为 true，此时会将 doSelect 方法选出的 Invoker 赋值给 stickyInvoker。\n以上就是 select 方法的逻辑，这段逻辑看起来不是很复杂，但是信息量比较大。不搞懂 invokers 和 selected 两个入参的含义，以及粘滞连接特性，这段代码是不容易看懂的。所以大家在阅读这段代码时，不要忽略了对背景知识的理解。关于 select 方法先分析这么多，继续向下分析。\nprivate Invoker&lt;T> doSelect(LoadBalance loadbalance, Invocation invocation, List&lt;Invoker&lt;T>> invokers, List&lt;Invoker&lt;T>> selected) throws RpcException &#123;\n    if (invokers == null || invokers.isEmpty())\n        return null;\n    if (invokers.size() == 1)\n        return invokers.get(0);\n    if (loadbalance == null) &#123;\n        // 如果 loadbalance 为空，这里通过 SPI 加载 Loadbalance，默认为 RandomLoadBalance\n        loadbalance = ExtensionLoader.getExtensionLoader(LoadBalance.class).getExtension(Constants.DEFAULT_LOADBALANCE);\n    &#125;\n    \n    // 通过负载均衡组件选择 Invoker\n    Invoker&lt;T> invoker = loadbalance.select(invokers, getUrl(), invocation);\n\n\t// 如果 selected 包含负载均衡选择出的 Invoker，或者该 Invoker 无法经过可用性检查，此时进行重选\n    if ((selected != null &amp;&amp; selected.contains(invoker))\n            || (!invoker.isAvailable() &amp;&amp; getUrl() != null &amp;&amp; availablecheck)) &#123;\n        try &#123;\n            // 进行重选\n            Invoker&lt;T> rinvoker = reselect(loadbalance, invocation, invokers, selected, availablecheck);\n            if (rinvoker != null) &#123;\n                // 如果 rinvoker 不为空，则将其赋值给 invoker\n                invoker = rinvoker;\n            &#125; else &#123;\n                // rinvoker 为空，定位 invoker 在 invokers 中的位置\n                int index = invokers.indexOf(invoker);\n                try &#123;\n                    // 获取 index + 1 位置处的 Invoker，以下代码等价于：\n                    //     invoker = invokers.get((index + 1) % invokers.size());\n                    invoker = index &lt; invokers.size() - 1 ? invokers.get(index + 1) : invokers.get(0);\n                &#125; catch (Exception e) &#123;\n                    logger.warn(\"... may because invokers list dynamic change, ignore.\");\n                &#125;\n            &#125;\n        &#125; catch (Throwable t) &#123;\n            logger.error(\"cluster reselect fail reason is : ...\");\n        &#125;\n    &#125;\n    return invoker;\n&#125;\n\ndoSelect 主要做了两件事，第一是通过负载均衡组件选择 Invoker。第二是，如果选出来的 Invoker 不稳定，或不可用，此时需要调用 reselect 方法进行重选。若 reselect 选出来的 Invoker 为空，此时定位 invoker 在 invokers 列表中的位置 index，然后获取 index + 1 处的 invoker，这也可以看做是重选逻辑的一部分。下面我们来看一下 reselect 方法的逻辑。\nprivate Invoker&lt;T> reselect(LoadBalance loadbalance, Invocation invocation,\n    List&lt;Invoker&lt;T>> invokers, List&lt;Invoker&lt;T>> selected, boolean availablecheck) throws RpcException &#123;\n\n    List&lt;Invoker&lt;T>> reselectInvokers = new ArrayList&lt;Invoker&lt;T>>(invokers.size() > 1 ? (invokers.size() - 1) : invokers.size());\n\n    // 下面的 if-else 分支逻辑有些冗余，pull request #2826 对这段代码进行了简化，可以参考一下\n    // 根据 availablecheck 进行不同的处理\n    if (availablecheck) &#123;\n        // 遍历 invokers 列表\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            // 检测可用性\n            if (invoker.isAvailable()) &#123;\n                // 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中\n                if (selected == null || !selected.contains(invoker)) &#123;\n                    reselectInvokers.add(invoker);\n                &#125;\n            &#125;\n        &#125;\n        \n        // reselectInvokers 不为空，此时通过负载均衡组件进行选择\n        if (!reselectInvokers.isEmpty()) &#123;\n            return loadbalance.select(reselectInvokers, getUrl(), invocation);\n        &#125;\n\n    // 不检查 Invoker 可用性\n    &#125; else &#123;\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            // 如果 selected 列表不包含当前 invoker，则将其添加到 reselectInvokers 中\n            if (selected == null || !selected.contains(invoker)) &#123;\n                reselectInvokers.add(invoker);\n            &#125;\n        &#125;\n        if (!reselectInvokers.isEmpty()) &#123;\n            // 通过负载均衡组件进行选择\n            return loadbalance.select(reselectInvokers, getUrl(), invocation);\n        &#125;\n    &#125;\n\n    &#123;\n        // 若线程走到此处，说明 reselectInvokers 集合为空，此时不会调用负载均衡组件进行筛选。\n        // 这里从 selected 列表中查找可用的 Invoker，并将其添加到 reselectInvokers 集合中\n        if (selected != null) &#123;\n            for (Invoker&lt;T> invoker : selected) &#123;\n                if ((invoker.isAvailable())\n                        &amp;&amp; !reselectInvokers.contains(invoker)) &#123;\n                    reselectInvokers.add(invoker);\n                &#125;\n            &#125;\n        &#125;\n        if (!reselectInvokers.isEmpty()) &#123;\n            // 再次进行选择，并返回选择结果\n            return loadbalance.select(reselectInvokers, getUrl(), invocation);\n        &#125;\n    &#125;\n    return null;\n&#125;\n\nreselect 方法总结下来其实只做了两件事情，第一是查找可用的 Invoker，并将其添加到 reselectInvokers 集合中。第二，如果 reselectInvokers 不为空，则通过负载均衡组件再次进行选择。其中第一件事情又可进行细分，一开始，reselect 从 invokers 列表中查找有效可用的 Invoker，若未能找到，此时再到 selected 列表中继续查找。关于 reselect 方法就先分析到这，继续分析其他的 Cluster Invoker。\n\n3.2.2 FailbackClusterInvokerFailbackClusterInvoker 会在调用失败后，返回一个空结果给服务消费者。并通过定时任务对失败的调用进行重传，适合执行消息通知等操作。下面来看一下它的实现逻辑。\npublic class FailbackClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n\n    private static final long RETRY_FAILED_PERIOD = 5 * 1000;\n\n    private final ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(2,\n            new NamedInternalThreadFactory(\"failback-cluster-timer\", true));\n\n    private final ConcurrentMap&lt;Invocation, AbstractClusterInvoker&lt;?>> failed = new ConcurrentHashMap&lt;Invocation, AbstractClusterInvoker&lt;?>>();\n    private volatile ScheduledFuture&lt;?> retryFuture;\n\n    @Override\n    protected Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        try &#123;\n            checkInvokers(invokers, invocation);\n            // 选择 Invoker\n            Invoker&lt;T> invoker = select(loadbalance, invocation, invokers, null);\n            // 进行调用\n            return invoker.invoke(invocation);\n        &#125; catch (Throwable e) &#123;\n            // 如果调用过程中发生异常，此时仅打印错误日志，不抛出异常\n            logger.error(\"Failback to invoke method ...\");\n            \n            // 记录调用信息\n            addFailed(invocation, this);\n            // 返回一个空结果给服务消费者\n            return new RpcResult();\n        &#125;\n    &#125;\n\n    private void addFailed(Invocation invocation, AbstractClusterInvoker&lt;?> router) &#123;\n        if (retryFuture == null) &#123;\n            synchronized (this) &#123;\n                if (retryFuture == null) &#123;\n                    // 创建定时任务，每隔5秒执行一次\n                    retryFuture = scheduledExecutorService.scheduleWithFixedDelay(new Runnable() &#123;\n\n                        @Override\n                        public void run() &#123;\n                            try &#123;\n                                // 对失败的调用进行重试\n                                retryFailed();\n                            &#125; catch (Throwable t) &#123;\n                                // 如果发生异常，仅打印异常日志，不抛出\n                                logger.error(\"Unexpected error occur at collect statistic\", t);\n                            &#125;\n                        &#125;\n                    &#125;, RETRY_FAILED_PERIOD, RETRY_FAILED_PERIOD, TimeUnit.MILLISECONDS);\n                &#125;\n            &#125;\n        &#125;\n        \n        // 添加 invocation 和 invoker 到 failed 中\n        failed.put(invocation, router);\n    &#125;\n\n    void retryFailed() &#123;\n        if (failed.size() == 0) &#123;\n            return;\n        &#125;\n        \n        // 遍历 failed，对失败的调用进行重试\n        for (Map.Entry&lt;Invocation, AbstractClusterInvoker&lt;?>> entry : new HashMap&lt;Invocation, AbstractClusterInvoker&lt;?>>(failed).entrySet()) &#123;\n            Invocation invocation = entry.getKey();\n            Invoker&lt;?> invoker = entry.getValue();\n            try &#123;\n                // 再次进行调用\n                invoker.invoke(invocation);\n                // 调用成功后，从 failed 中移除 invoker\n                failed.remove(invocation);\n            &#125; catch (Throwable e) &#123;\n                // 仅打印异常，不抛出\n                logger.error(\"Failed retry to invoke method ...\");\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n这个类主要由3个方法组成，首先是 doInvoker，该方法负责初次的远程调用。若远程调用失败，则通过 addFailed 方法将调用信息存入到 failed 中，等待定时重试。addFailed 在开始阶段会根据 retryFuture 为空与否，来决定是否开启定时任务。retryFailed 方法则是包含了失败重试的逻辑，该方法会对 failed 进行遍历，然后依次对 Invoker 进行调用。调用成功则将 Invoker 从 failed 中移除，调用失败则忽略失败原因。\n以上就是 FailbackClusterInvoker 的执行逻辑，不是很复杂，继续往下看。\n\n3.2.3 FailfastClusterInvokerFailfastClusterInvoker 只会发起一次调用，失败后立即抛出异常。通常用于非幂等性的写操作，比如新增记录。源码如下：\npublic class FailfastClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n\n    @Override\n    public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        checkInvokers(invokers, invocation);\n        // 选择 Invoker\n        Invoker&lt;T> invoker = select(loadbalance, invocation, invokers, null);\n        try &#123;\n            // 调用 Invoker\n            return invoker.invoke(invocation);\n        &#125; catch (Throwable e) &#123;\n            if (e instanceof RpcException &amp;&amp; ((RpcException) e).isBiz()) &#123;\n                // 抛出异常\n                throw (RpcException) e;\n            &#125;\n            // 抛出异常\n            throw new RpcException(..., \"Failfast invoke providers ...\");\n        &#125;\n    &#125;\n&#125;\n\n如上，首先是通过 select 方法选择 Invoker，然后进行远程调用。如果调用失败，则立即抛出异常。FailfastClusterInvoker 就先分析到这，下面分析 FailsafeClusterInvoker。\n\n3.2.4 FailsafeClusterInvokerFailsafeClusterInvoker 是一种失败安全的 Cluster Invoker。所谓的失败安全是指，当调用过程中出现异常时，FailsafeClusterInvoker 仅会打印异常，而不会抛出异常。适用于写入审计日志等操作。下面分析源码。\npublic class FailsafeClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n\n    @Override\n    public Result doInvoke(Invocation invocation, List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        try &#123;\n            checkInvokers(invokers, invocation);\n            // 选择 Invoker\n            Invoker&lt;T> invoker = select(loadbalance, invocation, invokers, null);\n            // 进行远程调用\n            return invoker.invoke(invocation);\n        &#125; catch (Throwable e) &#123;\n\t\t\t// 打印错误日志，但不抛出\n            logger.error(\"Failsafe ignore exception: \" + e.getMessage(), e);\n            // 返回空结果忽略错误\n            return new RpcResult();\n        &#125;\n    &#125;\n&#125;\n\nFailsafeClusterInvoker 的逻辑和 FailfastClusterInvoker 的逻辑一样简单，无需过多说明。继续向下分析。\n\n3.2.5 ForkingClusterInvokerForkingClusterInvoker 会在运行时通过线程池创建多个线程，并发调用多个服务提供者。只要有一个服务提供者成功返回了结果，doInvoke 方法就会立即结束运行。ForkingClusterInvoker 的应用场景是在一些对实时性要求比较高读操作（注意是读操作，并行写操作可能不安全）下使用，但这将会耗费更多的资源。下面来看该类的实现。\npublic class ForkingClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n    \n    private final ExecutorService executor = Executors.newCachedThreadPool(\n            new NamedInternalThreadFactory(\"forking-cluster-timer\", true));\n\n    @Override\n    public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        try &#123;\n            checkInvokers(invokers, invocation);\n            final List&lt;Invoker&lt;T>> selected;\n            // 获取 forks 配置\n            final int forks = getUrl().getParameter(Constants.FORKS_KEY, Constants.DEFAULT_FORKS);\n            // 获取超时配置\n            final int timeout = getUrl().getParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            // 如果 forks 配置不合理，则直接将 invokers 赋值给 selected\n            if (forks &lt;= 0 || forks >= invokers.size()) &#123;\n                selected = invokers;\n            &#125; else &#123;\n                selected = new ArrayList&lt;Invoker&lt;T>>();\n                // 循环选出 forks 个 Invoker，并添加到 selected 中\n                for (int i = 0; i &lt; forks; i++) &#123;\n                    // 选择 Invoker\n                    Invoker&lt;T> invoker = select(loadbalance, invocation, invokers, selected);\n                    if (!selected.contains(invoker)) &#123;\n                        selected.add(invoker);\n                    &#125;\n                &#125;\n            &#125;\n            \n            // ----------------------✨ 分割线1 ✨---------------------- //\n            \n            RpcContext.getContext().setInvokers((List) selected);\n            final AtomicInteger count = new AtomicInteger();\n            final BlockingQueue&lt;Object> ref = new LinkedBlockingQueue&lt;Object>();\n            // 遍历 selected 列表\n            for (final Invoker&lt;T> invoker : selected) &#123;\n                // 为每个 Invoker 创建一个执行线程\n                executor.execute(new Runnable() &#123;\n                    @Override\n                    public void run() &#123;\n                        try &#123;\n                            // 进行远程调用\n                            Result result = invoker.invoke(invocation);\n                            // 将结果存到阻塞队列中\n                            ref.offer(result);\n                        &#125; catch (Throwable e) &#123;\n                            int value = count.incrementAndGet();\n                            // 仅在 value 大于等于 selected.size() 时，才将异常对象\n                            // 放入阻塞队列中，请大家思考一下为什么要这样做。\n                            if (value >= selected.size()) &#123;\n                                // 将异常对象存入到阻塞队列中\n                                ref.offer(e);\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125;);\n            &#125;\n            \n            // ----------------------✨ 分割线2 ✨---------------------- //\n            \n            try &#123;\n                // 从阻塞队列中取出远程调用结果\n                Object ret = ref.poll(timeout, TimeUnit.MILLISECONDS);\n                \n                // 如果结果类型为 Throwable，则抛出异常\n                if (ret instanceof Throwable) &#123;\n                    Throwable e = (Throwable) ret;\n                    throw new RpcException(..., \"Failed to forking invoke provider ...\");\n                &#125;\n                \n                // 返回结果\n                return (Result) ret;\n            &#125; catch (InterruptedException e) &#123;\n                throw new RpcException(\"Failed to forking invoke provider ...\");\n            &#125;\n        &#125; finally &#123;\n            RpcContext.getContext().clearAttachments();\n        &#125;\n    &#125;\n&#125;\n\nForkingClusterInvoker 的 doInvoker 方法比较长，这里通过两个分割线将整个方法划分为三个逻辑块。从方法开始到分割线1之间的代码主要是用于选出 forks 个 Invoker，为接下来的并发调用提供输入。分割线1和分割线2之间的逻辑通过线程池并发调用多个 Invoker，并将结果存储在阻塞队列中。分割线2到方法结尾之间的逻辑主要用于从阻塞队列中获取返回结果，并对返回结果类型进行判断。如果为异常类型，则直接抛出，否则返回。\n以上就是ForkingClusterInvoker 的 doInvoker 方法大致过程。我们在分割线1和分割线2之间的代码上留了一个问题，问题是这样的：为什么要在value &gt;= selected.size()的情况下，才将异常对象添加到阻塞队列中？这里来解答一下。原因是这样的，在并行调用多个服务提供者的情况下，只要有一个服务提供者能够成功返回结果，而其他全部失败。此时 ForkingClusterInvoker 仍应该返回成功的结果，而非抛出异常。在value &gt;= selected.size()时将异常对象放入阻塞队列中，可以保证异常对象不会出现在正常结果的前面，这样可从阻塞队列中优先取出正常的结果。\n关于 ForkingClusterInvoker 就先分析到这，接下来分析最后一个 Cluster Invoker。\n\n3.2.6 BroadcastClusterInvoker本章的最后，我们再来看一下 BroadcastClusterInvoker。BroadcastClusterInvoker 会逐个调用每个服务提供者，如果其中一台报错，在循环调用结束后，BroadcastClusterInvoker 会抛出异常。该类通常用于通知所有提供者更新缓存或日志等本地资源信息。源码如下。\npublic class BroadcastClusterInvoker&lt;T> extends AbstractClusterInvoker&lt;T> &#123;\n\n    @Override\n    public Result doInvoke(final Invocation invocation, List&lt;Invoker&lt;T>> invokers, LoadBalance loadbalance) throws RpcException &#123;\n        checkInvokers(invokers, invocation);\n        RpcContext.getContext().setInvokers((List) invokers);\n        RpcException exception = null;\n        Result result = null;\n        // 遍历 Invoker 列表，逐个调用\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            try &#123;\n                // 进行远程调用\n                result = invoker.invoke(invocation);\n            &#125; catch (RpcException e) &#123;\n                exception = e;\n                logger.warn(e.getMessage(), e);\n            &#125; catch (Throwable e) &#123;\n                exception = new RpcException(e.getMessage(), e);\n                logger.warn(e.getMessage(), e);\n            &#125;\n        &#125;\n        \n        // exception 不为空，则抛出异常\n        if (exception != null) &#123;\n            throw exception;\n        &#125;\n        return result;\n    &#125;\n&#125;\n\n以上就是 BroadcastClusterInvoker 的代码，比较简单，就不多说了。\n\n4.总结本篇文章详细分析了集群容错的几种实现方式。集群容错对于 Dubbo 框架来说，是很重要的逻辑。集群模块处于服务提供者和消费者之间，对于服务消费者来说，集群可向其屏蔽服务提供者集群的情况，使其能够专心进行远程调用。除此之外，通过集群模块，我们还可以对服务之间的调用链路进行编排优化，治理服务。总的来说，对于 Dubbo 而言，集群容错相关逻辑是非常重要的。想要对 Dubbo 有比较深的理解，集群容错是必须要掌握的。\n关于集群模块就先分析到这，感谢阅读。\n本文介绍了负载均衡的原理和实现细节\n\n负载均衡1.简介LoadBalance 中文意思为负载均衡，它的职责是将网络请求，或者其他形式的负载“均摊”到不同的机器上。避免集群中部分服务器压力过大，而另一些服务器比较空闲的情况。通过负载均衡，可以让每台服务器获取到适合自己处理能力的负载。在为高负载服务器分流的同时，还可以避免资源浪费，一举两得。负载均衡可分为软件负载均衡和硬件负载均衡。在我们日常开发中，一般很难接触到硬件负载均衡。但软件负载均衡还是可以接触到的，比如 Nginx。在 Dubbo 中，也有负载均衡的概念和相应的实现。Dubbo 需要对服务消费者的调用请求进行分配，避免少数服务提供者负载过大。服务提供者负载过大，会导致部分请求超时。因此将负载均衡到每个服务提供者上，是非常必要的。Dubbo 提供了4种负载均衡实现，分别是基于权重随机算法的 RandomLoadBalance、基于最少活跃调用数算法的 LeastActiveLoadBalance、基于 hash 一致性的 ConsistentHashLoadBalance，以及基于加权轮询算法的 RoundRobinLoadBalance。这几个负载均衡算法代码不是很长，但是想看懂也不是很容易，需要大家对这几个算法的原理有一定了解才行。如果不是很了解，也没不用太担心。我们会在分析每个算法的源码之前，对算法原理进行简单的讲解，帮助大家建立初步的印象。\n本系列文章在编写之初是基于 Dubbo 2.6.4 的，近期，Dubbo 2.6.5 发布了，其中就有针对对负载均衡部分的优化。因此我们在分析完 2.6.4 版本后的源码后，会另外分析 2.6.5 更新的部分。其他的就不多说了，进入正题吧。\n\n2.源码分析在 Dubbo 中，所有负载均衡实现类均继承自 AbstractLoadBalance，该类实现了 LoadBalance 接口，并封装了一些公共的逻辑。所以在分析负载均衡实现之前，先来看一下 AbstractLoadBalance 的逻辑。首先来看一下负载均衡的入口方法 select，如下：\n@Override\npublic &lt;T> Invoker&lt;T> select(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n    if (invokers == null || invokers.isEmpty())\n        return null;\n    // 如果 invokers 列表中仅有一个 Invoker，直接返回即可，无需进行负载均衡\n    if (invokers.size() == 1)\n        return invokers.get(0);\n    \n    // 调用 doSelect 方法进行负载均衡，该方法为抽象方法，由子类实现\n    return doSelect(invokers, url, invocation);\n&#125;\n\nprotected abstract &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation);\n\nselect 方法的逻辑比较简单，首先会检测 invokers 集合的合法性，然后再检测 invokers 集合元素数量。如果只包含一个 Invoker，直接返回该 Inovker 即可。如果包含多个 Invoker，此时需要通过负载均衡算法选择一个 Invoker。具体的负载均衡算法由子类实现，接下来章节会对这些子类一一进行详细分析。\nAbstractLoadBalance 除了实现了 LoadBalance 接口方法，还封装了一些公共逻辑，比如服务提供者权重计算逻辑。具体实现如下：\nprotected int getWeight(Invoker&lt;?> invoker, Invocation invocation) &#123;\n    // 从 url 中获取权重 weight 配置值\n    int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n    if (weight > 0) &#123;\n        // 获取服务提供者启动时间戳\n        long timestamp = invoker.getUrl().getParameter(Constants.REMOTE_TIMESTAMP_KEY, 0L);\n        if (timestamp > 0L) &#123;\n            // 计算服务提供者运行时长\n            int uptime = (int) (System.currentTimeMillis() - timestamp);\n            // 获取服务预热时间，默认为10分钟\n            int warmup = invoker.getUrl().getParameter(Constants.WARMUP_KEY, Constants.DEFAULT_WARMUP);\n            // 如果服务运行时间小于预热时间，则重新计算服务权重，即降权\n            if (uptime > 0 &amp;&amp; uptime &lt; warmup) &#123;\n                // 重新计算服务权重\n                weight = calculateWarmupWeight(uptime, warmup, weight);\n            &#125;\n        &#125;\n    &#125;\n    return weight;\n&#125;\n\nstatic int calculateWarmupWeight(int uptime, int warmup, int weight) &#123;\n    // 计算权重，下面代码逻辑上形似于 (uptime / warmup) * weight。\n    // 随着服务运行时间 uptime 增大，权重计算值 ww 会慢慢接近配置值 weight\n    int ww = (int) ((float) uptime / ((float) warmup / (float) weight));\n    return ww &lt; 1 ? 1 : (ww > weight ? weight : ww);\n&#125;\n\n上面是权重的计算过程，该过程主要用于保证当服务运行时长小于服务预热时间时，对服务进行降权，避免让服务在启动之初就处于高负载状态。服务预热是一个优化手段，与此类似的还有 JVM 预热。主要目的是让服务启动后“低功率”运行一段时间，使其效率慢慢提升至最佳状态。\n关于 AbstractLoadBalance 就先分析到这，接下来分析各个实现类的代码。首先，我们从 Dubbo 缺省的实现类 RandomLoadBalance 看起。\n\n2.1 RandomLoadBalanceRandomLoadBalance 是加权随机算法的具体实现，它的算法思想很简单。假设我们有一组服务器 servers &#x3D; [A, B, C]，他们对应的权重为 weights &#x3D; [5, 3, 2]，权重总和为10。现在把这些权重值平铺在一维坐标值上，[0, 5) 区间属于服务器 A，[5, 8) 区间属于服务器 B，[8, 10) 区间属于服务器 C。接下来通过随机数生成器生成一个范围在 [0, 10) 之间的随机数，然后计算这个随机数会落到哪个区间上。比如数字3会落到服务器 A 对应的区间上，此时返回服务器 A 即可。权重越大的机器，在坐标轴上对应的区间范围就越大，因此随机数生成器生成的数字就会有更大的概率落到此区间内。只要随机数生成器产生的随机数分布性很好，在经过多次选择后，每个服务器被选中的次数比例接近其权重比例。比如，经过一万次选择后，服务器 A 被选中的次数大约为5000次，服务器 B 被选中的次数约为3000次，服务器 C 被选中的次数约为2000次。\n以上就是 RandomLoadBalance 背后的算法思想，比较简单。下面开始分析源码。\npublic class RandomLoadBalance extends AbstractLoadBalance &#123;\n\n    public static final String NAME = \"random\";\n\n    private final Random random = new Random();\n\n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        int length = invokers.size();\n        int totalWeight = 0;\n        boolean sameWeight = true;\n        // 下面这个循环有两个作用，第一是计算总权重 totalWeight，\n        // 第二是检测每个服务提供者的权重是否相同\n        for (int i = 0; i &lt; length; i++) &#123;\n            int weight = getWeight(invokers.get(i), invocation);\n            // 累加权重\n            totalWeight += weight;\n            // 检测当前服务提供者的权重与上一个服务提供者的权重是否相同，\n            // 不相同的话，则将 sameWeight 置为 false。\n            if (sameWeight &amp;&amp; i > 0\n                    &amp;&amp; weight != getWeight(invokers.get(i - 1), invocation)) &#123;\n                sameWeight = false;\n            &#125;\n        &#125;\n        \n        // 下面的 if 分支主要用于获取随机数，并计算随机数落在哪个区间上\n        if (totalWeight > 0 &amp;&amp; !sameWeight) &#123;\n            // 随机获取一个 [0, totalWeight) 区间内的数字\n            int offset = random.nextInt(totalWeight);\n            // 循环让 offset 数减去服务提供者权重值，当 offset 小于0时，返回相应的 Invoker。\n            // 举例说明一下，我们有 servers = [A, B, C]，weights = [5, 3, 2]，offset = 7。\n            // 第一次循环，offset - 5 = 2 > 0，即 offset > 5，\n            // 表明其不会落在服务器 A 对应的区间上。\n            // 第二次循环，offset - 3 = -1 &lt; 0，即 5 &lt; offset &lt; 8，\n            // 表明其会落在服务器 B 对应的区间上\n            for (int i = 0; i &lt; length; i++) &#123;\n                // 让随机值 offset 减去权重值\n                offset -= getWeight(invokers.get(i), invocation);\n                if (offset &lt; 0) &#123;\n                    // 返回相应的 Invoker\n                    return invokers.get(i);\n                &#125;\n            &#125;\n        &#125;\n        \n        // 如果所有服务提供者权重值相同，此时直接随机返回一个即可\n        return invokers.get(random.nextInt(length));\n    &#125;\n&#125;\n\nRandomLoadBalance 的算法思想比较简单，在经过多次请求后，能够将调用请求按照权重值进行“均匀”分配。当然 RandomLoadBalance 也存在一定的缺点，当调用次数比较少时，Random 产生的随机数可能会比较集中，此时多数请求会落到同一台服务器上。这个缺点并不是很严重，多数情况下可以忽略。RandomLoadBalance 是一个简单，高效的负载均衡实现，因此 Dubbo 选择它作为缺省实现。\n关于 RandomLoadBalance 就先到这了，接下来分析 LeastActiveLoadBalance。\n\n2.2 LeastActiveLoadBalanceLeastActiveLoadBalance 翻译过来是最小活跃数负载均衡。活跃调用数越小，表明该服务提供者效率越高，单位时间内可处理更多的请求。此时应优先将请求分配给该服务提供者。在具体实现中，每个服务提供者对应一个活跃数 active。初始情况下，所有服务提供者活跃数均为0。每收到一个请求，活跃数加1，完成请求后则将活跃数减1。在服务运行一段时间后，性能好的服务提供者处理请求的速度更快，因此活跃数下降的也越快，此时这样的服务提供者能够优先获取到新的服务请求、这就是最小活跃数负载均衡算法的基本思想。除了最小活跃数，LeastActiveLoadBalance 在实现上还引入了权重值。所以准确的来说，LeastActiveLoadBalance 是基于加权最小活跃数算法实现的。举个例子说明一下，在一个服务提供者集群中，有两个性能优异的服务提供者。某一时刻它们的活跃数相同，此时 Dubbo 会根据它们的权重去分配请求，权重越大，获取到新请求的概率就越大。如果两个服务提供者权重相同，此时随机选择一个即可。关于 LeastActiveLoadBalance 的背景知识就先介绍到这里，下面开始分析源码。\npublic class LeastActiveLoadBalance extends AbstractLoadBalance &#123;\n\n    public static final String NAME = \"leastactive\";\n\n    private final Random random = new Random();\n\n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        int length = invokers.size();\n        // 最小的活跃数\n        int leastActive = -1;\n        // 具有相同“最小活跃数”的服务者提供者（以下用 Invoker 代称）数量\n        int leastCount = 0; \n        // leastIndexs 用于记录具有相同“最小活跃数”的 Invoker 在 invokers 列表中的下标信息\n        int[] leastIndexs = new int[length];\n        int totalWeight = 0;\n        // 第一个最小活跃数的 Invoker 权重值，用于与其他具有相同最小活跃数的 Invoker 的权重进行对比，\n        // 以检测是否“所有具有相同最小活跃数的 Invoker 的权重”均相等\n        int firstWeight = 0;\n        boolean sameWeight = true;\n\n        // 遍历 invokers 列表\n        for (int i = 0; i &lt; length; i++) &#123;\n            Invoker&lt;T> invoker = invokers.get(i);\n            // 获取 Invoker 对应的活跃数\n            int active = RpcStatus.getStatus(invoker.getUrl(), invocation.getMethodName()).getActive();\n            // 获取权重 - ⭐️\n            int weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\n            // 发现更小的活跃数，重新开始\n            if (leastActive == -1 || active &lt; leastActive) &#123;\n            \t// 使用当前活跃数 active 更新最小活跃数 leastActive\n                leastActive = active;\n                // 更新 leastCount 为 1\n                leastCount = 1;\n                // 记录当前下标值到 leastIndexs 中\n                leastIndexs[0] = i;\n                totalWeight = weight;\n                firstWeight = weight;\n                sameWeight = true;\n\n            // 当前 Invoker 的活跃数 active 与最小活跃数 leastActive 相同 \n            &#125; else if (active == leastActive) &#123;\n            \t// 在 leastIndexs 中记录下当前 Invoker 在 invokers 集合中的下标\n                leastIndexs[leastCount++] = i;\n                // 累加权重\n                totalWeight += weight;\n                // 检测当前 Invoker 的权重与 firstWeight 是否相等，\n                // 不相等则将 sameWeight 置为 false\n                if (sameWeight &amp;&amp; i > 0\n                    &amp;&amp; weight != firstWeight) &#123;\n                    sameWeight = false;\n                &#125;\n            &#125;\n        &#125;\n        \n        // 当只有一个 Invoker 具有最小活跃数，此时直接返回该 Invoker 即可\n        if (leastCount == 1) &#123;\n            return invokers.get(leastIndexs[0]);\n        &#125;\n\n        // 有多个 Invoker 具有相同的最小活跃数，但它们之间的权重不同\n        if (!sameWeight &amp;&amp; totalWeight > 0) &#123;\n        \t// 随机生成一个 [0, totalWeight) 之间的数字\n            int offsetWeight = random.nextInt(totalWeight);\n            // 循环让随机数减去具有最小活跃数的 Invoker 的权重值，\n            // 当 offset 小于等于0时，返回相应的 Invoker\n            for (int i = 0; i &lt; leastCount; i++) &#123;\n                int leastIndex = leastIndexs[i];\n                // 获取权重值，并让随机数减去权重值 - ⭐️\n                offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n                if (offsetWeight &lt;= 0)\n                    return invokers.get(leastIndex);\n            &#125;\n        &#125;\n        // 如果权重相同或权重为0时，随机返回一个 Invoker\n        return invokers.get(leastIndexs[random.nextInt(leastCount)]);\n    &#125;\n&#125;\n\n上面代码的逻辑比较多，我们在代码中写了大量的注释，有帮助大家理解代码逻辑。下面简单总结一下以上代码所做的事情，如下：\n\n遍历 invokers 列表，寻找活跃数最小的 Invoker\n如果有多个 Invoker 具有相同的最小活跃数，此时记录下这些 Invoker 在 invokers 集合中的下标，并累加它们的权重，比较它们的权重值是否相等\n如果只有一个 Invoker 具有最小的活跃数，此时直接返回该 Invoker 即可\n如果有多个 Invoker 具有最小活跃数，且它们的权重不相等，此时处理方式和 RandomLoadBalance 一致\n如果有多个 Invoker 具有最小活跃数，但它们的权重相等，此时随机返回一个即可\n\n以上就是 LeastActiveLoadBalance 大致的实现逻辑，大家在阅读的源码的过程中要注意区分活跃数与权重这两个概念，不要混为一谈。\n以上分析是基于 Dubbo 2.6.4 版本进行的，由于近期 Dubbo 2.6.5 发布了，并对 LeastActiveLoadBalance 进行了一些修改，下面简单来介绍一下修改内容。回到上面的源码中，我们在上面的代码中标注了两个黄色的五角星⭐️。两处标记对应的代码分别如下：\nint weight = invoker.getUrl().getMethodParameter(invocation.getMethodName(), Constants.WEIGHT_KEY, Constants.DEFAULT_WEIGHT);\noffsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n\n问题出在服务预热阶段，第一行代码直接从 url 中取权重值，未被降权过。第二行代码获取到的是经过降权后的权重。第一行代码获取到的权重值最终会被累加到权重总和 totalWeight 中，这个时候会导致一个问题。offsetWeight 是一个在 [0, totalWeight) 范围内的随机数，而它所减去的是经过降权的权重。很有可能在经过 leastCount 次运算后，offsetWeight 仍然是大于0的，导致无法选中 Invoker。这个问题对应的 issue 为 #904，并在 pull request #2172 中被修复。具体的修复逻辑是将标注一处的代码修改为：\n// afterWarmup 等价于上面的 weight 变量，这样命名是为了强调该变量经过了 warmup 降权处理\nint afterWarmup = getWeight(invoker, invocation);\n\n另外，2.6.4 版本中的 LeastActiveLoadBalance 还有一个缺陷，即当一组 Invoker 具有相同的最小活跃数，且其中一个 Invoker 的权重值为1，此时这个 Invoker 无法被选中。缺陷代码如下：\nint offsetWeight = random.nextInt(totalWeight);\nfor (int i = 0; i &lt; leastCount; i++) &#123;\n    int leastIndex = leastIndexs[i];\n    offsetWeight -= getWeight(invokers.get(leastIndex), invocation);\n    if (offsetWeight &lt;= 0)    // ❌\n        return invokers.get(leastIndex);\n&#125;\n\n问题出在了offsetWeight &lt;= 0上，举例说明，假设有一组 Invoker 的权重为 5、2、1，offsetWeight 最大值为 7。假设 offsetWeight &#x3D; 7，你会发现，当 for 循环进行第二次遍历后 offsetWeight &#x3D; 7 - 5 - 2 &#x3D; 0，提前返回了。此时，此时权重为1的 Invoker 就没有机会被选中了。该问题在 Dubbo 2.6.5 中被修复了，修改后的代码如下：\nint offsetWeight = random.nextInt(totalWeight) + 1;\n\n以上就是 Dubbo 2.6.5 对 LeastActiveLoadBalance 的更新，内容不是很多，先分析到这。接下来分析基于一致性 hash 思想的 ConsistentHashLoadBalance。\n\n2.3 ConsistentHashLoadBalance一致性 hash 算法由麻省理工学院的 Karger 及其合作者于1997年提出的，算法提出之初是用于大规模缓存系统的负载均衡。它的工作过程是这样的，首先根据 ip 或者其他的信息为缓存节点生成一个 hash，并将这个 hash 投射到 [0, 2^32 - 1] 的圆环上。当有查询或写入请求时，则为缓存项的 key 生成一个 hash 值。然后查找第一个大于或等于该 hash 值的缓存节点，并到这个节点中查询或写入缓存项。如果当前节点挂了，则在下一次查询或写入缓存时，为缓存项查找另一个大于其 hash 值的缓存节点即可。大致效果如下图所示，每个缓存节点在圆环上占据一个位置。如果缓存项的 key 的 hash 值小于缓存节点 hash 值，则到该缓存节点中存储或读取缓存项。比如下面绿色点对应的缓存项将会被存储到 cache-2 节点中。由于 cache-3 挂了，原本应该存到该节点中的缓存项最终会存储到 cache-4 节点中。\n\n下面来看看一致性 hash 在 Dubbo 中的应用。我们把上图的缓存节点替换成 Dubbo 的服务提供者，于是得到了下图：\n\n这里相同颜色的节点均属于同一个服务提供者，比如 Invoker1-1，Invoker1-2，……, Invoker1-160。这样做的目的是通过引入虚拟节点，让 Invoker 在圆环上分散开来，避免数据倾斜问题。所谓数据倾斜是指，由于节点不够分散，导致大量请求落到了同一个节点上，而其他节点只会接收到了少量请求的情况。比如：\n\n如上，由于 Invoker-1 和 Invoker-2 在圆环上分布不均，导致系统中75%的请求都会落到 Invoker-1 上，只有 25% 的请求会落到 Invoker-2 上。解决这个问题办法是引入虚拟节点，通过虚拟节点均衡各个节点的请求量。\n到这里背景知识就普及完了，接下来开始分析源码。我们先从 ConsistentHashLoadBalance 的 doSelect 方法开始看起，如下：\npublic class ConsistentHashLoadBalance extends AbstractLoadBalance &#123;\n\n    private final ConcurrentMap&lt;String, ConsistentHashSelector&lt;?>> selectors = \n        new ConcurrentHashMap&lt;String, ConsistentHashSelector&lt;?>>();\n\n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        String methodName = RpcUtils.getMethodName(invocation);\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + methodName;\n\n        // 获取 invokers 原始的 hashcode\n        int identityHashCode = System.identityHashCode(invokers);\n        ConsistentHashSelector&lt;T> selector = (ConsistentHashSelector&lt;T>) selectors.get(key);\n        // 如果 invokers 是一个新的 List 对象，意味着服务提供者数量发生了变化，可能新增也可能减少了。\n        // 此时 selector.identityHashCode != identityHashCode 条件成立\n        if (selector == null || selector.identityHashCode != identityHashCode) &#123;\n            // 创建新的 ConsistentHashSelector\n            selectors.put(key, new ConsistentHashSelector&lt;T>(invokers, methodName, identityHashCode));\n            selector = (ConsistentHashSelector&lt;T>) selectors.get(key);\n        &#125;\n\n        // 调用 ConsistentHashSelector 的 select 方法选择 Invoker\n        return selector.select(invocation);\n    &#125;\n    \n    private static final class ConsistentHashSelector&lt;T> &#123;...&#125;\n&#125;\n\n如上，doSelect 方法主要做了一些前置工作，比如检测 invokers 列表是不是变动过，以及创建 ConsistentHashSelector。这些工作做完后，接下来开始调用 ConsistentHashSelector 的 select 方法执行负载均衡逻辑。在分析 select 方法之前，我们先来看一下一致性 hash 选择器 ConsistentHashSelector 的初始化过程，如下：\nprivate static final class ConsistentHashSelector&lt;T> &#123;\n\n    // 使用 TreeMap 存储 Invoker 虚拟节点\n    private final TreeMap&lt;Long, Invoker&lt;T>> virtualInvokers;\n\n    private final int replicaNumber;\n\n    private final int identityHashCode;\n\n    private final int[] argumentIndex;\n\n    ConsistentHashSelector(List&lt;Invoker&lt;T>> invokers, String methodName, int identityHashCode) &#123;\n        this.virtualInvokers = new TreeMap&lt;Long, Invoker&lt;T>>();\n        this.identityHashCode = identityHashCode;\n        URL url = invokers.get(0).getUrl();\n        // 获取虚拟节点数，默认为160\n        this.replicaNumber = url.getMethodParameter(methodName, \"hash.nodes\", 160);\n        // 获取参与 hash 计算的参数下标值，默认对第一个参数进行 hash 运算\n        String[] index = Constants.COMMA_SPLIT_PATTERN.split(url.getMethodParameter(methodName, \"hash.arguments\", \"0\"));\n        argumentIndex = new int[index.length];\n        for (int i = 0; i &lt; index.length; i++) &#123;\n            argumentIndex[i] = Integer.parseInt(index[i]);\n        &#125;\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            String address = invoker.getUrl().getAddress();\n            for (int i = 0; i &lt; replicaNumber / 4; i++) &#123;\n                // 对 address + i 进行 md5 运算，得到一个长度为16的字节数组\n                byte[] digest = md5(address + i);\n                // 对 digest 部分字节进行4次 hash 运算，得到四个不同的 long 型正整数\n                for (int h = 0; h &lt; 4; h++) &#123;\n                    // h = 0 时，取 digest 中下标为 0 ~ 3 的4个字节进行位运算\n                    // h = 1 时，取 digest 中下标为 4 ~ 7 的4个字节进行位运算\n                    // h = 2, h = 3 时过程同上\n                    long m = hash(digest, h);\n                    // 将 hash 到 invoker 的映射关系存储到 virtualInvokers 中，\n                    // virtualInvokers 需要提供高效的查询操作，因此选用 TreeMap 作为存储结构\n                    virtualInvokers.put(m, invoker);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nConsistentHashSelector 的构造方法执行了一系列的初始化逻辑，比如从配置中获取虚拟节点数以及参与 hash 计算的参数下标，默认情况下只使用第一个参数进行 hash。需要特别说明的是，ConsistentHashLoadBalance 的负载均衡逻辑只受参数值影响，具有相同参数值的请求将会被分配给同一个服务提供者。ConsistentHashLoadBalance 不 关系权重，因此使用时需要注意一下。\n在获取虚拟节点数和参数下标配置后，接下来要做的事情是计算虚拟节点 hash 值，并将虚拟节点存储到 TreeMap 中。到此，ConsistentHashSelector 初始化工作就完成了。接下来，我们来看看 select 方法的逻辑。\npublic Invoker&lt;T> select(Invocation invocation) &#123;\n    // 将参数转为 key\n    String key = toKey(invocation.getArguments());\n    // 对参数 key 进行 md5 运算\n    byte[] digest = md5(key);\n    // 取 digest 数组的前四个字节进行 hash 运算，再将 hash 值传给 selectForKey 方法，\n    // 寻找合适的 Invoker\n    return selectForKey(hash(digest, 0));\n&#125;\n\nprivate Invoker&lt;T> selectForKey(long hash) &#123;\n    // 到 TreeMap 中查找第一个节点值大于或等于当前 hash 的 Invoker\n    Map.Entry&lt;Long, Invoker&lt;T>> entry = virtualInvokers.tailMap(hash, true).firstEntry();\n    // 如果 hash 大于 Invoker 在圆环上最大的位置，此时 entry = null，\n    // 需要将 TreeMap 的头节点赋值给 entry\n    if (entry == null) &#123;\n        entry = virtualInvokers.firstEntry();\n    &#125;\n\n    // 返回 Invoker\n    return entry.getValue();\n&#125;\n\n如上，选择的过程相对比较简单了。首先是对参数进行 md5 以及 hash 运算，得到一个 hash 值。然后再拿这个值到 TreeMap 中查找目标 Invoker 即可。\n到此关于 ConsistentHashLoadBalance 就分析完了。在阅读 ConsistentHashLoadBalance 源码之前，大家一定要先补充背景知识，不然很难看懂代码逻辑。\n\n2.4 RoundRobinLoadBalance本节，我们来看一下 Dubbo 中加权轮询负载均衡的实现 RoundRobinLoadBalance。在详细分析源码前，我们先来了解一下什么是加权轮询。这里从最简单的轮询开始讲起，所谓轮询是指将请求轮流分配给每台服务器。举个例子，我们有三台服务器 A、B、C。我们将第一个请求分配给服务器 A，第二个请求分配给服务器 B，第三个请求分配给服务器 C，第四个请求再次分配给服务器 A。这个过程就叫做轮询。轮询是一种无状态负载均衡算法，实现简单，适用于每台服务器性能相近的场景下。但现实情况下，我们并不能保证每台服务器性能均相近。如果我们将等量的请求分配给性能较差的服务器，这显然是不合理的。因此，这个时候我们需要对轮询过程进行加权，以调控每台服务器的负载。经过加权后，每台服务器能够得到的请求数比例，接近或等于他们的权重比。比如服务器 A、B、C 权重比为 5:2:1。那么在8次请求中，服务器 A 将收到其中的5次请求，服务器 B 会收到其中的2次请求，服务器 C 则收到其中的1次请求。\n以上就是加权轮询的算法思想，搞懂了这个思想，接下来我们就可以分析源码了。我们先来看一下 2.6.4 版本的 RoundRobinLoadBalance。\npublic class RoundRobinLoadBalance extends AbstractLoadBalance &#123;\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap&lt;String, AtomicPositiveInteger> sequences = \n        new ConcurrentHashMap&lt;String, AtomicPositiveInteger>();\n\n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        // key = 全限定类名 + \".\" + 方法名，比如 com.xxx.DemoService.sayHello\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size();\n        // 最大权重\n        int maxWeight = 0;\n        // 最小权重\n        int minWeight = Integer.MAX_VALUE;\n        final LinkedHashMap&lt;Invoker&lt;T>, IntegerWrapper> invokerToWeightMap = new LinkedHashMap&lt;Invoker&lt;T>, IntegerWrapper>();\n        // 权重总和\n        int weightSum = 0;\n\n        // 下面这个循环主要用于查找最大和最小权重，计算权重总和等\n        for (int i = 0; i &lt; length; i++) &#123;\n            int weight = getWeight(invokers.get(i), invocation);\n            // 获取最大和最小权重\n            maxWeight = Math.max(maxWeight, weight);\n            minWeight = Math.min(minWeight, weight);\n            if (weight > 0) &#123;\n                // 将 weight 封装到 IntegerWrapper 中\n                invokerToWeightMap.put(invokers.get(i), new IntegerWrapper(weight));\n                // 累加权重\n                weightSum += weight;\n            &#125;\n        &#125;\n\n        // 查找 key 对应的对应 AtomicPositiveInteger 实例，为空则创建。\n        // 这里可以把 AtomicPositiveInteger 看成一个黑盒，大家只要知道\n        // AtomicPositiveInteger 用于记录服务的调用编号即可。至于细节，\n        // 大家如果感兴趣，可以自行分析\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) &#123;\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        &#125;\n\n        // 获取当前的调用编号\n        int currentSequence = sequence.getAndIncrement();\n        // 如果最小权重小于最大权重，表明服务提供者之间的权重是不相等的\n        if (maxWeight > 0 &amp;&amp; minWeight &lt; maxWeight) &#123;\n            // 使用调用编号对权重总和进行取余操作\n            int mod = currentSequence % weightSum;\n            // 进行 maxWeight 次遍历\n            for (int i = 0; i &lt; maxWeight; i++) &#123;\n                // 遍历 invokerToWeightMap\n                for (Map.Entry&lt;Invoker&lt;T>, IntegerWrapper> each : invokerToWeightMap.entrySet()) &#123;\n\t\t\t\t\t// 获取 Invoker\n                    final Invoker&lt;T> k = each.getKey();\n                    // 获取权重包装类 IntegerWrapper\n                    final IntegerWrapper v = each.getValue();\n                    \n                    // 如果 mod = 0，且权重大于0，此时返回相应的 Invoker\n                    if (mod == 0 &amp;&amp; v.getValue() > 0) &#123;\n                        return k;\n                    &#125;\n                    \n                    // mod != 0，且权重大于0，此时对权重和 mod 分别进行自减操作\n                    if (v.getValue() > 0) &#123;\n                        v.decrement();\n                        mod--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        \n        // 服务提供者之间的权重相等，此时通过轮询选择 Invoker\n        return invokers.get(currentSequence % length);\n    &#125;\n\n    // IntegerWrapper 是一个 int 包装类，主要包含了一个自减方法。\n    private static final class IntegerWrapper &#123;\n        private int value;\n\n        public void decrement() &#123;\n            this.value--;\n        &#125;\n        \n        // 省略部分代码\n    &#125;\n&#125;\n\n如上，RoundRobinLoadBalance 的每行代码都不是很难理解，但是将它们组合在一起之后，就不是很好理解了。所以下面我们举例进行说明，假设我们有三台服务器 servers &#x3D; [A, B, C]，对应的权重为 weights &#x3D; [2, 5, 1]。接下来对上面的逻辑进行简单的模拟。\nmod &#x3D; 0：满足条件，此时直接返回服务器 A\nmod &#x3D; 1：需要进行一次递减操作才能满足条件，此时返回服务器 B\nmod &#x3D; 2：需要进行两次递减操作才能满足条件，此时返回服务器 C\nmod &#x3D; 3：需要进行三次递减操作才能满足条件，经过递减后，服务器权重为 [1, 4, 0]，此时返回服务器 A\nmod &#x3D; 4：需要进行四次递减操作才能满足条件，经过递减后，服务器权重为 [0, 4, 0]，此时返回服务器 B\nmod &#x3D; 5：需要进行五次递减操作才能满足条件，经过递减后，服务器权重为 [0, 3, 0]，此时返回服务器 B\nmod &#x3D; 6：需要进行六次递减操作才能满足条件，经过递减后，服务器权重为 [0, 2, 0]，此时返回服务器 B\nmod &#x3D; 7：需要进行七次递减操作才能满足条件，经过递减后，服务器权重为 [0, 1, 0]，此时返回服务器 B\n经过8次调用后，我们得到的负载均衡结果为 [A, B, C, A, B, B, B, B]，次数比 A:B:C &#x3D; 2:5:1，等于权重比。当 sequence &#x3D; 8 时，mod &#x3D; 0，此时重头再来。从上面的模拟过程可以看出，当 mod &gt;&#x3D; 3 后，服务器 C 就不会被选中了，因为它的权重被减为0了。当 mod &gt;&#x3D; 4 后，服务器 A 的权重被减为0，此后 A 就不会再被选中。\n以上是 2.6.4 版本的 RoundRobinLoadBalance 分析过程，2.6.4 版本的 RoundRobinLoadBalance 在某些情况下存在着比较严重的性能问题，该问题最初是在 issue #2578 中被反馈出来。问题出在了 Invoker 的返回时机上，RoundRobinLoadBalance 需要在mod == 0 &amp;&amp; v.getValue() &gt; 0 条件成立的情况下才会被返回相应的 Invoker。假如 mod 很大，比如 10000，50000，甚至更大时，doSelect 方法需要进行很多次计算才能将 mod 减为0。由此可知，doSelect 的效率与 mod 有关，时间复杂度为 O(mod)。mod 又受最大权重 maxWeight 的影响，因此当某个服务提供者配置了非常大的权重，此时 RoundRobinLoadBalance 会产生比较严重的性能问题。这个问题被反馈后，社区很快做了回应。并对 RoundRobinLoadBalance 的代码进行了重构，将时间复杂度优化至了常量级别。这个优化可以说很好了，下面我们来学习一下优化后的代码。\npublic class RoundRobinLoadBalance extends AbstractLoadBalance &#123;\n\n    public static final String NAME = \"roundrobin\";\n\n    private final ConcurrentMap&lt;String, AtomicPositiveInteger> sequences = new ConcurrentHashMap&lt;String, AtomicPositiveInteger>();\n\n    private final ConcurrentMap&lt;String, AtomicPositiveInteger> indexSeqs = new ConcurrentHashMap&lt;String, AtomicPositiveInteger>();\n\n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        int length = invokers.size();\n        int maxWeight = 0;\n        int minWeight = Integer.MAX_VALUE;\n        final List&lt;Invoker&lt;T>> invokerToWeightList = new ArrayList&lt;>();\n        \n        // 查找最大和最小权重\n        for (int i = 0; i &lt; length; i++) &#123;\n            int weight = getWeight(invokers.get(i), invocation);\n            maxWeight = Math.max(maxWeight, weight);\n            minWeight = Math.min(minWeight, weight);\n            if (weight > 0) &#123;\n                invokerToWeightList.add(invokers.get(i));\n            &#125;\n        &#125;\n        \n        // 获取当前服务对应的调用序列对象 AtomicPositiveInteger\n        AtomicPositiveInteger sequence = sequences.get(key);\n        if (sequence == null) &#123;\n            // 创建 AtomicPositiveInteger，默认值为0\n            sequences.putIfAbsent(key, new AtomicPositiveInteger());\n            sequence = sequences.get(key);\n        &#125;\n        \n        // 获取下标序列对象 AtomicPositiveInteger\n        AtomicPositiveInteger indexSeq = indexSeqs.get(key);\n        if (indexSeq == null) &#123;\n            // 创建 AtomicPositiveInteger，默认值为 -1\n            indexSeqs.putIfAbsent(key, new AtomicPositiveInteger(-1));\n            indexSeq = indexSeqs.get(key);\n        &#125;\n\n        if (maxWeight > 0 &amp;&amp; minWeight &lt; maxWeight) &#123;\n            length = invokerToWeightList.size();\n            while (true) &#123;\n                int index = indexSeq.incrementAndGet() % length;\n                int currentWeight = sequence.get() % maxWeight;\n\n                // 每循环一轮（index = 0），重新计算 currentWeight\n                if (index == 0) &#123;\n                    currentWeight = sequence.incrementAndGet() % maxWeight;\n                &#125;\n                \n                // 检测 Invoker 的权重是否大于 currentWeight，大于则返回\n                if (getWeight(invokerToWeightList.get(index), invocation) > currentWeight) &#123;\n                    return invokerToWeightList.get(index);\n                &#125;\n            &#125;\n        &#125;\n        \n        // 所有 Invoker 权重相等，此时进行普通的轮询即可\n        return invokers.get(sequence.incrementAndGet() % length);\n    &#125;\n&#125;\n\n上面代码的逻辑是这样的，每进行一轮循环，重新计算 currentWeight。如果当前 Invoker 权重大于 currentWeight，则返回该 Invoker。下面举例说明，假设服务器 [A, B, C] 对应权重 [5, 2, 1]。\n第一轮循环，currentWeight &#x3D; 1，可返回 A 和 B\n第二轮循环，currentWeight &#x3D; 2，返回 A\n第三轮循环，currentWeight &#x3D; 3，返回 A\n第四轮循环，currentWeight &#x3D; 4，返回 A\n第五轮循环，currentWeight &#x3D; 0，返回 A, B, C\n如上，这里的一轮循环是指 index 再次变为0所经历过的循环，这里可以把 index &#x3D; 0 看做是一轮循环的开始。每一轮循环的次数与 Invoker 的数量有关，Invoker 数量通常不会太多，所以我们可以认为上面代码的时间复杂度为常数级。\n重构后的 RoundRobinLoadBalance 看起来已经很不错了，但是在代码更新不久后，很快又被重构了。这次重构原因是新的 RoundRobinLoadBalance 在某些情况下选出的服务器序列不够均匀。比如，服务器 [A, B, C] 对应权重 [5, 1, 1]。进行7次负载均衡后，选择出来的序列为 [A, A, A, A, A, B, C]。前5个请求全部都落在了服务器 A上，这将会使服务器 A 短时间内接收大量的请求，压力陡增。而 B 和 C 此时无请求，处于空闲状态。而我们期望的结果是这样的 [A, A, B, A, C, A, A]，不同服务器可以穿插获取请求。为了增加负载均衡结果的平滑性，社区再次对 RoundRobinLoadBalance 的实现进行了重构，这次重构参考自 Nginx 的平滑加权轮询负载均衡。每个服务器对应两个权重，分别为 weight 和 currentWeight。其中 weight 是固定的，currentWeight 会动态调整，初始值为0。当有新的请求进来时，遍历服务器列表，让它的 currentWeight 加上自身权重。遍历完成后，找到最大的 currentWeight，并将其减去权重总和，然后返回相应的服务器即可。\n上面描述不是很好理解，下面还是举例进行说明。这里仍然使用服务器 [A, B, C] 对应权重 [5, 1, 1] 的例子说明，现在有7个请求依次进入负载均衡逻辑，选择过程如下：\n\n\n\n请求编号\ncurrentWeight 数组\n选择结果\n减去权重总和后的 currentWeight 数组\n\n\n\n1\n[5, 1, 1]\nA\n[-2, 1, 1]\n\n\n2\n[3, 2, 2]\nA\n[-4, 2, 2]\n\n\n3\n[1, 3, 3]\nB\n[1, -4, 3]\n\n\n4\n[6, -3, 4]\nA\n[-1, -3, 4]\n\n\n5\n[4, -2, 5]\nC\n[4, -2, -2]\n\n\n6\n[9, -1, -1]\nA\n[2, -1, -1]\n\n\n7\n[7, 0, 0]\nA\n[0, 0, 0]\n\n\n如上，经过平滑性处理后，得到的服务器序列为 [A, A, B, A, C, A, A]，相比之前的序列 [A, A, A, A, A, B, C]，分布性要好一些。初始情况下 currentWeight &#x3D; [0, 0, 0]，第7个请求处理完后，currentWeight 再次变为 [0, 0, 0]。\n以上就是平滑加权轮询的计算过程，接下来，我们来看看 Dubbo-2.6.5 是如何实现上面的计算过程的。\npublic class RoundRobinLoadBalance extends AbstractLoadBalance &#123;\n    public static final String NAME = \"roundrobin\";\n    \n    private static int RECYCLE_PERIOD = 60000;\n    \n    protected static class WeightedRoundRobin &#123;\n        // 服务提供者权重\n        private int weight;\n        // 当前权重\n        private AtomicLong current = new AtomicLong(0);\n        // 最后一次更新时间\n        private long lastUpdate;\n        \n        public void setWeight(int weight) &#123;\n            this.weight = weight;\n            // 初始情况下，current = 0\n            current.set(0);\n        &#125;\n        public long increaseCurrent() &#123;\n            // current = current + weight；\n            return current.addAndGet(weight);\n        &#125;\n        public void sel(int total) &#123;\n            // current = current - total;\n            current.addAndGet(-1 * total);\n        &#125;\n    &#125;\n\n    // 嵌套 Map 结构，存储的数据结构示例如下：\n    // &#123;\n    //     \"UserService.query\": &#123;\n    //         \"url1\": WeightedRoundRobin@123, \n    //         \"url2\": WeightedRoundRobin@456, \n    //     &#125;,\n    //     \"UserService.update\": &#123;\n    //         \"url1\": WeightedRoundRobin@123, \n    //         \"url2\": WeightedRoundRobin@456,\n    //     &#125;\n    // &#125;\n    // 最外层为服务类名 + 方法名，第二层为 url 到 WeightedRoundRobin 的映射关系。\n    // 这里我们可以将 url 看成是服务提供者的 id\n    private ConcurrentMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin>> methodWeightMap = new ConcurrentHashMap&lt;String, ConcurrentMap&lt;String, WeightedRoundRobin>>();\n    \n    // 原子更新锁\n    private AtomicBoolean updateLock = new AtomicBoolean();\n    \n    @Override\n    protected &lt;T> Invoker&lt;T> doSelect(List&lt;Invoker&lt;T>> invokers, URL url, Invocation invocation) &#123;\n        String key = invokers.get(0).getUrl().getServiceKey() + \".\" + invocation.getMethodName();\n        // 获取 url 到 WeightedRoundRobin 映射表，如果为空，则创建一个新的\n        ConcurrentMap&lt;String, WeightedRoundRobin> map = methodWeightMap.get(key);\n        if (map == null) &#123;\n            methodWeightMap.putIfAbsent(key, new ConcurrentHashMap&lt;String, WeightedRoundRobin>());\n            map = methodWeightMap.get(key);\n        &#125;\n        int totalWeight = 0;\n        long maxCurrent = Long.MIN_VALUE;\n        \n        // 获取当前时间\n        long now = System.currentTimeMillis();\n        Invoker&lt;T> selectedInvoker = null;\n        WeightedRoundRobin selectedWRR = null;\n\n        // 下面这个循环主要做了这样几件事情：\n        //   1. 遍历 Invoker 列表，检测当前 Invoker 是否有\n        //      相应的 WeightedRoundRobin，没有则创建\n        //   2. 检测 Invoker 权重是否发生了变化，若变化了，\n        //      则更新 WeightedRoundRobin 的 weight 字段\n        //   3. 让 current 字段加上自身权重，等价于 current += weight\n        //   4. 设置 lastUpdate 字段，即 lastUpdate = now\n        //   5. 寻找具有最大 current 的 Invoker，以及 Invoker 对应的 WeightedRoundRobin，\n        //      暂存起来，留作后用\n        //   6. 计算权重总和\n        for (Invoker&lt;T> invoker : invokers) &#123;\n            String identifyString = invoker.getUrl().toIdentityString();\n            WeightedRoundRobin weightedRoundRobin = map.get(identifyString);\n            int weight = getWeight(invoker, invocation);\n            if (weight &lt; 0) &#123;\n                weight = 0;\n            &#125;\n            \n            // 检测当前 Invoker 是否有对应的 WeightedRoundRobin，没有则创建\n            if (weightedRoundRobin == null) &#123;\n                weightedRoundRobin = new WeightedRoundRobin();\n                // 设置 Invoker 权重\n                weightedRoundRobin.setWeight(weight);\n                // 存储 url 唯一标识 identifyString 到 weightedRoundRobin 的映射关系\n                map.putIfAbsent(identifyString, weightedRoundRobin);\n                weightedRoundRobin = map.get(identifyString);\n            &#125;\n            // Invoker 权重不等于 WeightedRoundRobin 中保存的权重，说明权重变化了，此时进行更新\n            if (weight != weightedRoundRobin.getWeight()) &#123;\n                weightedRoundRobin.setWeight(weight);\n            &#125;\n            \n            // 让 current 加上自身权重，等价于 current += weight\n            long cur = weightedRoundRobin.increaseCurrent();\n            // 设置 lastUpdate，表示近期更新过\n            weightedRoundRobin.setLastUpdate(now);\n            // 找出最大的 current \n            if (cur > maxCurrent) &#123;\n                maxCurrent = cur;\n                // 将具有最大 current 权重的 Invoker 赋值给 selectedInvoker\n                selectedInvoker = invoker;\n                // 将 Invoker 对应的 weightedRoundRobin 赋值给 selectedWRR，留作后用\n                selectedWRR = weightedRoundRobin;\n            &#125;\n            \n            // 计算权重总和\n            totalWeight += weight;\n        &#125;\n\n        // 对 &lt;identifyString, WeightedRoundRobin> 进行检查，过滤掉长时间未被更新的节点。\n        // 该节点可能挂了，invokers 中不包含该节点，所以该节点的 lastUpdate 长时间无法被更新。\n        // 若未更新时长超过阈值后，就会被移除掉，默认阈值为60秒。\n        if (!updateLock.get() &amp;&amp; invokers.size() != map.size()) &#123;\n            if (updateLock.compareAndSet(false, true)) &#123;\n                try &#123;\n                    ConcurrentMap&lt;String, WeightedRoundRobin> newMap = new ConcurrentHashMap&lt;String, WeightedRoundRobin>();\n                    // 拷贝\n                    newMap.putAll(map);\n                    \n                    // 遍历修改，即移除过期记录\n                    Iterator&lt;Entry&lt;String, WeightedRoundRobin>> it = newMap.entrySet().iterator();\n                    while (it.hasNext()) &#123;\n                        Entry&lt;String, WeightedRoundRobin> item = it.next();\n                        if (now - item.getValue().getLastUpdate() > RECYCLE_PERIOD) &#123;\n                            it.remove();\n                        &#125;\n                    &#125;\n                    \n                    // 更新引用\n                    methodWeightMap.put(key, newMap);\n                &#125; finally &#123;\n                    updateLock.set(false);\n                &#125;\n            &#125;\n        &#125;\n\n        if (selectedInvoker != null) &#123;\n            // 让 current 减去权重总和，等价于 current -= totalWeight\n            selectedWRR.sel(totalWeight);\n            // 返回具有最大 current 的 Invoker\n            return selectedInvoker;\n        &#125;\n        \n        // should not happen here\n        return invokers.get(0);\n    &#125;\n&#125;\n\n以上就是 Dubbo-2.6.5 版本的 RoundRobinLoadBalance，大家如果能够理解平滑加权轮询算法的计算过程，再配合代码中注释，理解上面的代码应该不难。\n\n3.总结本篇文章对 Dubbo 中的几种负载均衡实现进行了详细的分析，内容比较多，大家慢慢消化。理解负载均衡代码逻辑的关键之处在于对背景知识的理解，因此大家在阅读源码前，务必先了解每种负载均衡对应的背景知识。\n本文介绍了服务调用过程的原理和实现细节\n\n服务导出1. 简介在前面的文章中，我们分析了 Dubbo SPI、服务导出与引入、以及集群容错方面的代码。经过前文的铺垫，本篇文章我们终于可以分析服务调用过程了。Dubbo 服务调用过程比较复杂，包含众多步骤，比如发送请求、编解码、服务降级、过滤器链处理、序列化、线程派发以及响应请求等步骤。限于篇幅原因，本篇文章无法对所有的步骤一一进行分析。本篇文章将会重点分析请求的发送与接收、编解码、线程派发以及响应的发送与接收等过程，至于服务降级、过滤器链和序列化大家自行进行分析，也可以将其当成一个黑盒，暂时忽略也没关系。介绍完本篇文章要分析的内容，接下来我们进入正题吧。\n\n2. 源码分析在进行源码分析之前，我们先来通过一张图了解 Dubbo 服务调用过程。\n\n首先服务消费者通过代理对象 Proxy 发起远程调用，接着通过网络客户端 Client 将编码后的请求发送给服务提供方的网络层上，也就是 Server。Server 在收到请求后，首先要做的事情是对数据包进行解码。然后将解码后的请求发送至分发器 Dispatcher，再由分发器将请求派发到指定的线程池上，最后由线程池调用具体的服务。这就是一个远程调用请求的发送与接收过程。至于响应的发送与接收过程，这张图中没有表现出来。对于这两个过程，我们也会进行详细分析。\n\n2.1 服务调用方式Dubbo 支持同步和异步两种调用方式，其中异步调用还可细分为“有返回值”的异步调用和“无返回值”的异步调用。所谓“无返回值”异步调用是指服务消费方只管调用，但不关心调用结果，此时 Dubbo 会直接返回一个空的 RpcResult。若要使用异步特性，需要服务消费方手动进行配置。默认情况下，Dubbo 使用同步调用方式。\n本节以及其他章节将会使用 Dubbo 官方提供的 Demo 分析整个调用过程，下面我们从 DemoService 接口的代理类开始进行分析。Dubbo 默认使用 Javassist 框架为服务接口生成动态代理类，因此我们需要先将代理类进行反编译才能看到源码。这里使用阿里开源 Java 应用诊断工具 Arthas 反编译代理类，结果如下：\n/**\n * Arthas 反编译步骤：\n * 1. 启动 Arthas\n *    java -jar arthas-boot.jar\n *\n * 2. 输入编号选择进程\n *    Arthas 启动后，会打印 Java 应用进程列表，如下：\n *    [1]: 11232 org.jetbrains.jps.cmdline.Launcher\n *    [2]: 22370 org.jetbrains.jps.cmdline.Launcher\n *    [3]: 22371 com.alibaba.dubbo.demo.consumer.Consumer\n *    [4]: 22362 com.alibaba.dubbo.demo.provider.Provider\n *    [5]: 2074 org.apache.zookeeper.server.quorum.QuorumPeerMain\n * 这里输入编号 3，让 Arthas 关联到启动类为 com.....Consumer 的 Java 进程上\n *\n * 3. 由于 Demo 项目中只有一个服务接口，因此此接口的代理类类名为 proxy0，此时使用 sc 命令搜索这个类名。\n *    $ sc *.proxy0\n *    com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 4. 使用 jad 命令反编译 com.alibaba.dubbo.common.bytecode.proxy0\n *    $ jad com.alibaba.dubbo.common.bytecode.proxy0\n *\n * 更多使用方法请参考 Arthas 官方文档：\n *   https://alibaba.github.io/arthas/quick-start.html\n */\npublic class proxy0 implements ClassGenerator.DC, EchoService, DemoService &#123;\n    // 方法数组\n    public static Method[] methods;\n    private InvocationHandler handler;\n\n    public proxy0(InvocationHandler invocationHandler) &#123;\n        this.handler = invocationHandler;\n    &#125;\n\n    public proxy0() &#123;\n    &#125;\n\n    public String sayHello(String string) &#123;\n        // 将参数存储到 Object 数组中\n        Object[] arrobject = new Object[]&#123;string&#125;;\n        // 调用 InvocationHandler 实现类的 invoke 方法得到调用结果\n        Object object = this.handler.invoke(this, methods[0], arrobject);\n        // 返回调用结果\n        return (String)object;\n    &#125;\n\n    /** 回声测试方法 */\n    public Object $echo(Object object) &#123;\n        Object[] arrobject = new Object[]&#123;object&#125;;\n        Object object2 = this.handler.invoke(this, methods[1], arrobject);\n        return object2;\n    &#125;\n&#125;\n\n如上，代理类的逻辑比较简单。首先将运行时参数存储到数组中，然后调用 InvocationHandler 接口实现类的 invoke 方法，得到调用结果，最后将结果转型并返回给调用方。关于代理类的逻辑就说这么多，继续向下分析。\npublic class InvokerInvocationHandler implements InvocationHandler &#123;\n\n    private final Invoker&lt;?> invoker;\n\n    public InvokerInvocationHandler(Invoker&lt;?> handler) &#123;\n        this.invoker = handler;\n    &#125;\n\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        String methodName = method.getName();\n        Class&lt;?>[] parameterTypes = method.getParameterTypes();\n        \n        // 拦截定义在 Object 类中的方法（未被子类重写），比如 wait/notify\n        if (method.getDeclaringClass() == Object.class) &#123;\n            return method.invoke(invoker, args);\n        &#125;\n        \n        // 如果 toString、hashCode 和 equals 等方法被子类重写了，这里也直接调用\n        if (\"toString\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;\n            return invoker.toString();\n        &#125;\n        if (\"hashCode\".equals(methodName) &amp;&amp; parameterTypes.length == 0) &#123;\n            return invoker.hashCode();\n        &#125;\n        if (\"equals\".equals(methodName) &amp;&amp; parameterTypes.length == 1) &#123;\n            return invoker.equals(args[0]);\n        &#125;\n        \n        // 将 method 和 args 封装到 RpcInvocation 中，并执行后续的调用\n        return invoker.invoke(new RpcInvocation(method, args)).recreate();\n    &#125;\n&#125;\n\nInvokerInvocationHandler 中的 invoker 成员变量类型为 MockClusterInvoker，MockClusterInvoker 内部封装了服务降级逻辑。下面简单看一下：\npublic class MockClusterInvoker&lt;T> implements Invoker&lt;T> &#123;\n    \n    private final Invoker&lt;T> invoker;\n    \n    public Result invoke(Invocation invocation) throws RpcException &#123;\n        Result result = null;\n\n        // 获取 mock 配置值\n        String value = directory.getUrl().getMethodParameter(invocation.getMethodName(), Constants.MOCK_KEY, Boolean.FALSE.toString()).trim();\n        if (value.length() == 0 || value.equalsIgnoreCase(\"false\")) &#123;\n            // 无 mock 逻辑，直接调用其他 Invoker 对象的 invoke 方法，\n            // 比如 FailoverClusterInvoker\n            result = this.invoker.invoke(invocation);\n        &#125; else if (value.startsWith(\"force\")) &#123;\n            // force:xxx 直接执行 mock 逻辑，不发起远程调用\n            result = doMockInvoke(invocation, null);\n        &#125; else &#123;\n            // fail:xxx 表示消费方对调用服务失败后，再执行 mock 逻辑，不抛出异常\n            try &#123;\n                // 调用其他 Invoker 对象的 invoke 方法\n                result = this.invoker.invoke(invocation);\n            &#125; catch (RpcException e) &#123;\n                if (e.isBiz()) &#123;\n                    throw e;\n                &#125; else &#123;\n                    // 调用失败，执行 mock 逻辑\n                    result = doMockInvoke(invocation, e);\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n    \n    // 省略其他方法\n&#125;\n\n服务降级不是本文重点，因此这里就不分析 doMockInvoke 方法了。考虑到前文已经详细分析过 FailoverClusterInvoker，因此本节略过 FailoverClusterInvoker，直接分析 DubboInvoker。\npublic abstract class AbstractInvoker&lt;T> implements Invoker&lt;T> &#123;\n    \n    public Result invoke(Invocation inv) throws RpcException &#123;\n        if (destroyed.get()) &#123;\n            throw new RpcException(\"Rpc invoker for service ...\");\n        &#125;\n        RpcInvocation invocation = (RpcInvocation) inv;\n        // 设置 Invoker\n        invocation.setInvoker(this);\n        if (attachment != null &amp;&amp; attachment.size() > 0) &#123;\n            // 设置 attachment\n            invocation.addAttachmentsIfAbsent(attachment);\n        &#125;\n        Map&lt;String, String> contextAttachments = RpcContext.getContext().getAttachments();\n        if (contextAttachments != null &amp;&amp; contextAttachments.size() != 0) &#123;\n            // 添加 contextAttachments 到 RpcInvocation#attachment 变量中\n            invocation.addAttachments(contextAttachments);\n        &#125;\n        if (getUrl().getMethodParameter(invocation.getMethodName(), Constants.ASYNC_KEY, false)) &#123;\n            // 设置异步信息到 RpcInvocation#attachment 中\n            invocation.setAttachment(Constants.ASYNC_KEY, Boolean.TRUE.toString());\n        &#125;\n        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);\n\n        try &#123;\n            // 抽象方法，由子类实现\n            return doInvoke(invocation);\n        &#125; catch (InvocationTargetException e) &#123;\n            // ...\n        &#125; catch (RpcException e) &#123;\n            // ...\n        &#125; catch (Throwable e) &#123;\n            return new RpcResult(e);\n        &#125;\n    &#125;\n\n    protected abstract Result doInvoke(Invocation invocation) throws Throwable;\n    \n    // 省略其他方法\n&#125;\n\n上面的代码来自 AbstractInvoker 类，其中大部分代码用于添加信息到 RpcInvocation#attachment 变量中，添加完毕后，调用 doInvoke 执行后续的调用。doInvoke 是一个抽象方法，需要由子类实现，下面到 DubboInvoker 中看一下。\npublic class DubboInvoker&lt;T> extends AbstractInvoker&lt;T> &#123;\n    \n    private final ExchangeClient[] clients;\n    \n    protected Result doInvoke(final Invocation invocation) throws Throwable &#123;\n        RpcInvocation inv = (RpcInvocation) invocation;\n        final String methodName = RpcUtils.getMethodName(invocation);\n        // 设置 path 和 version 到 attachment 中\n        inv.setAttachment(Constants.PATH_KEY, getUrl().getPath());\n        inv.setAttachment(Constants.VERSION_KEY, version);\n\n        ExchangeClient currentClient;\n        if (clients.length == 1) &#123;\n            // 从 clients 数组中获取 ExchangeClient\n            currentClient = clients[0];\n        &#125; else &#123;\n            currentClient = clients[index.getAndIncrement() % clients.length];\n        &#125;\n        try &#123;\n            // 获取异步配置\n            boolean isAsync = RpcUtils.isAsync(getUrl(), invocation);\n            // isOneway 为 true，表示“单向”通信\n            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);\n            int timeout = getUrl().getMethodParameter(methodName, Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n\n            // 异步无返回值\n            if (isOneway) &#123;\n                boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);\n                // 发送请求\n                currentClient.send(inv, isSent);\n                // 设置上下文中的 future 字段为 null\n                RpcContext.getContext().setFuture(null);\n                // 返回一个空的 RpcResult\n                return new RpcResult();\n            &#125; \n\n            // 异步有返回值\n            else if (isAsync) &#123;\n                // 发送请求，并得到一个 ResponseFuture 实例\n                ResponseFuture future = currentClient.request(inv, timeout);\n                // 设置 future 到上下文中\n                RpcContext.getContext().setFuture(new FutureAdapter&lt;Object>(future));\n                // 暂时返回一个空结果\n                return new RpcResult();\n            &#125; \n\n            // 同步调用\n            else &#123;\n                RpcContext.getContext().setFuture(null);\n                // 发送请求，得到一个 ResponseFuture 实例，并调用该实例的 get 方法进行等待\n                return (Result) currentClient.request(inv, timeout).get();\n            &#125;\n        &#125; catch (TimeoutException e) &#123;\n            throw new RpcException(..., \"Invoke remote method timeout....\");\n        &#125; catch (RemotingException e) &#123;\n            throw new RpcException(..., \"Failed to invoke remote method: ...\");\n        &#125;\n    &#125;\n    \n    // 省略其他方法\n&#125;\n\n上面的代码包含了 Dubbo 对同步和异步调用的处理逻辑，搞懂了上面的代码，会对 Dubbo 的同步和异步调用方式有更深入的了解。Dubbo 实现同步和异步调用比较关键的一点就在于由谁调用 ResponseFuture 的 get 方法。同步调用模式下，由框架自身调用 ResponseFuture 的 get 方法。异步调用模式下，则由用户调用该方法。ResponseFuture 是一个接口，下面我们来看一下它的默认实现类 DefaultFuture 的源码。\npublic class DefaultFuture implements ResponseFuture &#123;\n    \n    private static final Map&lt;Long, Channel> CHANNELS = \n        new ConcurrentHashMap&lt;Long, Channel>();\n\n    private static final Map&lt;Long, DefaultFuture> FUTURES = \n        new ConcurrentHashMap&lt;Long, DefaultFuture>();\n    \n    private final long id;\n    private final Channel channel;\n    private final Request request;\n    private final int timeout;\n    private final Lock lock = new ReentrantLock();\n    private final Condition done = lock.newCondition();\n    private volatile Response response;\n    \n    public DefaultFuture(Channel channel, Request request, int timeout) &#123;\n        this.channel = channel;\n        this.request = request;\n        \n        // 获取请求 id，这个 id 很重要，后面还会见到\n        this.id = request.getId();\n        this.timeout = timeout > 0 ? timeout : channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n        // 存储 &lt;requestId, DefaultFuture> 映射关系到 FUTURES 中\n        FUTURES.put(id, this);\n        CHANNELS.put(id, channel);\n    &#125;\n    \n    @Override\n    public Object get() throws RemotingException &#123;\n        return get(timeout);\n    &#125;\n\n    @Override\n    public Object get(int timeout) throws RemotingException &#123;\n        if (timeout &lt;= 0) &#123;\n            timeout = Constants.DEFAULT_TIMEOUT;\n        &#125;\n        \n        // 检测服务提供方是否成功返回了调用结果\n        if (!isDone()) &#123;\n            long start = System.currentTimeMillis();\n            lock.lock();\n            try &#123;\n                // 循环检测服务提供方是否成功返回了调用结果\n                while (!isDone()) &#123;\n                    // 如果调用结果尚未返回，这里等待一段时间\n                    done.await(timeout, TimeUnit.MILLISECONDS);\n                    // 如果调用结果成功返回，或等待超时，此时跳出 while 循环，执行后续的逻辑\n                    if (isDone() || System.currentTimeMillis() - start > timeout) &#123;\n                        break;\n                    &#125;\n                &#125;\n            &#125; catch (InterruptedException e) &#123;\n                throw new RuntimeException(e);\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n            \n            // 如果调用结果仍未返回，则抛出超时异常\n            if (!isDone()) &#123;\n                throw new TimeoutException(sent > 0, channel, getTimeoutMessage(false));\n            &#125;\n        &#125;\n        \n        // 返回调用结果\n        return returnFromResponse();\n    &#125;\n    \n    @Override\n    public boolean isDone() &#123;\n        // 通过检测 response 字段为空与否，判断是否收到了调用结果\n        return response != null;\n    &#125;\n    \n    private Object returnFromResponse() throws RemotingException &#123;\n        Response res = response;\n        if (res == null) &#123;\n            throw new IllegalStateException(\"response cannot be null\");\n        &#125;\n        \n        // 如果调用结果的状态为 Response.OK，则表示调用过程正常，服务提供方成功返回了调用结果\n        if (res.getStatus() == Response.OK) &#123;\n            return res.getResult();\n        &#125;\n        \n        // 抛出异常\n        if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) &#123;\n            throw new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage());\n        &#125;\n        throw new RemotingException(channel, res.getErrorMessage());\n    &#125;\n    \n    // 省略其他方法\n&#125;\n\n如上，当服务消费者还未接收到调用结果时，用户线程调用 get 方法会被阻塞住。同步调用模式下，框架获得 DefaultFuture 对象后，会立即调用 get 方法进行等待。而异步模式下则是将该对象封装到 FutureAdapter 实例中，并将 FutureAdapter 实例设置到 RpcContext 中，供用户使用。FutureAdapter 是一个适配器，用于将 Dubbo 中的 ResponseFuture 与 JDK 中的 Future 进行适配。这样当用户线程调用 Future 的 get 方法时，经过 FutureAdapter 适配，最终会调用 ResponseFuture 实现类对象的 get 方法，也就是 DefaultFuture 的 get 方法。\n到这里关于 Dubbo 几种调用方式的代码逻辑就分析完了，下面来分析请求数据的发送与接收，以及响应数据的发送与接收过程。\n\n2.2 服务消费方发送请求\n2.2.1 发送请求本节我们来看一下同步调用模式下，服务消费方是如何发送调用请求的。在深入分析源码前，我们先来看一张图。\n\n这张图展示了服务消费方发送请求过程的部分调用栈，略为复杂。从上图可以看出，经过多次调用后，才将请求数据送至 Netty NioClientSocketChannel。这样做的原因是通过 Exchange 层为框架引入 Request 和 Response 语义，这一点会在接下来的源码分析过程中会看到。其他的就不多说了，下面开始进行分析。首先分析 ReferenceCountExchangeClient 的源码。\nfinal class ReferenceCountExchangeClient implements ExchangeClient &#123;\n\n    private final URL url;\n    private final AtomicInteger referenceCount = new AtomicInteger(0);\n\n    public ReferenceCountExchangeClient(ExchangeClient client, ConcurrentMap&lt;String, LazyConnectExchangeClient> ghostClientMap) &#123;\n        this.client = client;\n        // 引用计数自增\n        referenceCount.incrementAndGet();\n        this.url = client.getUrl();\n        \n        // ...\n    &#125;\n\n    @Override\n    public ResponseFuture request(Object request) throws RemotingException &#123;\n        // 直接调用被装饰对象的同签名方法\n        return client.request(request);\n    &#125;\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException &#123;\n        // 直接调用被装饰对象的同签名方法\n        return client.request(request, timeout);\n    &#125;\n\n    /** 引用计数自增，该方法由外部调用 */\n    public void incrementAndGetCount() &#123;\n        // referenceCount 自增\n        referenceCount.incrementAndGet();\n    &#125;\n    \n        @Override\n    public void close(int timeout) &#123;\n        // referenceCount 自减\n        if (referenceCount.decrementAndGet() &lt;= 0) &#123;\n            if (timeout == 0) &#123;\n                client.close();\n            &#125; else &#123;\n                client.close(timeout);\n            &#125;\n            client = replaceWithLazyClient();\n        &#125;\n    &#125;\n    \n    // 省略部分方法\n&#125;\n\nReferenceCountExchangeClient 内部定义了一个引用计数变量 referenceCount，每当该对象被引用一次 referenceCount 都会进行自增。每当 close 方法被调用时，referenceCount 进行自减。ReferenceCountExchangeClient 内部仅实现了一个引用计数的功能，其他方法并无复杂逻辑，均是直接调用被装饰对象的相关方法。所以这里就不多说了，继续向下分析，这次是 HeaderExchangeClient。\npublic class HeaderExchangeClient implements ExchangeClient &#123;\n\n    private static final ScheduledThreadPoolExecutor scheduled = new ScheduledThreadPoolExecutor(2, new NamedThreadFactory(\"dubbo-remoting-client-heartbeat\", true));\n    private final Client client;\n    private final ExchangeChannel channel;\n    private ScheduledFuture&lt;?> heartbeatTimer;\n    private int heartbeat;\n    private int heartbeatTimeout;\n\n    public HeaderExchangeClient(Client client, boolean needHeartbeat) &#123;\n        if (client == null) &#123;\n            throw new IllegalArgumentException(\"client == null\");\n        &#125;\n        this.client = client;\n        \n        // 创建 HeaderExchangeChannel 对象\n        this.channel = new HeaderExchangeChannel(client);\n        \n        // 以下代码均与心跳检测逻辑有关\n        String dubbo = client.getUrl().getParameter(Constants.DUBBO_VERSION_KEY);\n        this.heartbeat = client.getUrl().getParameter(Constants.HEARTBEAT_KEY, dubbo != null &amp;&amp; dubbo.startsWith(\"1.0.\") ? Constants.DEFAULT_HEARTBEAT : 0);\n        this.heartbeatTimeout = client.getUrl().getParameter(Constants.HEARTBEAT_TIMEOUT_KEY, heartbeat * 3);\n        if (heartbeatTimeout &lt; heartbeat * 2) &#123;\n            throw new IllegalStateException(\"heartbeatTimeout &lt; heartbeatInterval * 2\");\n        &#125;\n        if (needHeartbeat) &#123;\n            // 开启心跳检测定时器\n            startHeartbeatTimer();\n        &#125;\n    &#125;\n\n    @Override\n    public ResponseFuture request(Object request) throws RemotingException &#123;\n        // 直接 HeaderExchangeChannel 对象的同签名方法\n        return channel.request(request);\n    &#125;\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException &#123;\n        // 直接 HeaderExchangeChannel 对象的同签名方法\n        return channel.request(request, timeout);\n    &#125;\n\n    @Override\n    public void close() &#123;\n        doClose();\n        channel.close();\n    &#125;\n    \n    private void doClose() &#123;\n        // 停止心跳检测定时器\n        stopHeartbeatTimer();\n    &#125;\n\n    private void startHeartbeatTimer() &#123;\n        stopHeartbeatTimer();\n        if (heartbeat > 0) &#123;\n            heartbeatTimer = scheduled.scheduleWithFixedDelay(\n                    new HeartBeatTask(new HeartBeatTask.ChannelProvider() &#123;\n                        @Override\n                        public Collection&lt;Channel> getChannels() &#123;\n                            return Collections.&lt;Channel>singletonList(HeaderExchangeClient.this);\n                        &#125;\n                    &#125;, heartbeat, heartbeatTimeout),\n                    heartbeat, heartbeat, TimeUnit.MILLISECONDS);\n        &#125;\n    &#125;\n\n    private void stopHeartbeatTimer() &#123;\n        if (heartbeatTimer != null &amp;&amp; !heartbeatTimer.isCancelled()) &#123;\n            try &#123;\n                heartbeatTimer.cancel(true);\n                scheduled.purge();\n            &#125; catch (Throwable e) &#123;\n                if (logger.isWarnEnabled()) &#123;\n                    logger.warn(e.getMessage(), e);\n                &#125;\n            &#125;\n        &#125;\n        heartbeatTimer = null;\n    &#125;\n    \n    // 省略部分方法\n&#125;\n\nHeaderExchangeClient 中很多方法只有一行代码，即调用 HeaderExchangeChannel 对象的同签名方法。那 HeaderExchangeClient 有什么用处呢？答案是封装了一些关于心跳检测的逻辑。心跳检测并非本文所关注的点，因此就不多说了，继续向下看。\nfinal class HeaderExchangeChannel implements ExchangeChannel &#123;\n    \n    private final Channel channel;\n    \n    HeaderExchangeChannel(Channel channel) &#123;\n        if (channel == null) &#123;\n            throw new IllegalArgumentException(\"channel == null\");\n        &#125;\n        \n        // 这里的 channel 指向的是 NettyClient\n        this.channel = channel;\n    &#125;\n    \n    @Override\n    public ResponseFuture request(Object request) throws RemotingException &#123;\n        return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));\n    &#125;\n\n    @Override\n    public ResponseFuture request(Object request, int timeout) throws RemotingException &#123;\n        if (closed) &#123;\n            throw new RemotingException(..., \"Failed to send request ...);\n        &#125;\n        // 创建 Request 对象\n        Request req = new Request();\n        req.setVersion(Version.getProtocolVersion());\n        // 设置双向通信标志为 true\n        req.setTwoWay(true);\n        // 这里的 request 变量类型为 RpcInvocation\n        req.setData(request);\n                                        \n        // 创建 DefaultFuture 对象\n        DefaultFuture future = new DefaultFuture(channel, req, timeout);\n        try &#123;\n            // 调用 NettyClient 的 send 方法发送请求\n            channel.send(req);\n        &#125; catch (RemotingException e) &#123;\n            future.cancel();\n            throw e;\n        &#125;\n        // 返回 DefaultFuture 对象\n        return future;\n    &#125;\n&#125;\n\n到这里大家终于看到了 Request 语义了，上面的方法首先定义了一个 Request 对象，然后再将该对象传给 NettyClient 的 send 方法，进行后续的调用。需要说明的是，NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，下面直接分析 AbstractPeer 的代码。\npublic abstract class AbstractPeer implements Endpoint, ChannelHandler &#123;\n    \n    @Override\n    public void send(Object message) throws RemotingException &#123;\n        // 该方法由 AbstractClient 类实现\n        send(message, url.getParameter(Constants.SENT_KEY, false));\n    &#125;\n    \n    // 省略其他方法\n&#125;\n\npublic abstract class AbstractClient extends AbstractEndpoint implements Client &#123;\n    \n    @Override\n    public void send(Object message, boolean sent) throws RemotingException &#123;\n        if (send_reconnect &amp;&amp; !isConnected()) &#123;\n            connect();\n        &#125;\n        \n        // 获取 Channel，getChannel 是一个抽象方法，具体由子类实现\n        Channel channel = getChannel();\n        if (channel == null || !channel.isConnected()) &#123;\n            throw new RemotingException(this, \"message can not send ...\");\n        &#125;\n        \n        // 继续向下调用\n        channel.send(message, sent);\n    &#125;\n    \n    protected abstract Channel getChannel();\n    \n    // 省略其他方法\n&#125;\n\n默认情况下，Dubbo 使用 Netty 作为底层的通信框架，因此下面我们到 NettyClient 类中看一下 getChannel 方法的实现逻辑。\npublic class NettyClient extends AbstractClient &#123;\n    \n    // 这里的 Channel 全限定名称为 org.jboss.netty.channel.Channel\n    private volatile Channel channel;\n\n    @Override\n    protected com.alibaba.dubbo.remoting.Channel getChannel() &#123;\n        Channel c = channel;\n        if (c == null || !c.isConnected())\n            return null;\n        // 获取一个 NettyChannel 类型对象\n        return NettyChannel.getOrAddChannel(c, getUrl(), this);\n    &#125;\n&#125;\n\nfinal class NettyChannel extends AbstractChannel &#123;\n\n    private static final ConcurrentMap&lt;org.jboss.netty.channel.Channel, NettyChannel> channelMap = \n        new ConcurrentHashMap&lt;org.jboss.netty.channel.Channel, NettyChannel>();\n\n    private final org.jboss.netty.channel.Channel channel;\n    \n    /** 私有构造方法 */\n    private NettyChannel(org.jboss.netty.channel.Channel channel, URL url, ChannelHandler handler) &#123;\n        super(url, handler);\n        if (channel == null) &#123;\n            throw new IllegalArgumentException(\"netty channel == null;\");\n        &#125;\n        this.channel = channel;\n    &#125;\n\n    static NettyChannel getOrAddChannel(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler) &#123;\n        if (ch == null) &#123;\n            return null;\n        &#125;\n        \n        // 尝试从集合中获取 NettyChannel 实例\n        NettyChannel ret = channelMap.get(ch);\n        if (ret == null) &#123;\n            // 如果 ret = null，则创建一个新的 NettyChannel 实例\n            NettyChannel nc = new NettyChannel(ch, url, handler);\n            if (ch.isConnected()) &#123;\n                // 将 &lt;Channel, NettyChannel> 键值对存入 channelMap 集合中\n                ret = channelMap.putIfAbsent(ch, nc);\n            &#125;\n            if (ret == null) &#123;\n                ret = nc;\n            &#125;\n        &#125;\n        return ret;\n    &#125;\n&#125;\n\n获取到 NettyChannel 实例后，即可进行后续的调用。下面看一下 NettyChannel 的 send 方法。\npublic void send(Object message, boolean sent) throws RemotingException &#123;\n    super.send(message, sent);\n\n    boolean success = true;\n    int timeout = 0;\n    try &#123;\n        // 发送消息(包含请求和响应消息)\n        ChannelFuture future = channel.write(message);\n        \n        // sent 的值源于 &lt;dubbo:method sent=\"true/false\" /> 中 sent 的配置值，有两种配置值：\n        //   1. true: 等待消息发出，消息发送失败将抛出异常\n        //   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回\n        // 默认情况下 sent = false；\n        if (sent) &#123;\n            timeout = getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT);\n            // 等待消息发出，若在规定时间没能发出，success 会被置为 false\n            success = future.await(timeout);\n        &#125;\n        Throwable cause = future.getCause();\n        if (cause != null) &#123;\n            throw cause;\n        &#125;\n    &#125; catch (Throwable e) &#123;\n        throw new RemotingException(this, \"Failed to send message ...\");\n    &#125;\n\n    // 若 success 为 false，这里抛出异常\n    if (!success) &#123;\n        throw new RemotingException(this, \"Failed to send message ...\");\n    &#125;\n&#125;\n\n经历多次调用，到这里请求数据的发送过程就结束了，过程漫长。为了便于大家阅读代码，这里以 DemoService 为例，将 sayHello 方法的整个调用路径贴出来。\nproxy0#sayHello(String)\n  —&gt; InvokerInvocationHandler#invoke(Object, Method, Object[])\n    —&gt; MockClusterInvoker#invoke(Invocation)\n      —&gt; AbstractClusterInvoker#invoke(Invocation)\n        —&gt; FailoverClusterInvoker#doInvoke(Invocation, List&lt;Invoker&lt;T&gt;&gt;, LoadBalance)\n          —&gt; Filter#invoke(Invoker, Invocation)  &#x2F;&#x2F; 包含多个 Filter 调用\n            —&gt; ListenerInvokerWrapper#invoke(Invocation) \n              —&gt; AbstractInvoker#invoke(Invocation) \n                —&gt; DubboInvoker#doInvoke(Invocation)\n                  —&gt; ReferenceCountExchangeClient#request(Object, int)\n                    —&gt; HeaderExchangeClient#request(Object, int)\n                      —&gt; HeaderExchangeChannel#request(Object, int)\n                        —&gt; AbstractPeer#send(Object)\n                          —&gt; AbstractClient#send(Object, boolean)\n                            —&gt; NettyChannel#send(Object, boolean)\n                              —&gt; NioClientSocketChannel#write(Object)\n\n在 Netty 中，出站数据在发出之前还需要进行编码操作，接下来我们来分析一下请求数据的编码逻辑。\n\n2.2.2 请求编码在分析请求编码逻辑之前，我们先来看一下 Dubbo 数据包结构。\n\nDubbo 数据包分为消息头和消息体，消息头用于存储一些元信息，比如魔数（Magic），数据包类型（Request&#x2F;Response），消息体长度（Data Length）等。消息体中用于存储具体的调用消息，比如方法名称，参数列表等。下面简单列举一下消息头的内容。\n\n\n\n偏移量(Bit)\n字段\n取值\n\n\n\n0 ~ 7\n魔数高位\n0xda00\n\n\n8 ~ 15\n魔数低位\n0xbb\n\n\n16\n数据包类型\n0 - Response, 1 - Request\n\n\n17\n调用方式\n仅在第16位被设为1的情况下有效，0 - 单向调用，1 - 双向调用\n\n\n18\n事件标识\n0 - 当前数据包是请求或响应包，1 - 当前数据包是心跳包\n\n\n19 ~ 23\n序列化器编号\n2 - Hessian2Serialization 3 - JavaSerialization 4 - CompactedJavaSerialization 6 - FastJsonSerialization 7 - NativeJavaSerialization 8 - KryoSerialization 9 - FstSerialization\n\n\n24 ~ 31\n状态\n20 - OK 30 - CLIENT_TIMEOUT 31 - SERVER_TIMEOUT 40 - BAD_REQUEST 50 - BAD_RESPONSE ……\n\n\n32 ~ 95\n请求编号\n共8字节，运行时生成\n\n\n96 ~ 127\n消息体长度\n运行时计算\n\n\n了解了 Dubbo 数据包格式，接下来我们就可以探索编码过程了。这次我们开门见山，直接分析编码逻辑所在类。如下：\npublic class ExchangeCodec extends TelnetCodec &#123;\n\n    // 消息头长度\n    protected static final int HEADER_LENGTH = 16;\n    // 魔数内容\n    protected static final short MAGIC = (short) 0xdabb;\n    protected static final byte MAGIC_HIGH = Bytes.short2bytes(MAGIC)[0];\n    protected static final byte MAGIC_LOW = Bytes.short2bytes(MAGIC)[1];\n    protected static final byte FLAG_REQUEST = (byte) 0x80;\n    protected static final byte FLAG_TWOWAY = (byte) 0x40;\n    protected static final byte FLAG_EVENT = (byte) 0x20;\n    protected static final int SERIALIZATION_MASK = 0x1f;\n    private static final Logger logger = LoggerFactory.getLogger(ExchangeCodec.class);\n\n    public Short getMagicCode() &#123;\n        return MAGIC;\n    &#125;\n\n    @Override\n    public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException &#123;\n        if (msg instanceof Request) &#123;\n            // 对 Request 对象进行编码\n            encodeRequest(channel, buffer, (Request) msg);\n        &#125; else if (msg instanceof Response) &#123;\n            // 对 Response 对象进行编码，后面分析\n            encodeResponse(channel, buffer, (Response) msg);\n        &#125; else &#123;\n            super.encode(channel, buffer, msg);\n        &#125;\n    &#125;\n\n    protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException &#123;\n        Serialization serialization = getSerialization(channel);\n\n        // 创建消息头字节数组，长度为 16\n        byte[] header = new byte[HEADER_LENGTH];\n\n        // 设置魔数\n        Bytes.short2bytes(MAGIC, header);\n\n        // 设置数据包类型（Request/Response）和序列化器编号\n        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());\n\n        // 设置通信方式(单向/双向)\n        if (req.isTwoWay()) &#123;\n            header[2] |= FLAG_TWOWAY;\n        &#125;\n        \n        // 设置事件标识\n        if (req.isEvent()) &#123;\n            header[2] |= FLAG_EVENT;\n        &#125;\n\n        // 设置请求编号，8个字节，从第4个字节开始设置\n        Bytes.long2bytes(req.getId(), header, 4);\n\n        // 获取 buffer 当前的写位置\n        int savedWriteIndex = buffer.writerIndex();\n        // 更新 writerIndex，为消息头预留 16 个字节的空间\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n        // 创建序列化器，比如 Hessian2ObjectOutput\n        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n        if (req.isEvent()) &#123;\n            // 对事件数据进行序列化操作\n            encodeEventData(channel, out, req.getData());\n        &#125; else &#123;\n            // 对请求数据进行序列化操作\n            encodeRequestData(channel, out, req.getData(), req.getVersion());\n        &#125;\n        out.flushBuffer();\n        if (out instanceof Cleanable) &#123;\n            ((Cleanable) out).cleanup();\n        &#125;\n        bos.flush();\n        bos.close();\n        \n        // 获取写入的字节数，也就是消息体长度\n        int len = bos.writtenBytes();\n        checkPayload(channel, len);\n\n        // 将消息体长度写入到消息头中\n        Bytes.int2bytes(len, header, 12);\n\n        // 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备\n        buffer.writerIndex(savedWriteIndex);\n        // 从 savedWriteIndex 下标处写入消息头\n        buffer.writeBytes(header);\n        // 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度\n        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n    &#125;\n    \n    // 省略其他方法\n&#125;\n\n以上就是请求对象的编码过程，该过程首先会通过位运算将消息头写入到 header 数组中。然后对 Request 对象的 data 字段执行序列化操作，序列化后的数据最终会存储到 ChannelBuffer 中。序列化操作执行完后，可得到数据序列化后的长度 len，紧接着将 len 写入到 header 指定位置处。最后再将消息头字节数组 header 写入到 ChannelBuffer 中，整个编码过程就结束了。本节的最后，我们再来看一下 Request 对象的 data 字段序列化过程，也就是 encodeRequestData 方法的逻辑，如下：\npublic class DubboCodec extends ExchangeCodec implements Codec2 &#123;\n    \n\tprotected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123;\n        RpcInvocation inv = (RpcInvocation) data;\n\n        // 依次序列化 dubbo version、path、version\n        out.writeUTF(version);\n        out.writeUTF(inv.getAttachment(Constants.PATH_KEY));\n        out.writeUTF(inv.getAttachment(Constants.VERSION_KEY));\n\n        // 序列化调用方法名\n        out.writeUTF(inv.getMethodName());\n        // 将参数类型转换为字符串，并进行序列化\n        out.writeUTF(ReflectUtils.getDesc(inv.getParameterTypes()));\n        Object[] args = inv.getArguments();\n        if (args != null)\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                // 对运行时参数进行序列化\n                out.writeObject(encodeInvocationArgument(channel, inv, i));\n            &#125;\n        \n        // 序列化 attachments\n        out.writeObject(inv.getAttachments());\n    &#125;\n&#125;\n\n至此，关于服务消费方发送请求的过程就分析完了，接下来我们来看一下服务提供方是如何接收请求的。\n\n2.3 服务提供方接收请求前面说过，默认情况下 Dubbo 使用 Netty 作为底层的通信框架。Netty 检测到有数据入站后，首先会通过解码器对数据进行解码，并将解码后的数据传递给下一个入站处理器的指定方法。所以在进行后续的分析之前，我们先来看一下数据解码过程。\n\n2.3.1 请求解码这里直接分析请求数据的解码逻辑，忽略中间过程，如下：\npublic class ExchangeCodec extends TelnetCodec &#123;\n    \n    @Override\n    public Object decode(Channel channel, ChannelBuffer buffer) throws IOException &#123;\n        int readable = buffer.readableBytes();\n        // 创建消息头字节数组\n        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];\n        // 读取消息头数据\n        buffer.readBytes(header);\n        // 调用重载方法进行后续解码工作\n        return decode(channel, buffer, readable, header);\n    &#125;\n\n    @Override\n    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException &#123;\n        // 检查魔数是否相等\n        if (readable > 0 &amp;&amp; header[0] != MAGIC_HIGH\n                || readable > 1 &amp;&amp; header[1] != MAGIC_LOW) &#123;\n            int length = header.length;\n            if (header.length &lt; readable) &#123;\n                header = Bytes.copyOf(header, readable);\n                buffer.readBytes(header, length, readable - length);\n            &#125;\n            for (int i = 1; i &lt; header.length - 1; i++) &#123;\n                if (header[i] == MAGIC_HIGH &amp;&amp; header[i + 1] == MAGIC_LOW) &#123;\n                    buffer.readerIndex(buffer.readerIndex() - header.length + i);\n                    header = Bytes.copyOf(header, i);\n                    break;\n                &#125;\n            &#125;\n            // 通过 telnet 命令行发送的数据包不包含消息头，所以这里\n            // 调用 TelnetCodec 的 decode 方法对数据包进行解码\n            return super.decode(channel, buffer, readable, header);\n        &#125;\n        \n        // 检测可读数据量是否少于消息头长度，若小于则立即返回 DecodeResult.NEED_MORE_INPUT\n        if (readable &lt; HEADER_LENGTH) &#123;\n            return DecodeResult.NEED_MORE_INPUT;\n        &#125;\n\n        // 从消息头中获取消息体长度\n        int len = Bytes.bytes2int(header, 12);\n        // 检测消息体长度是否超出限制，超出则抛出异常\n        checkPayload(channel, len);\n\n        int tt = len + HEADER_LENGTH;\n        // 检测可读的字节数是否小于实际的字节数\n        if (readable &lt; tt) &#123;\n            return DecodeResult.NEED_MORE_INPUT;\n        &#125;\n        \n        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);\n\n        try &#123;\n            // 继续进行解码工作\n            return decodeBody(channel, is, header);\n        &#125; finally &#123;\n            if (is.available() > 0) &#123;\n                try &#123;\n                    StreamUtils.skipUnusedStream(is);\n                &#125; catch (IOException e) &#123;\n                    logger.warn(e.getMessage(), e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\n上面方法通过检测消息头中的魔数是否与规定的魔数相等，提前拦截掉非常规数据包，比如通过 telnet 命令行发出的数据包。接着再对消息体长度，以及可读字节数进行检测。最后调用 decodeBody 方法进行后续的解码工作，ExchangeCodec 中实现了 decodeBody 方法，但因其子类 DubboCodec 覆写了该方法，所以在运行时 DubboCodec 中的 decodeBody 方法会被调用。下面我们来看一下该方法的代码。\npublic class DubboCodec extends ExchangeCodec implements Codec2 &#123;\n\n    @Override\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123;\n        // 获取消息头中的第三个字节，并通过逻辑与运算得到序列化器编号\n        byte flag = header[2], proto = (byte) (flag &amp; SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        // 获取调用编号\n        long id = Bytes.bytes2long(header, 4);\n        // 通过逻辑与运算得到调用类型，0 - Response，1 - Request\n        if ((flag &amp; FLAG_REQUEST) == 0) &#123;\n            // 对响应结果进行解码，得到 Response 对象。这个非本节内容，后面再分析\n            // ...\n        &#125; else &#123;\n            // 创建 Request 对象\n            Request req = new Request(id);\n            req.setVersion(Version.getProtocolVersion());\n            // 通过逻辑与运算得到通信方式，并设置到 Request 对象中\n            req.setTwoWay((flag &amp; FLAG_TWOWAY) != 0);\n            \n            // 通过位运算检测数据包是否为事件类型\n            if ((flag &amp; FLAG_EVENT) != 0) &#123;\n                // 设置心跳事件到 Request 对象中\n                req.setEvent(Request.HEARTBEAT_EVENT);\n            &#125;\n            try &#123;\n                Object data;\n                if (req.isHeartbeat()) &#123;\n                    // 对心跳包进行解码，该方法已被标注为废弃\n                    data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                &#125; else if (req.isEvent()) &#123;\n                    // 对事件数据进行解码\n                    data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                &#125; else &#123;\n                    DecodeableRpcInvocation inv;\n                    // 根据 url 参数判断是否在 IO 线程上对消息体进行解码\n                    if (channel.getUrl().getParameter(\n                            Constants.DECODE_IN_IO_THREAD_KEY,\n                            Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;\n                        inv = new DecodeableRpcInvocation(channel, req, is, proto);\n                        // 在当前线程，也就是 IO 线程上进行后续的解码工作。此工作完成后，可将\n                        // 调用方法名、attachment、以及调用参数解析出来\n                        inv.decode();\n                    &#125; else &#123;\n                        // 仅创建 DecodeableRpcInvocation 对象，但不在当前线程上执行解码逻辑\n                        inv = new DecodeableRpcInvocation(channel, req,\n                                new UnsafeByteArrayInputStream(readMessageData(is)), proto);\n                    &#125;\n                    data = inv;\n                &#125;\n                \n                // 设置 data 到 Request 对象中\n                req.setData(data);\n            &#125; catch (Throwable t) &#123;\n                // 若解码过程中出现异常，则将 broken 字段设为 true，\n                // 并将异常对象设置到 Reqeust 对象中\n                req.setBroken(true);\n                req.setData(t);\n            &#125;\n            return req;\n        &#125;\n    &#125;\n&#125;\n\n如上，decodeBody 对部分字段进行了解码，并将解码得到的字段封装到 Request 中。随后会调用 DecodeableRpcInvocation 的 decode 方法进行后续的解码工作。此工作完成后，可将调用方法名、attachment、以及调用参数解析出来。下面我们来看一下 DecodeableRpcInvocation 的 decode 方法逻辑。\npublic class DecodeableRpcInvocation extends RpcInvocation implements Codec, Decodeable &#123;\n    \n\t@Override\n    public Object decode(Channel channel, InputStream input) throws IOException &#123;\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n\n        // 通过反序列化得到 dubbo version，并保存到 attachments 变量中\n        String dubboVersion = in.readUTF();\n        request.setVersion(dubboVersion);\n        setAttachment(Constants.DUBBO_VERSION_KEY, dubboVersion);\n\n        // 通过反序列化得到 path，version，并保存到 attachments 变量中\n        setAttachment(Constants.PATH_KEY, in.readUTF());\n        setAttachment(Constants.VERSION_KEY, in.readUTF());\n\n        // 通过反序列化得到调用方法名\n        setMethodName(in.readUTF());\n        try &#123;\n            Object[] args;\n            Class&lt;?>[] pts;\n            // 通过反序列化得到参数类型字符串，比如 Ljava/lang/String;\n            String desc = in.readUTF();\n            if (desc.length() == 0) &#123;\n                pts = DubboCodec.EMPTY_CLASS_ARRAY;\n                args = DubboCodec.EMPTY_OBJECT_ARRAY;\n            &#125; else &#123;\n                // 将 desc 解析为参数类型数组\n                pts = ReflectUtils.desc2classArray(desc);\n                args = new Object[pts.length];\n                for (int i = 0; i &lt; args.length; i++) &#123;\n                    try &#123;\n                        // 解析运行时参数\n                        args[i] = in.readObject(pts[i]);\n                    &#125; catch (Exception e) &#123;\n                        if (log.isWarnEnabled()) &#123;\n                            log.warn(\"Decode argument failed: \" + e.getMessage(), e);\n                        &#125;\n                    &#125;\n                &#125;\n            &#125;\n            \n            // 设置参数类型数组\n            setParameterTypes(pts);\n\n            // 通过反序列化得到原 attachment 的内容\n            Map&lt;String, String> map = (Map&lt;String, String>) in.readObject(Map.class);\n            if (map != null &amp;&amp; map.size() > 0) &#123;\n                Map&lt;String, String> attachment = getAttachments();\n                if (attachment == null) &#123;\n                    attachment = new HashMap&lt;String, String>();\n                &#125;\n                // 将 map 与当前对象中的 attachment 集合进行融合\n                attachment.putAll(map);\n                setAttachments(attachment);\n            &#125;\n            \n            // 对 callback 类型的参数进行处理\n            for (int i = 0; i &lt; args.length; i++) &#123;\n                args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]);\n            &#125;\n\n            // 设置参数列表\n            setArguments(args);\n\n        &#125; catch (ClassNotFoundException e) &#123;\n            throw new IOException(StringUtils.toString(\"Read invocation data failed.\", e));\n        &#125; finally &#123;\n            if (in instanceof Cleanable) &#123;\n                ((Cleanable) in).cleanup();\n            &#125;\n        &#125;\n        return this;\n    &#125;\n&#125;\n\n上面的方法通过反序列化将诸如 path、version、调用方法名、参数列表等信息依次解析出来，并设置到相应的字段中，最终得到一个具有完整调用信息的 DecodeableRpcInvocation 对象。\n到这里，请求数据解码的过程就分析完了。此时我们得到了一个 Request 对象，这个对象会被传送到下一个入站处理器中，我们继续往下看。\n\n2.3.2 调用服务解码器将数据包解析成 Request 对象后，NettyHandler 的 messageReceived 方法紧接着会收到这个对象，并将这个对象继续向下传递。这期间该对象会被依次传递给 NettyServer、MultiMessageHandler、HeartbeatHandler 以及 AllChannelHandler。最后由 AllChannelHandler 将该对象封装到 Runnable 实现类对象中，并将 Runnable 放入线程池中执行后续的调用逻辑。整个调用栈如下：\nNettyHandler#messageReceived(ChannelHandlerContext, MessageEvent)\n  —&gt; AbstractPeer#received(Channel, Object)\n    —&gt; MultiMessageHandler#received(Channel, Object)\n      —&gt; HeartbeatHandler#received(Channel, Object)\n        —&gt; AllChannelHandler#received(Channel, Object)\n          —&gt; ExecutorService#execute(Runnable)    &#x2F;&#x2F; 由线程池执行后续的调用逻辑\n\n考虑到篇幅，以及很多中间调用的逻辑并非十分重要，所以这里就不对调用栈中的每个方法都进行分析了。这里我们直接分析调用栈中的分析第一个和最后一个调用方法逻辑。如下：\n@Sharable\npublic class NettyHandler extends SimpleChannelHandler &#123;\n    \n    private final Map&lt;String, Channel> channels = new ConcurrentHashMap&lt;String, Channel>();\n\n    private final URL url;\n\n    private final ChannelHandler handler;\n    \n    public NettyHandler(URL url, ChannelHandler handler) &#123;\n        if (url == null) &#123;\n            throw new IllegalArgumentException(\"url == null\");\n        &#125;\n        if (handler == null) &#123;\n            throw new IllegalArgumentException(\"handler == null\");\n        &#125;\n        this.url = url;\n        \n        // 这里的 handler 类型为 NettyServer\n        this.handler = handler;\n    &#125;\n    \n\tpublic void messageReceived(ChannelHandlerContext ctx, MessageEvent e) throws Exception &#123;\n        // 获取 NettyChannel\n        NettyChannel channel = NettyChannel.getOrAddChannel(ctx.getChannel(), url, handler);\n        try &#123;\n            // 继续向下调用\n            handler.received(channel, e.getMessage());\n        &#125; finally &#123;\n            NettyChannel.removeChannelIfDisconnected(ctx.getChannel());\n        &#125;\n    &#125;\n&#125;\n\n如上，NettyHandler 中的 messageReceived 逻辑比较简单。首先根据一些信息获取 NettyChannel 实例，然后将 NettyChannel 实例以及 Request 对象向下传递。下面再来看看 AllChannelHandler 的逻辑，在详细分析代码之前，我们先来了解一下 Dubbo 中的线程派发模型。\n\n2.3.2.1 线程派发模型Dubbo 将底层通信框架中接收请求的线程称为 IO 线程。如果一些事件处理逻辑可以很快执行完，比如只在内存打一个标记，此时直接在 IO 线程上执行该段逻辑即可。但如果事件的处理逻辑比较耗时，比如该段逻辑会发起数据库查询或者 HTTP 请求。此时我们就不应该让事件处理逻辑在 IO 线程上执行，而是应该派发到线程池中去执行。原因也很简单，IO 线程主要用于接收请求，如果 IO 线程被占满，将导致它不能接收新的请求。\n以上就是线程派发的背景，下面我们再来通过 Dubbo 调用图，看一下线程派发器所处的位置。\n\n如上图，红框中的 Dispatcher 就是线程派发器。需要说明的是，Dispatcher 真实的职责创建具有线程派发能力的 ChannelHandler，比如 AllChannelHandler、MessageOnlyChannelHandler 和 ExecutionChannelHandler 等，其本身并不具备线程派发能力。Dubbo 支持 5 种不同的线程派发策略，下面通过一个表格列举一下。\n\n\n\n策略\n用途\n\n\n\nall\n所有消息都派发到线程池，包括请求，响应，连接事件，断开事件等\n\n\ndirect\n所有消息都不派发到线程池，全部在 IO 线程上直接执行\n\n\nmessage\n只有请求和响应消息派发到线程池，其它消息均在 IO 线程上执行\n\n\nexecution\n只有请求消息派发到线程池，不含响应。其它消息均在 IO 线程上执行\n\n\nconnection\n在 IO 线程上，将连接断开事件放入队列，有序逐个执行，其它消息派发到线程池\n\n\n默认配置下，Dubbo 使用 all 派发策略，即将所有的消息都派发到线程池中。下面我们来分析一下 AllChannelHandler 的代码。\npublic class AllChannelHandler extends WrappedChannelHandler &#123;\n\n    public AllChannelHandler(ChannelHandler handler, URL url) &#123;\n        super(handler, url);\n    &#125;\n\n    /** 处理连接事件 */\n    @Override\n    public void connected(Channel channel) throws RemotingException &#123;\n        // 获取线程池\n        ExecutorService cexecutor = getExecutorService();\n        try &#123;\n            // 将连接事件派发到线程池中处理\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));\n        &#125; catch (Throwable t) &#123;\n            throw new ExecutionException(..., \" error when process connected event .\", t);\n        &#125;\n    &#125;\n\n    /** 处理断开事件 */\n    @Override\n    public void disconnected(Channel channel) throws RemotingException &#123;\n        ExecutorService cexecutor = getExecutorService();\n        try &#123;\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));\n        &#125; catch (Throwable t) &#123;\n            throw new ExecutionException(..., \"error when process disconnected event .\", t);\n        &#125;\n    &#125;\n\n    /** 处理请求和响应消息，这里的 message 变量类型可能是 Request，也可能是 Response */\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException &#123;\n        ExecutorService cexecutor = getExecutorService();\n        try &#123;\n            // 将请求和响应消息派发到线程池中处理\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));\n        &#125; catch (Throwable t) &#123;\n            if(message instanceof Request &amp;&amp; t instanceof RejectedExecutionException)&#123;\n                Request request = (Request)message;\n                // 如果通信方式为双向通信，此时将 Server side ... threadpool is exhausted \n                // 错误信息封装到 Response 中，并返回给服务消费方。\n                if(request.isTwoWay())&#123;\n                    String msg = \"Server side(\" + url.getIp() + \",\" + url.getPort() \n                        + \") threadpool is exhausted ,detail msg:\" + t.getMessage();\n                    Response response = new Response(request.getId(), request.getVersion());\n                    response.setStatus(Response.SERVER_THREADPOOL_EXHAUSTED_ERROR);\n                    response.setErrorMessage(msg);\n                    // 返回包含错误信息的 Response 对象\n                    channel.send(response);\n                    return;\n                &#125;\n            &#125;\n            throw new ExecutionException(..., \" error when process received event .\", t);\n        &#125;\n    &#125;\n\n    /** 处理异常信息 */\n    @Override\n    public void caught(Channel channel, Throwable exception) throws RemotingException &#123;\n        ExecutorService cexecutor = getExecutorService();\n        try &#123;\n            cexecutor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));\n        &#125; catch (Throwable t) &#123;\n            throw new ExecutionException(..., \"error when process caught event ...\");\n        &#125;\n    &#125;\n&#125;\n\n如上，请求对象会被封装 ChannelEventRunnable 中，ChannelEventRunnable 将会是服务调用过程的新起点。所以接下来我们以 ChannelEventRunnable 为起点向下探索。\n\n2.3.2.2 调用服务本小节，我们从 ChannelEventRunnable 开始分析，该类的主要代码如下：\npublic class ChannelEventRunnable implements Runnable &#123;\n    \n    private final ChannelHandler handler;\n    private final Channel channel;\n    private final ChannelState state;\n    private final Throwable exception;\n    private final Object message;\n    \n    @Override\n    public void run() &#123;\n        // 检测通道状态，对于请求或响应消息，此时 state = RECEIVED\n        if (state == ChannelState.RECEIVED) &#123;\n            try &#123;\n                // 将 channel 和 message 传给 ChannelHandler 对象，进行后续的调用\n                handler.received(channel, message);\n            &#125; catch (Exception e) &#123;\n                logger.warn(\"... operation error, channel is ... message is ...\");\n            &#125;\n        &#125; \n        \n        // 其他消息类型通过 switch 进行处理\n        else &#123;\n            switch (state) &#123;\n            case CONNECTED:\n                try &#123;\n                    handler.connected(channel);\n                &#125; catch (Exception e) &#123;\n                    logger.warn(\"... operation error, channel is ...\");\n                &#125;\n                break;\n            case DISCONNECTED:\n                // ...\n            case SENT:\n                // ...\n            case CAUGHT:\n                // ...\n            default:\n                logger.warn(\"unknown state: \" + state + \", message is \" + message);\n            &#125;\n        &#125;\n\n    &#125;\n&#125;\n\n如上，请求和响应消息出现频率明显比其他类型消息高，所以这里对该类型的消息进行了针对性判断。ChannelEventRunnable 仅是一个中转站，它的 run 方法中并不包含具体的调用逻辑，仅用于将参数传给其他 ChannelHandler 对象进行处理，该对象类型为 DecodeHandler。\npublic class DecodeHandler extends AbstractChannelHandlerDelegate &#123;\n\n    public DecodeHandler(ChannelHandler handler) &#123;\n        super(handler);\n    &#125;\n\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException &#123;\n        if (message instanceof Decodeable) &#123;\n            // 对 Decodeable 接口实现类对象进行解码\n            decode(message);\n        &#125;\n\n        if (message instanceof Request) &#123;\n            // 对 Request 的 data 字段进行解码\n            decode(((Request) message).getData());\n        &#125;\n\n        if (message instanceof Response) &#123;\n            // 对 Request 的 result 字段进行解码\n            decode(((Response) message).getResult());\n        &#125;\n\n        // 执行后续逻辑\n        handler.received(channel, message);\n    &#125;\n\n    private void decode(Object message) &#123;\n        // Decodeable 接口目前有两个实现类，\n        // 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult\n        if (message != null &amp;&amp; message instanceof Decodeable) &#123;\n            try &#123;\n                // 执行解码逻辑\n                ((Decodeable) message).decode();\n            &#125; catch (Throwable e) &#123;\n                if (log.isWarnEnabled()) &#123;\n                    log.warn(\"Call Decodeable.decode failed: \" + e.getMessage(), e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n\nDecodeHandler 主要是包含了一些解码逻辑。2.2.1 节分析请求解码时说过，请求解码可在 IO 线程上执行，也可在线程池中执行，这个取决于运行时配置。DecodeHandler 存在的意义就是保证请求或响应对象可在线程池中被解码。解码完毕后，完全解码后的 Request 对象会继续向后传递，下一站是 HeaderExchangeHandler。\npublic class HeaderExchangeHandler implements ChannelHandlerDelegate &#123;\n\n    private final ExchangeHandler handler;\n\n    public HeaderExchangeHandler(ExchangeHandler handler) &#123;\n        if (handler == null) &#123;\n            throw new IllegalArgumentException(\"handler == null\");\n        &#125;\n        this.handler = handler;\n    &#125;\n\n    @Override\n    public void received(Channel channel, Object message) throws RemotingException &#123;\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        try &#123;\n            // 处理请求对象\n            if (message instanceof Request) &#123;\n                Request request = (Request) message;\n                if (request.isEvent()) &#123;\n                    // 处理事件\n                    handlerEvent(channel, request);\n                &#125; \n                // 处理普通的请求\n                else &#123;\n                    // 双向通信\n                    if (request.isTwoWay()) &#123;\n                        // 向后调用服务，并得到调用结果\n                        Response response = handleRequest(exchangeChannel, request);\n                        // 将调用结果返回给服务消费端\n                        channel.send(response);\n                    &#125; \n                    // 如果是单向通信，仅向后调用指定服务即可，无需返回调用结果\n                    else &#123;\n                        handler.received(exchangeChannel, request.getData());\n                    &#125;\n                &#125;\n            &#125;      \n            // 处理响应对象，服务消费方会执行此处逻辑，后面分析\n            else if (message instanceof Response) &#123;\n                handleResponse(channel, (Response) message);\n            &#125; else if (message instanceof String) &#123;\n                // telnet 相关，忽略\n            &#125; else &#123;\n                handler.received(exchangeChannel, message);\n            &#125;\n        &#125; finally &#123;\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        &#125;\n    &#125;\n\n    Response handleRequest(ExchangeChannel channel, Request req) throws RemotingException &#123;\n        Response res = new Response(req.getId(), req.getVersion());\n        // 检测请求是否合法，不合法则返回状态码为 BAD_REQUEST 的响应\n        if (req.isBroken()) &#123;\n            Object data = req.getData();\n\n            String msg;\n            if (data == null)\n                msg = null;\n            else if\n                (data instanceof Throwable) msg = StringUtils.toString((Throwable) data);\n            else\n                msg = data.toString();\n            res.setErrorMessage(\"Fail to decode request due to: \" + msg);\n            // 设置 BAD_REQUEST 状态\n            res.setStatus(Response.BAD_REQUEST);\n\n            return res;\n        &#125;\n        \n        // 获取 data 字段值，也就是 RpcInvocation 对象\n        Object msg = req.getData();\n        try &#123;\n            // 继续向下调用\n            Object result = handler.reply(channel, msg);\n            // 设置 OK 状态码\n            res.setStatus(Response.OK);\n            // 设置调用结果\n            res.setResult(result);\n        &#125; catch (Throwable e) &#123;\n            // 若调用过程出现异常，则设置 SERVICE_ERROR，表示服务端异常\n            res.setStatus(Response.SERVICE_ERROR);\n            res.setErrorMessage(StringUtils.toString(e));\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n到这里，我们看到了比较清晰的请求和响应逻辑。对于双向通信，HeaderExchangeHandler 首先向后进行调用，得到调用结果。然后将调用结果封装到 Response 对象中，最后再将该对象返回给服务消费方。如果请求不合法，或者调用失败，则将错误信息封装到 Response 对象中，并返回给服务消费方。接下来我们继续向后分析，把剩余的调用过程分析完。下面分析定义在 DubboProtocol 类中的匿名类对象逻辑，如下：\npublic class DubboProtocol extends AbstractProtocol &#123;\n\n    public static final String NAME = \"dubbo\";\n    \n    private ExchangeHandler requestHandler = new ExchangeHandlerAdapter() &#123;\n\n        @Override\n        public Object reply(ExchangeChannel channel, Object message) throws RemotingException &#123;\n            if (message instanceof Invocation) &#123;\n                Invocation inv = (Invocation) message;\n                // 获取 Invoker 实例\n                Invoker&lt;?> invoker = getInvoker(channel, inv);\n                if (Boolean.TRUE.toString().equals(inv.getAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) &#123;\n                    // 回调相关，忽略\n                &#125;\n                RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());\n                // 通过 Invoker 调用具体的服务\n                return invoker.invoke(inv);\n            &#125;\n            throw new RemotingException(channel, \"Unsupported request: ...\");\n        &#125;\n        \n        // 忽略其他方法\n    &#125;\n    \n    Invoker&lt;?> getInvoker(Channel channel, Invocation inv) throws RemotingException &#123;\n        // 忽略回调和本地存根相关逻辑\n        // ...\n        \n        int port = channel.getLocalAddress().getPort();\n        \n        // 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：\n        //   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880\n        String serviceKey = serviceKey(port, path, inv.getAttachments().get(Constants.VERSION_KEY), inv.getAttachments().get(Constants.GROUP_KEY));\n\n        // 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，\n        // 服务导出过程中会将 &lt;serviceKey, DubboExporter> 映射关系存储到 exporterMap 集合中\n        DubboExporter&lt;?> exporter = (DubboExporter&lt;?>) exporterMap.get(serviceKey);\n\n        if (exporter == null)\n            throw new RemotingException(channel, \"Not found exported service ...\");\n\n        // 获取 Invoker 对象，并返回\n        return exporter.getInvoker();\n    &#125;\n    \n    // 忽略其他方法\n&#125;\n\n以上逻辑用于获取与指定服务对应的 Invoker 实例，并通过 Invoker 的 invoke 方法调用服务逻辑。invoke 方法定义在 AbstractProxyInvoker 中，代码如下。\npublic abstract class AbstractProxyInvoker&lt;T> implements Invoker&lt;T> &#123;\n\n    @Override\n    public Result invoke(Invocation invocation) throws RpcException &#123;\n        try &#123;\n            // 调用 doInvoke 执行后续的调用，并将调用结果封装到 RpcResult 中，并\n            return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));\n        &#125; catch (InvocationTargetException e) &#123;\n            return new RpcResult(e.getTargetException());\n        &#125; catch (Throwable e) &#123;\n            throw new RpcException(\"Failed to invoke remote proxy method ...\");\n        &#125;\n    &#125;\n    \n    protected abstract Object doInvoke(T proxy, String methodName, Class&lt;?>[] parameterTypes, Object[] arguments) throws Throwable;\n&#125;\n\n如上，doInvoke 是一个抽象方法，这个需要由具体的 Invoker 实例实现。Invoker 实例是在运行时通过 JavassistProxyFactory 创建的，创建逻辑如下：\npublic class JavassistProxyFactory extends AbstractProxyFactory &#123;\n    \n    // 省略其他方法\n\n    @Override\n    public &lt;T> Invoker&lt;T> getInvoker(T proxy, Class&lt;T> type, URL url) &#123;\n        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type);\n        // 创建匿名类对象\n        return new AbstractProxyInvoker&lt;T>(proxy, type, url) &#123;\n            @Override\n            protected Object doInvoke(T proxy, String methodName,\n                                      Class&lt;?>[] parameterTypes,\n                                      Object[] arguments) throws Throwable &#123;\n                // 调用 invokeMethod 方法进行后续的调用\n                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n            &#125;\n        &#125;;\n    &#125;\n&#125;\n\nWrapper 是一个抽象类，其中 invokeMethod 是一个抽象方法。Dubbo 会在运行时通过 Javassist 框架为 Wrapper 生成实现类，并实现 invokeMethod 方法，该方法最终会根据调用信息调用具体的服务。以 DemoServiceImpl 为例，Javassist 为其生成的代理类如下。\n/** Wrapper0 是在运行时生成的，大家可使用 Arthas 进行反编译 */\npublic class Wrapper0 extends Wrapper implements ClassGenerator.DC &#123;\n    public static String[] pns;\n    public static Map pts;\n    public static String[] mns;\n    public static String[] dmns;\n    public static Class[] mts0;\n\n    // 省略其他方法\n\n    public Object invokeMethod(Object object, String string, Class[] arrclass, Object[] arrobject) throws InvocationTargetException &#123;\n        DemoService demoService;\n        try &#123;\n            // 类型转换\n            demoService = (DemoService)object;\n        &#125;\n        catch (Throwable throwable) &#123;\n            throw new IllegalArgumentException(throwable);\n        &#125;\n        try &#123;\n            // 根据方法名调用指定的方法\n            if (\"sayHello\".equals(string) &amp;&amp; arrclass.length == 1) &#123;\n                return demoService.sayHello((String)arrobject[0]);\n            &#125;\n        &#125;\n        catch (Throwable throwable) &#123;\n            throw new InvocationTargetException(throwable);\n        &#125;\n        throw new NoSuchMethodException(new StringBuffer().append(\"Not found method \\\"\").append(string).append(\"\\\" in class com.alibaba.dubbo.demo.DemoService.\").toString());\n    &#125;\n&#125;\n\n到这里，整个服务调用过程就分析完了。最后把调用过程贴出来，如下：\nChannelEventRunnable#run()\n  —&gt; DecodeHandler#received(Channel, Object)\n    —&gt; HeaderExchangeHandler#received(Channel, Object)\n      —&gt; HeaderExchangeHandler#handleRequest(ExchangeChannel, Request)\n        —&gt; DubboProtocol.requestHandler#reply(ExchangeChannel, Object)\n          —&gt; Filter#invoke(Invoker, Invocation)\n            —&gt; AbstractProxyInvoker#invoke(Invocation)\n              —&gt; Wrapper0#invokeMethod(Object, String, Class[], Object[])\n                —&gt; DemoServiceImpl#sayHello(String)\n\n\n2.4 服务提供方返回调用结果服务提供方调用指定服务后，会将调用结果封装到 Response 对象中，并将该对象返回给服务消费方。服务提供方也是通过 NettyChannel 的 send 方法将 Response 对象返回，这个方法在 2.2.1 节分析过，这里就不在重复分析了。本节我们仅需关注 Response 对象的编码过程即可，这里仍然省略一些中间调用，直接分析具体的编码逻辑。\npublic class ExchangeCodec extends TelnetCodec &#123;\n\tpublic void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException &#123;\n        if (msg instanceof Request) &#123;\n            encodeRequest(channel, buffer, (Request) msg);\n        &#125; else if (msg instanceof Response) &#123;\n            // 对响应对象进行编码\n            encodeResponse(channel, buffer, (Response) msg);\n        &#125; else &#123;\n            super.encode(channel, buffer, msg);\n        &#125;\n    &#125;\n    \n    protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response res) throws IOException &#123;\n        int savedWriteIndex = buffer.writerIndex();\n        try &#123;\n            Serialization serialization = getSerialization(channel);\n            // 创建消息头字节数组\n            byte[] header = new byte[HEADER_LENGTH];\n            // 设置魔数\n            Bytes.short2bytes(MAGIC, header);\n            // 设置序列化器编号\n            header[2] = serialization.getContentTypeId();\n            if (res.isHeartbeat()) header[2] |= FLAG_EVENT;\n            // 获取响应状态\n            byte status = res.getStatus();\n            // 设置响应状态\n            header[3] = status;\n            // 设置请求编号\n            Bytes.long2bytes(res.getId(), header, 4);\n\n            // 更新 writerIndex，为消息头预留 16 个字节的空间\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);\n            ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);\n            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);\n           \n            if (status == Response.OK) &#123;\n                if (res.isHeartbeat()) &#123;\n                    // 对心跳响应结果进行序列化，已废弃\n                    encodeHeartbeatData(channel, out, res.getResult());\n                &#125; else &#123;\n                    // 对调用结果进行序列化\n                    encodeResponseData(channel, out, res.getResult(), res.getVersion());\n                &#125;\n            &#125; else &#123; \n                // 对错误信息进行序列化\n                out.writeUTF(res.getErrorMessage())\n            &#125;;\n            out.flushBuffer();\n            if (out instanceof Cleanable) &#123;\n                ((Cleanable) out).cleanup();\n            &#125;\n            bos.flush();\n            bos.close();\n\n            // 获取写入的字节数，也就是消息体长度\n            int len = bos.writtenBytes();\n            checkPayload(channel, len);\n            \n            // 将消息体长度写入到消息头中\n            Bytes.int2bytes(len, header, 12);\n            // 将 buffer 指针移动到 savedWriteIndex，为写消息头做准备\n            buffer.writerIndex(savedWriteIndex);\n            // 从 savedWriteIndex 下标处写入消息头\n            buffer.writeBytes(header); \n            // 设置新的 writerIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度\n            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);\n        &#125; catch (Throwable t) &#123;\n            // 异常处理逻辑不是很难理解，但是代码略多，这里忽略了\n        &#125;\n    &#125;\n&#125;\n\npublic class DubboCodec extends ExchangeCodec implements Codec2 &#123;\n    \n\tprotected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException &#123;\n        Result result = (Result) data;\n        // 检测当前协议版本是否支持带有 attachment 集合的 Response 对象\n        boolean attach = Version.isSupportResponseAttachment(version);\n        Throwable th = result.getException();\n        \n        // 异常信息为空\n        if (th == null) &#123;\n            Object ret = result.getValue();\n            // 调用结果为空\n            if (ret == null) &#123;\n                // 序列化响应类型\n                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);\n            &#125; \n            // 调用结果非空\n            else &#123;\n                // 序列化响应类型\n                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);\n                // 序列化调用结果\n                out.writeObject(ret);\n            &#125;\n        &#125; \n        // 异常信息非空\n        else &#123;\n            // 序列化响应类型\n            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);\n            // 序列化异常对象\n            out.writeObject(th);\n        &#125;\n\n        if (attach) &#123;\n            // 记录 Dubbo 协议版本\n            result.getAttachments().put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n            // 序列化 attachments 集合\n            out.writeObject(result.getAttachments());\n        &#125;\n    &#125;\n&#125;\n\n以上就是 Response 对象编码的过程，和前面分析的 Request 对象编码过程很相似。如果大家能看 Request 对象的编码逻辑，那么这里的 Response 对象的编码逻辑也不难理解，就不多说了。接下来我们再来分析双向通信的最后一环 —— 服务消费方接收调用结果。\n\n2.5 服务消费方接收调用结果服务消费方在收到响应数据后，首先要做的事情是对响应数据进行解码，得到 Response 对象。然后再将该对象传递给下一个入站处理器，这个入站处理器就是 NettyHandler。接下来 NettyHandler 会将这个对象继续向下传递，最后 AllChannelHandler 的 received 方法会收到这个对象，并将这个对象派发到线程池中。这个过程和服务提供方接收请求的过程是一样的，因此这里就不重复分析了。本节我们重点分析两个方面的内容，一是响应数据的解码过程，二是 Dubbo 如何将调用结果传递给用户线程的。下面先来分析响应数据的解码过程。\n\n2.5.1 响应数据解码响应数据解码逻辑主要的逻辑封装在 DubboCodec 中，我们直接分析这个类的代码。如下：\npublic class DubboCodec extends ExchangeCodec implements Codec2 &#123;\n\n    @Override\n    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException &#123;\n        byte flag = header[2], proto = (byte) (flag &amp; SERIALIZATION_MASK);\n        Serialization s = CodecSupport.getSerialization(channel.getUrl(), proto);\n        // 获取请求编号\n        long id = Bytes.bytes2long(header, 4);\n        // 检测消息类型，若下面的条件成立，表明消息类型为 Response\n        if ((flag &amp; FLAG_REQUEST) == 0) &#123;\n            // 创建 Response 对象\n            Response res = new Response(id);\n            // 检测事件标志位\n            if ((flag &amp; FLAG_EVENT) != 0) &#123;\n                // 设置心跳事件\n                res.setEvent(Response.HEARTBEAT_EVENT);\n            &#125;\n            // 获取响应状态\n            byte status = header[3];\n            // 设置响应状态\n            res.setStatus(status);\n            \n            // 如果响应状态为 OK，表明调用过程正常\n            if (status == Response.OK) &#123;\n                try &#123;\n                    Object data;\n                    if (res.isHeartbeat()) &#123;\n                        // 反序列化心跳数据，已废弃\n                        data = decodeHeartbeatData(channel, deserialize(s, channel.getUrl(), is));\n                    &#125; else if (res.isEvent()) &#123;\n                        // 反序列化事件数据\n                        data = decodeEventData(channel, deserialize(s, channel.getUrl(), is));\n                    &#125; else &#123;\n                        DecodeableRpcResult result;\n                        // 根据 url 参数决定是否在 IO 线程上执行解码逻辑\n                        if (channel.getUrl().getParameter(\n                                Constants.DECODE_IN_IO_THREAD_KEY,\n                                Constants.DEFAULT_DECODE_IN_IO_THREAD)) &#123;\n                            // 创建 DecodeableRpcResult 对象\n                            result = new DecodeableRpcResult(channel, res, is,\n                                    (Invocation) getRequestData(id), proto);\n                            // 进行后续的解码工作\n                            result.decode();\n                        &#125; else &#123;\n                            // 创建 DecodeableRpcResult 对象\n                            result = new DecodeableRpcResult(channel, res,\n                                    new UnsafeByteArrayInputStream(readMessageData(is)),\n                                    (Invocation) getRequestData(id), proto);\n                        &#125;\n                        data = result;\n                    &#125;\n                    \n                    // 设置 DecodeableRpcResult 对象到 Response 对象中\n                    res.setResult(data);\n                &#125; catch (Throwable t) &#123;\n                    // 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中\n                    res.setStatus(Response.CLIENT_ERROR);\n                    res.setErrorMessage(StringUtils.toString(t));\n                &#125;\n            &#125; \n            // 响应状态非 OK，表明调用过程出现了异常\n            else &#123;\n                // 反序列化异常信息，并设置到 Response 对象中\n                res.setErrorMessage(deserialize(s, channel.getUrl(), is).readUTF());\n            &#125;\n            return res;\n        &#125; else &#123;\n            // 对请求数据进行解码，前面已分析过，此处忽略\n        &#125;\n    &#125;\n&#125;\n\n以上就是响应数据的解码过程，上面逻辑看起来是不是似曾相识。对的，我们在前面章节分析过 DubboCodec 的 decodeBody 方法中关于请求数据的解码过程，该过程和响应数据的解码过程很相似。下面，我们继续分析调用结果的反序列化过程，如下：\npublic class DecodeableRpcResult extends RpcResult implements Codec, Decodeable &#123;\n    \n    private Invocation invocation;\n\t\n    @Override\n    public void decode() throws Exception &#123;\n        if (!hasDecoded &amp;&amp; channel != null &amp;&amp; inputStream != null) &#123;\n            try &#123;\n                // 执行反序列化操作\n                decode(channel, inputStream);\n            &#125; catch (Throwable e) &#123;\n                // 反序列化失败，设置 CLIENT_ERROR 状态到 Response 对象中\n                response.setStatus(Response.CLIENT_ERROR);\n                // 设置异常信息\n                response.setErrorMessage(StringUtils.toString(e));\n            &#125; finally &#123;\n                hasDecoded = true;\n            &#125;\n        &#125;\n    &#125;\n    \n    @Override\n    public Object decode(Channel channel, InputStream input) throws IOException &#123;\n        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)\n                .deserialize(channel.getUrl(), input);\n        \n        // 反序列化响应类型\n        byte flag = in.readByte();\n        switch (flag) &#123;\n            case DubboCodec.RESPONSE_NULL_VALUE:\n                break;\n            case DubboCodec.RESPONSE_VALUE:\n                // ...\n                break;\n            case DubboCodec.RESPONSE_WITH_EXCEPTION:\n                // ...\n                break;\n                \n            // 返回值为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:\n                try &#123;\n                    // 反序列化 attachments 集合，并存储起来 \n                    setAttachments((Map&lt;String, String>) in.readObject(Map.class));\n                &#125; catch (ClassNotFoundException e) &#123;\n                    throw new IOException(StringUtils.toString(\"Read response data failed.\", e));\n                &#125;\n                break;\n                \n            // 返回值不为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:\n                try &#123;\n                    // 获取返回值类型\n                    Type[] returnType = RpcUtils.getReturnTypes(invocation);\n                    // 反序列化调用结果，并保存起来\n                    setValue(returnType == null || returnType.length == 0 ? in.readObject() :\n                            (returnType.length == 1 ? in.readObject((Class&lt;?>) returnType[0])\n                                    : in.readObject((Class&lt;?>) returnType[0], returnType[1])));\n                    // 反序列化 attachments 集合，并存储起来\n                    setAttachments((Map&lt;String, String>) in.readObject(Map.class));\n                &#125; catch (ClassNotFoundException e) &#123;\n                    throw new IOException(StringUtils.toString(\"Read response data failed.\", e));\n                &#125;\n                break;\n                \n            // 异常对象不为空，且携带了 attachments 集合\n            case DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:\n                try &#123;\n                    // 反序列化异常对象\n                    Object obj = in.readObject();\n                    if (obj instanceof Throwable == false)\n                        throw new IOException(\"Response data error, expect Throwable, but get \" + obj);\n                    // 设置异常对象\n                    setException((Throwable) obj);\n                    // 反序列化 attachments 集合，并存储起来\n                    setAttachments((Map&lt;String, String>) in.readObject(Map.class));\n                &#125; catch (ClassNotFoundException e) &#123;\n                    throw new IOException(StringUtils.toString(\"Read response data failed.\", e));\n                &#125;\n                break;\n            default:\n                throw new IOException(\"Unknown result flag, expect '0' '1' '2', get \" + flag);\n        &#125;\n        if (in instanceof Cleanable) &#123;\n            ((Cleanable) in).cleanup();\n        &#125;\n        return this;\n    &#125;\n&#125;\n\n本篇文章所分析的源码版本为 2.6.4，该版本下的 Response 支持 attachments 集合，所以上面仅对部分 case 分支进行了注释。其他 case 分支的逻辑比被注释分支的逻辑更为简单，这里就忽略了。我们所使用的测试服务接口 DemoService 包含了一个具有返回值的方法，正常调用下，线程会进入 RESPONSE_VALUE_WITH_ATTACHMENTS 分支中。然后线程会从 invocation 变量（大家探索一下 invocation 变量的由来）中获取返回值类型，接着对调用结果进行反序列化，并将序列化后的结果存储起来。最后对 attachments 集合进行反序列化，并存到指定字段中。到此，关于响应数据的解码过程就分析完了。接下来，我们再来探索一下响应对象 Response 的去向。\n\n2.5.2 向用户线程传递调用结果响应数据解码完成后，Dubbo 会将响应对象派发到线程池上。要注意的是，线程池中的线程并非用户的调用线程，所以要想办法将响应对象从线程池线程传递到用户线程上。我们在 2.1 节分析过用户线程在发送完请求后的动作，即调用 DefaultFuture 的 get 方法等待响应对象的到来。当响应对象到来后，用户线程会被唤醒，并通过调用编号获取属于自己的响应对象。下面我们来看一下整个过程对应的代码。\npublic class HeaderExchangeHandler implements ChannelHandlerDelegate &#123;\n    \n    @Override\n    public void received(Channel channel, Object message) throws RemotingException &#123;\n        channel.setAttribute(KEY_READ_TIMESTAMP, System.currentTimeMillis());\n        ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);\n        try &#123;\n            if (message instanceof Request) &#123;\n                // 处理请求，前面已分析过，省略\n            &#125; else if (message instanceof Response) &#123;\n                // 处理响应\n                handleResponse(channel, (Response) message);\n            &#125; else if (message instanceof String) &#123;\n                // telnet 相关，忽略\n            &#125; else &#123;\n                handler.received(exchangeChannel, message);\n            &#125;\n        &#125; finally &#123;\n            HeaderExchangeChannel.removeChannelIfDisconnected(channel);\n        &#125;\n    &#125;\n\n    static void handleResponse(Channel channel, Response response) throws RemotingException &#123;\n        if (response != null &amp;&amp; !response.isHeartbeat()) &#123;\n            // 继续向下调用\n            DefaultFuture.received(channel, response);\n        &#125;\n    &#125;\n&#125;\n\npublic class DefaultFuture implements ResponseFuture &#123;  \n    \n    private final Lock lock = new ReentrantLock();\n    private final Condition done = lock.newCondition();\n    private volatile Response response;\n    \n\tpublic static void received(Channel channel, Response response) &#123;\n        try &#123;\n            // 根据调用编号从 FUTURES 集合中查找指定的 DefaultFuture 对象\n            DefaultFuture future = FUTURES.remove(response.getId());\n            if (future != null) &#123;\n                // 继续向下调用\n                future.doReceived(response);\n            &#125; else &#123;\n                logger.warn(\"The timeout response finally returned at ...\");\n            &#125;\n        &#125; finally &#123;\n            CHANNELS.remove(response.getId());\n        &#125;\n    &#125;\n\n\tprivate void doReceived(Response res) &#123;\n        lock.lock();\n        try &#123;\n            // 保存响应对象\n            response = res;\n            if (done != null) &#123;\n                // 唤醒用户线程\n                done.signal();\n            &#125;\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n        if (callback != null) &#123;\n            invokeCallback(callback);\n        &#125;\n    &#125;\n&#125;\n\n以上逻辑是将响应对象保存到相应的 DefaultFuture 实例中，然后再唤醒用户线程，随后用户线程即可从 DefaultFuture 实例中获取到相应结果。\n本篇文章在多个地方都强调过调用编号很重要，但一直没有解释原因，这里简单说明一下。一般情况下，服务消费方会并发调用多个服务，每个用户线程发送请求后，会调用不同 DefaultFuture 对象的 get 方法进行等待。 一段时间后，服务消费方的线程池会收到多个响应对象。这个时候要考虑一个问题，如何将每个响应对象传递给相应的 DefaultFuture 对象，且不出错。答案是通过调用编号。DefaultFuture 被创建时，会要求传入一个 Request 对象。此时 DefaultFuture 可从 Request 对象中获取调用编号，并将 &lt;调用编号, DefaultFuture 对象&gt; 映射关系存入到静态 Map 中，即 FUTURES。线程池中的线程在收到 Response 对象后，会根据 Response 对象中的调用编号到 FUTURES 集合中取出相应的 DefaultFuture 对象，然后再将 Response 对象设置到 DefaultFuture 对象中。最后再唤醒用户线程，这样用户线程即可从 DefaultFuture 对象中获取调用结果了。整个过程大致如下图：\n\n\n3. 总结本篇文章主要对 Dubbo 中的几种服务调用方式，以及从双向通信的角度对整个通信过程进行了详细的分析。按照通信顺序，通信过程包括服务消费方发送请求，服务提供方接收请求，服务提供方返回响应数据，服务消费方接收响应数据等过程。理解这些过程需要大家对网络编程，尤其是 Netty 有一定的了解。限于篇幅原因，本篇文章无法将服务调用的所有内容都一一进行分析。对于本篇文章未讲到或未详细分析的内容，比如服务降级、过滤器链、以及序列化等。大家若感兴趣，可自行进行分析。并将分析整理成文，分享给社区。\n本篇文章就到这里了，感谢阅读。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/refer-service/\n作者： Dubbo 官方\n本文介绍了 Dubbo 服务引用的过程和实现细节\n\n服务引用1. 简介上一篇文章详细分析了服务导出的过程，本篇文章我们趁热打铁，继续分析服务引用过程。在 Dubbo 中，我们可以通过两种方式引用远程服务。第一种是使用服务直连的方式引用服务，第二种方式是基于注册中心进行引用。服务直连的方式仅适合在调试或测试服务的场景下使用，不适合在线上环境使用。因此，本文我将重点分析通过注册中心引用服务的过程。从注册中心中获取服务配置只是服务引用过程中的一环，除此之外，服务消费者还需要经历 Invoker 创建、代理类创建等步骤。这些步骤，将在后续章节中一一进行分析。\n\n2.服务引用原理Dubbo 服务引用的时机有两个，第一个是在 Spring 容器调用 ReferenceBean 的 afterPropertiesSet 方法时引用服务，第二个是在 ReferenceBean 对应的服务被注入到其他类中时引用。这两个引用服务的时机区别在于，第一个是饿汉式的，第二个是懒汉式的。默认情况下，Dubbo 使用懒汉式引用服务。如果需要使用饿汉式，可通过配置 dubbo:reference 的 init 属性开启。下面我们按照 Dubbo 默认配置进行分析，整个分析过程从 ReferenceBean 的 getObject 方法开始。当我们的服务被注入到其他类中时，Spring 会第一时间调用 getObject 方法，并由该方法执行服务引用逻辑。按照惯例，在进行具体工作之前，需先进行配置检查与收集工作。接着根据收集到的信息决定服务用的方式，有三种，第一种是引用本地 (JVM) 服务，第二是通过直连方式引用远程服务，第三是通过注册中心引用远程服务。不管是哪种引用方式，最后都会得到一个 Invoker 实例。如果有多个注册中心，多个服务提供者，这个时候会得到一组 Invoker 实例，此时需要通过集群管理类 Cluster 将多个 Invoker 合并成一个实例。合并后的 Invoker 实例已经具备调用本地或远程服务的能力了，但并不能将此实例暴露给用户使用，这会对用户业务代码造成侵入。此时框架还需要通过代理工厂类 (ProxyFactory) 为服务接口生成代理类，并让代理类去调用 Invoker 逻辑。避免了 Dubbo 框架代码对业务代码的侵入，同时也让框架更容易使用。\n以上就是服务引用的大致原理，下面我们深入到代码中，详细分析服务引用细节。\n\n3.源码分析服务引用的入口方法为 ReferenceBean 的 getObject 方法，该方法定义在 Spring 的 FactoryBean 接口中，ReferenceBean 实现了这个方法。实现代码如下：\npublic Object getObject() throws Exception &#123;\n    return get();\n&#125;\n\npublic synchronized T get() &#123;\n    if (destroyed) &#123;\n        throw new IllegalStateException(\"Already destroyed!\");\n    &#125;\n    // 检测 ref 是否为空，为空则通过 init 方法创建\n    if (ref == null) &#123;\n        // init 方法主要用于处理配置，以及调用 createProxy 生成代理类\n        init();\n    &#125;\n    return ref;\n&#125;\n\n以上两个方法的代码比较简短，并不难理解。这里需要特别说明一下，如果你对 2.6.4 及以下版本的 getObject 方法进行调试时，会碰到比较奇怪的的问题。这里假设你使用 IDEA，且保持了 IDEA 的默认配置。当你面调试到 get 方法的if (ref == null)时，你会发现 ref 不为空，导致你无法进入到 init 方法中继续调试。导致这个现象的原因是 Dubbo 框架本身有一些小问题。该问题已经在 pull request #2754 修复了此问题，并跟随 2.6.5 版本发布了。如果你正在学习 2.6.4 及以下版本，可通过修改 IDEA 配置规避这个问题。首先 IDEA 配置弹窗中搜索 toString，然后取消Enable &#39;toString&#39; object view勾选。具体如下：\n\n\n3.1 处理配置Dubbo 提供了丰富的配置，用于调整和优化框架行为，性能等。Dubbo 在引用或导出服务时，首先会对这些配置进行检查和处理，以保证配置的正确性。配置解析逻辑封装在 ReferenceConfig 的 init 方法中，下面进行分析。\nprivate void init() &#123;\n    // 避免重复初始化\n    if (initialized) &#123;\n        return;\n    &#125;\n    initialized = true;\n    // 检测接口名合法性\n    if (interfaceName == null || interfaceName.length() == 0) &#123;\n        throw new IllegalStateException(\"interface not allow null!\");\n    &#125;\n\n    // 检测 consumer 变量是否为空，为空则创建\n    checkDefault();\n    appendProperties(this);\n    if (getGeneric() == null &amp;&amp; getConsumer() != null) &#123;\n        // 设置 generic\n        setGeneric(getConsumer().getGeneric());\n    &#125;\n\n    // 检测是否为泛化接口\n    if (ProtocolUtils.isGeneric(getGeneric())) &#123;\n        interfaceClass = GenericService.class;\n    &#125; else &#123;\n        try &#123;\n            // 加载类\n            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                    .getContextClassLoader());\n        &#125; catch (ClassNotFoundException e) &#123;\n            throw new IllegalStateException(e.getMessage(), e);\n        &#125;\n        checkInterfaceAndMethods(interfaceClass, methods);\n    &#125;\n    \n    // -------------------------------✨ 分割线1 ✨------------------------------\n\n    // 从系统变量中获取与接口名对应的属性值\n    String resolve = System.getProperty(interfaceName);\n    String resolveFile = null;\n    if (resolve == null || resolve.length() == 0) &#123;\n        // 从系统属性中获取解析文件路径\n        resolveFile = System.getProperty(\"dubbo.resolve.file\");\n        if (resolveFile == null || resolveFile.length() == 0) &#123;\n            // 从指定位置加载配置文件\n            File userResolveFile = new File(new File(System.getProperty(\"user.home\")), \"dubbo-resolve.properties\");\n            if (userResolveFile.exists()) &#123;\n                // 获取文件绝对路径\n                resolveFile = userResolveFile.getAbsolutePath();\n            &#125;\n        &#125;\n        if (resolveFile != null &amp;&amp; resolveFile.length() > 0) &#123;\n            Properties properties = new Properties();\n            FileInputStream fis = null;\n            try &#123;\n                fis = new FileInputStream(new File(resolveFile));\n                // 从文件中加载配置\n                properties.load(fis);\n            &#125; catch (IOException e) &#123;\n                throw new IllegalStateException(\"Unload ..., cause:...\");\n            &#125; finally &#123;\n                try &#123;\n                    if (null != fis) fis.close();\n                &#125; catch (IOException e) &#123;\n                    logger.warn(e.getMessage(), e);\n                &#125;\n            &#125;\n            // 获取与接口名对应的配置\n            resolve = properties.getProperty(interfaceName);\n        &#125;\n    &#125;\n    if (resolve != null &amp;&amp; resolve.length() > 0) &#123;\n        // 将 resolve 赋值给 url\n        url = resolve;\n    &#125;\n    \n    // -------------------------------✨ 分割线2 ✨------------------------------\n    if (consumer != null) &#123;\n        if (application == null) &#123;\n            // 从 consumer 中获取 Application 实例，下同\n            application = consumer.getApplication();\n        &#125;\n        if (module == null) &#123;\n            module = consumer.getModule();\n        &#125;\n        if (registries == null) &#123;\n            registries = consumer.getRegistries();\n        &#125;\n        if (monitor == null) &#123;\n            monitor = consumer.getMonitor();\n        &#125;\n    &#125;\n    if (module != null) &#123;\n        if (registries == null) &#123;\n            registries = module.getRegistries();\n        &#125;\n        if (monitor == null) &#123;\n            monitor = module.getMonitor();\n        &#125;\n    &#125;\n    if (application != null) &#123;\n        if (registries == null) &#123;\n            registries = application.getRegistries();\n        &#125;\n        if (monitor == null) &#123;\n            monitor = application.getMonitor();\n        &#125;\n    &#125;\n    \n    // 检测 Application 合法性\n    checkApplication();\n    // 检测本地存根配置合法性\n    checkStubAndMock(interfaceClass);\n    \n\t// -------------------------------✨ 分割线3 ✨------------------------------\n    \n    Map&lt;String, String> map = new HashMap&lt;String, String>();\n    Map&lt;Object, Object> attributes = new HashMap&lt;Object, Object>();\n\n    // 添加 side、协议版本信息、时间戳和进程号等信息到 map 中\n    map.put(Constants.SIDE_KEY, Constants.CONSUMER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    if (ConfigUtils.getPid() > 0) &#123;\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    &#125;\n\n    // 非泛化服务\n    if (!isGeneric()) &#123;\n        // 获取版本\n        String revision = Version.getVersion(interfaceClass, version);\n        if (revision != null &amp;&amp; revision.length() > 0) &#123;\n            map.put(\"revision\", revision);\n        &#125;\n\n        // 获取接口方法列表，并添加到 map 中\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        if (methods.length == 0) &#123;\n            map.put(\"methods\", Constants.ANY_VALUE);\n        &#125; else &#123;\n            map.put(\"methods\", StringUtils.join(new HashSet&lt;String>(Arrays.asList(methods)), \",\"));\n        &#125;\n    &#125;\n    map.put(Constants.INTERFACE_KEY, interfaceName);\n    // 将 ApplicationConfig、ConsumerConfig、ReferenceConfig 等对象的字段信息添加到 map 中\n    appendParameters(map, application);\n    appendParameters(map, module);\n    appendParameters(map, consumer, Constants.DEFAULT_KEY);\n    appendParameters(map, this);\n    \n\t// -------------------------------✨ 分割线4 ✨------------------------------\n    \n    String prefix = StringUtils.getServiceKey(map);\n    if (methods != null &amp;&amp; !methods.isEmpty()) &#123;\n        // 遍历 MethodConfig 列表\n        for (MethodConfig method : methods) &#123;\n            appendParameters(map, method, method.getName());\n            String retryKey = method.getName() + \".retry\";\n            // 检测 map 是否包含 methodName.retry\n            if (map.containsKey(retryKey)) &#123;\n                String retryValue = map.remove(retryKey);\n                if (\"false\".equals(retryValue)) &#123;\n                    // 添加重试次数配置 methodName.retries\n                    map.put(method.getName() + \".retries\", \"0\");\n                &#125;\n            &#125;\n \n            // 添加 MethodConfig 中的“属性”字段到 attributes\n            // 比如 onreturn、onthrow、oninvoke 等\n            appendAttributes(attributes, method, prefix + \".\" + method.getName());\n            checkAndConvertImplicitConfig(method, map, attributes);\n        &#125;\n    &#125;\n    \n\t// -------------------------------✨ 分割线5 ✨------------------------------\n\n    // 获取服务消费者 ip 地址\n    String hostToRegistry = ConfigUtils.getSystemProperty(Constants.DUBBO_IP_TO_REGISTRY);\n    if (hostToRegistry == null || hostToRegistry.length() == 0) &#123;\n        hostToRegistry = NetUtils.getLocalHost();\n    &#125; else if (isInvalidLocalHost(hostToRegistry)) &#123;\n        throw new IllegalArgumentException(\"Specified invalid registry ip from property...\" );\n    &#125;\n    map.put(Constants.REGISTER_IP_KEY, hostToRegistry);\n\n    // 存储 attributes 到系统上下文中\n    StaticContext.getSystemContext().putAll(attributes);\n\n    // 创建代理类\n    ref = createProxy(map);\n\n    // 根据服务名，ReferenceConfig，代理类构建 ConsumerModel，\n    // 并将 ConsumerModel 存入到 ApplicationModel 中\n    ConsumerModel consumerModel = new ConsumerModel(getUniqueServiceName(), this, ref, interfaceClass.getMethods());\n    ApplicationModel.initConsumerModel(getUniqueServiceName(), consumerModel);\n&#125;\n\n\n上面的代码很长，做的事情比较多。这里根据代码逻辑，对代码进行了分块，下面我们一起来看一下。\n首先是方法开始到分割线1之间的代码。这段代码主要用于检测 ConsumerConfig 实例是否存在，如不存在则创建一个新的实例，然后通过系统变量或 dubbo.properties 配置文件填充 ConsumerConfig 的字段。接着是检测泛化配置，并根据配置设置 interfaceClass 的值。接着来看分割线1到分割线2之间的逻辑。这段逻辑用于从系统属性或配置文件中加载与接口名相对应的配置，并将解析结果赋值给 url 字段。url 字段的作用一般是用于点对点调用。继续向下看，分割线2和分割线3之间的代码用于检测几个核心配置类是否为空，为空则尝试从其他配置类中获取。分割线3与分割线4之间的代码主要用于收集各种配置，并将配置存储到 map 中。分割线4和分割线5之间的代码用于处理 MethodConfig 实例。该实例包含了事件通知配置，比如 onreturn、onthrow、oninvoke 等。分割线5到方法结尾的代码主要用于解析服务消费者 ip，以及调用 createProxy 创建代理对象。关于该方法的详细分析，将会在接下来的章节中展开。\n\n3.2 引用服务本节我们要从 createProxy 开始看起。从字面意思上来看，createProxy 似乎只是用于创建代理对象的。但实际上并非如此，该方法还会调用其他方法构建以及合并 Invoker 实例。具体细节如下。\nprivate T createProxy(Map&lt;String, String> map) &#123;\n    URL tmpUrl = new URL(\"temp\", \"localhost\", 0, map);\n    final boolean isJvmRefer;\n    if (isInjvm() == null) &#123;\n        // url 配置被指定，则不做本地引用\n        if (url != null &amp;&amp; url.length() > 0) &#123;\n            isJvmRefer = false;\n        // 根据 url 的协议、scope 以及 injvm 等参数检测是否需要本地引用\n        // 比如如果用户显式配置了 scope=local，此时 isInjvmRefer 返回 true\n        &#125; else if (InjvmProtocol.getInjvmProtocol().isInjvmRefer(tmpUrl)) &#123;\n            isJvmRefer = true;\n        &#125; else &#123;\n            isJvmRefer = false;\n        &#125;\n    &#125; else &#123;\n        // 获取 injvm 配置值\n        isJvmRefer = isInjvm().booleanValue();\n    &#125;\n\n    // 本地引用\n    if (isJvmRefer) &#123;\n        // 生成本地引用 URL，协议为 injvm\n        URL url = new URL(Constants.LOCAL_PROTOCOL, NetUtils.LOCALHOST, 0, interfaceClass.getName()).addParameters(map);\n        // 调用 refer 方法构建 InjvmInvoker 实例\n        invoker = refprotocol.refer(interfaceClass, url);\n        \n    // 远程引用\n    &#125; else &#123;\n        // url 不为空，表明用户可能想进行点对点调用\n        if (url != null &amp;&amp; url.length() > 0) &#123;\n            // 当需要配置多个 url 时，可用分号进行分割，这里会进行切分\n            String[] us = Constants.SEMICOLON_SPLIT_PATTERN.split(url);\n            if (us != null &amp;&amp; us.length > 0) &#123;\n                for (String u : us) &#123;\n                    URL url = URL.valueOf(u);\n                    if (url.getPath() == null || url.getPath().length() == 0) &#123;\n                        // 设置接口全限定名为 url 路径\n                        url = url.setPath(interfaceName);\n                    &#125;\n                    \n                    // 检测 url 协议是否为 registry，若是，表明用户想使用指定的注册中心\n                    if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;\n                        // 将 map 转换为查询字符串，并作为 refer 参数的值添加到 url 中\n                        urls.add(url.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                    &#125; else &#123;\n                        // 合并 url，移除服务提供者的一些配置（这些配置来源于用户配置的 url 属性），\n                        // 比如线程池相关配置。并保留服务提供者的部分配置，比如版本，group，时间戳等\n                        // 最后将合并后的配置设置为 url 查询字符串中。\n                        urls.add(ClusterUtils.mergeUrl(url, map));\n                    &#125;\n                &#125;\n            &#125;\n        &#125; else &#123;\n            // 加载注册中心 url\n            List&lt;URL> us = loadRegistries(false);\n            if (us != null &amp;&amp; !us.isEmpty()) &#123;\n                for (URL u : us) &#123;\n                    URL monitorUrl = loadMonitor(u);\n                    if (monitorUrl != null) &#123;\n                        map.put(Constants.MONITOR_KEY, URL.encode(monitorUrl.toFullString()));\n                    &#125;\n                    // 添加 refer 参数到 url 中，并将 url 添加到 urls 中\n                    urls.add(u.addParameterAndEncoded(Constants.REFER_KEY, StringUtils.toQueryString(map)));\n                &#125;\n            &#125;\n\n            // 未配置注册中心，抛出异常\n            if (urls.isEmpty()) &#123;\n                throw new IllegalStateException(\"No such any registry to reference...\");\n            &#125;\n        &#125;\n\n        // 单个注册中心或服务提供者(服务直连，下同)\n        if (urls.size() == 1) &#123;\n            // 调用 RegistryProtocol 的 refer 构建 Invoker 实例\n            invoker = refprotocol.refer(interfaceClass, urls.get(0));\n            \n        // 多个注册中心或多个服务提供者，或者两者混合\n        &#125; else &#123;\n            List&lt;Invoker&lt;?>> invokers = new ArrayList&lt;Invoker&lt;?>>();\n            URL registryURL = null;\n\n            // 获取所有的 Invoker\n            for (URL url : urls) &#123;\n                // 通过 refprotocol 调用 refer 构建 Invoker，refprotocol 会在运行时\n                // 根据 url 协议头加载指定的 Protocol 实例，并调用实例的 refer 方法\n                invokers.add(refprotocol.refer(interfaceClass, url));\n                if (Constants.REGISTRY_PROTOCOL.equals(url.getProtocol())) &#123;\n                    registryURL = url;\n                &#125;\n            &#125;\n            if (registryURL != null) &#123;\n                // 如果注册中心链接不为空，则将使用 AvailableCluster\n                URL u = registryURL.addParameter(Constants.CLUSTER_KEY, AvailableCluster.NAME);\n                // 创建 StaticDirectory 实例，并由 Cluster 对多个 Invoker 进行合并\n                invoker = cluster.join(new StaticDirectory(u, invokers));\n            &#125; else &#123;\n                invoker = cluster.join(new StaticDirectory(invokers));\n            &#125;\n        &#125;\n    &#125;\n\n    Boolean c = check;\n    if (c == null &amp;&amp; consumer != null) &#123;\n        c = consumer.isCheck();\n    &#125;\n    if (c == null) &#123;\n        c = true;\n    &#125;\n    \n    // invoker 可用性检查\n    if (c &amp;&amp; !invoker.isAvailable()) &#123;\n        throw new IllegalStateException(\"No provider available for the service...\");\n    &#125;\n\n    // 生成代理类\n    return (T) proxyFactory.getProxy(invoker);\n&#125;\n\n\n上面代码很多，不过逻辑比较清晰。首先根据配置检查是否为本地调用，若是，则调用 InjvmProtocol 的 refer 方法生成 InjvmInvoker 实例。若不是，则读取直连配置项，或注册中心 url，并将读取到的 url 存储到 urls 中。然后根据 urls 元素数量进行后续操作。若 urls 元素数量为1，则直接通过 Protocol 自适应拓展类构建 Invoker 实例接口。若 urls 元素数量大于1，即存在多个注册中心或服务直连 url，此时先根据 url 构建 Invoker。然后再通过 Cluster 合并多个 Invoker，最后调用 ProxyFactory 生成代理类。Invoker 的构建过程以及代理类的过程比较重要，因此接下来将分两小节对这两个过程进行分析。\n\n3.2.1 创建 InvokerInvoker 是 Dubbo 的核心模型，代表一个可执行体。在服务提供方，Invoker 用于调用服务提供类。在服务消费方，Invoker 用于执行远程调用。Invoker 是由 Protocol 实现类构建而来。Protocol 实现类有很多，本节会分析最常用的两个，分别是 RegistryProtocol 和 DubboProtocol，其他的大家自行分析。下面先来分析 DubboProtocol 的 refer 方法源码。如下：\npublic &lt;T> Invoker&lt;T> refer(Class&lt;T> serviceType, URL url) throws RpcException &#123;\n    optimizeSerialization(url);\n    // 创建 DubboInvoker\n    DubboInvoker&lt;T> invoker = new DubboInvoker&lt;T>(serviceType, url, getClients(url), invokers);\n    invokers.add(invoker);\n    return invoker;\n&#125;\n\n\n上面方法看起来比较简单，不过这里有一个调用需要我们注意一下，即 getClients。这个方法用于获取客户端实例，实例类型为 ExchangeClient。ExchangeClient 实际上并不具备通信能力，它需要基于更底层的客户端实例进行通信。比如 NettyClient、MinaClient 等，默认情况下，Dubbo 使用 NettyClient 进行通信。接下来，我们简单看一下 getClients 方法的逻辑。\nprivate ExchangeClient[] getClients(URL url) &#123;\n    // 是否共享连接\n    boolean service_share_connect = false;\n  \t// 获取连接数，默认为0，表示未配置\n    int connections = url.getParameter(Constants.CONNECTIONS_KEY, 0);\n    // 如果未配置 connections，则共享连接\n    if (connections == 0) &#123;\n        service_share_connect = true;\n        connections = 1;\n    &#125;\n\n    ExchangeClient[] clients = new ExchangeClient[connections];\n    for (int i = 0; i &lt; clients.length; i++) &#123;\n        if (service_share_connect) &#123;\n            // 获取共享客户端\n            clients[i] = getSharedClient(url);\n        &#125; else &#123;\n            // 初始化新的客户端\n            clients[i] = initClient(url);\n        &#125;\n    &#125;\n    return clients;\n&#125;\n\n\n这里根据 connections 数量决定是获取共享客户端还是创建新的客户端实例，默认情况下，使用共享客户端实例。getSharedClient 方法中也会调用 initClient 方法，因此下面我们一起看一下这两个方法。\nprivate ExchangeClient getSharedClient(URL url) &#123;\n    String key = url.getAddress();\n    // 获取带有“引用计数”功能的 ExchangeClient\n    ReferenceCountExchangeClient client = referenceClientMap.get(key);\n    if (client != null) &#123;\n        if (!client.isClosed()) &#123;\n            // 增加引用计数\n            client.incrementAndGetCount();\n            return client;\n        &#125; else &#123;\n            referenceClientMap.remove(key);\n        &#125;\n    &#125;\n\n    locks.putIfAbsent(key, new Object());\n    synchronized (locks.get(key)) &#123;\n        if (referenceClientMap.containsKey(key)) &#123;\n            return referenceClientMap.get(key);\n        &#125;\n\n        // 创建 ExchangeClient 客户端\n        ExchangeClient exchangeClient = initClient(url);\n        // 将 ExchangeClient 实例传给 ReferenceCountExchangeClient，这里使用了装饰模式\n        client = new ReferenceCountExchangeClient(exchangeClient, ghostClientMap);\n        referenceClientMap.put(key, client);\n        ghostClientMap.remove(key);\n        locks.remove(key);\n        return client;\n    &#125;\n&#125;\n\n\n上面方法先访问缓存，若缓存未命中，则通过 initClient 方法创建新的 ExchangeClient 实例，并将该实例传给 ReferenceCountExchangeClient 构造方法创建一个带有引用计数功能的 ExchangeClient 实例。ReferenceCountExchangeClient 内部实现比较简单，就不分析了。下面我们再来看一下 initClient 方法的代码。\nprivate ExchangeClient initClient(URL url) &#123;\n\n    // 获取客户端类型，默认为 netty\n    String str = url.getParameter(Constants.CLIENT_KEY, url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_CLIENT));\n\n    // 添加编解码和心跳包参数到 url 中\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\n    // 检测客户端类型是否存在，不存在则抛出异常\n    if (str != null &amp;&amp; str.length() > 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) &#123;\n        throw new RpcException(\"Unsupported client type: ...\");\n    &#125;\n\n    ExchangeClient client;\n    try &#123;\n        // 获取 lazy 配置，并根据配置值决定创建的客户端类型\n        if (url.getParameter(Constants.LAZY_CONNECT_KEY, false)) &#123;\n            // 创建懒加载 ExchangeClient 实例\n            client = new LazyConnectExchangeClient(url, requestHandler);\n        &#125; else &#123;\n            // 创建普通 ExchangeClient 实例\n            client = Exchangers.connect(url, requestHandler);\n        &#125;\n    &#125; catch (RemotingException e) &#123;\n        throw new RpcException(\"Fail to create remoting client for service...\");\n    &#125;\n    return client;\n&#125;\n\n\ninitClient 方法首先获取用户配置的客户端类型，默认为 netty。然后检测用户配置的客户端类型是否存在，不存在则抛出异常。最后根据 lazy 配置决定创建什么类型的客户端。这里的 LazyConnectExchangeClient 代码并不是很复杂，该类会在 request 方法被调用时通过 Exchangers 的 connect 方法创建 ExchangeClient 客户端，该类的代码本节就不分析了。下面我们分析一下 Exchangers 的 connect 方法。\npublic static ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123;\n    if (url == null) &#123;\n        throw new IllegalArgumentException(\"url == null\");\n    &#125;\n    if (handler == null) &#123;\n        throw new IllegalArgumentException(\"handler == null\");\n    &#125;\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    // 获取 Exchanger 实例，默认为 HeaderExchangeClient\n    return getExchanger(url).connect(url, handler);\n&#125;\n\n\n如上，getExchanger 会通过 SPI 加载 HeaderExchanger 实例，这个方法比较简单，大家自己看一下吧。接下来分析 HeaderExchanger.connect 的实现。\npublic ExchangeClient connect(URL url, ExchangeHandler handler) throws RemotingException &#123;\n    // 这里包含了多个调用，分别如下：\n    // 1. 创建 HeaderExchangeHandler 对象\n    // 2. 创建 DecodeHandler 对象\n    // 3. 通过 Transporters 构建 Client 实例\n    // 4. 创建 HeaderExchangeClient 对象\n    return new HeaderExchangeClient(Transporters.connect(url, new DecodeHandler(new HeaderExchangeHandler(handler))), true);\n&#125;\n\n\n\n这里的调用比较多，我们这里重点看一下 Transporters 的 connect 方法。如下：\npublic static Client connect(URL url, ChannelHandler... handlers) throws RemotingException &#123;\n    if (url == null) &#123;\n        throw new IllegalArgumentException(\"url == null\");\n    &#125;\n    ChannelHandler handler;\n    if (handlers == null || handlers.length == 0) &#123;\n        handler = new ChannelHandlerAdapter();\n    &#125; else if (handlers.length == 1) &#123;\n        handler = handlers[0];\n    &#125; else &#123;\n        // 如果 handler 数量大于1，则创建一个 ChannelHandler 分发器\n        handler = new ChannelHandlerDispatcher(handlers);\n    &#125;\n    \n    // 获取 Transporter 自适应拓展类，并调用 connect 方法生成 Client 实例\n    return getTransporter().connect(url, handler);\n&#125;\n\n\n\n如上，getTransporter 方法返回的是自适应拓展类，该类会在运行时根据客户端类型加载指定的 Transporter 实现类。若用户未配置客户端类型，则默认加载 NettyTransporter，并调用该类的 connect 方法。如下：\npublic Client connect(URL url, ChannelHandler listener) throws RemotingException &#123;\n    // 创建 NettyClient 对象\n    return new NettyClient(url, listener);\n&#125;\n\n\n\n到这里就不继续跟下去了，在往下就是通过 Netty 提供的 API 构建 Netty 客户端了，大家有兴趣自己看看。到这里，关于 DubboProtocol 的 refer 方法就分析完了。接下来，继续分析 RegistryProtocol 的 refer 方法逻辑。\npublic &lt;T> Invoker&lt;T> refer(Class&lt;T> type, URL url) throws RpcException &#123;\n    // 取 registry 参数值，并将其设置为协议头\n    url = url.setProtocol(url.getParameter(Constants.REGISTRY_KEY, Constants.DEFAULT_REGISTRY)).removeParameter(Constants.REGISTRY_KEY);\n    // 获取注册中心实例\n    Registry registry = registryFactory.getRegistry(url);\n    if (RegistryService.class.equals(type)) &#123;\n        return proxyFactory.getInvoker((T) registry, type, url);\n    &#125;\n\n    // 将 url 查询字符串转为 Map\n    Map&lt;String, String> qs = StringUtils.parseQueryString(url.getParameterAndDecoded(Constants.REFER_KEY));\n    // 获取 group 配置\n    String group = qs.get(Constants.GROUP_KEY);\n    if (group != null &amp;&amp; group.length() > 0) &#123;\n        if ((Constants.COMMA_SPLIT_PATTERN.split(group)).length > 1\n                || \"*\".equals(group)) &#123;\n            // 通过 SPI 加载 MergeableCluster 实例，并调用 doRefer 继续执行服务引用逻辑\n            return doRefer(getMergeableCluster(), registry, type, url);\n        &#125;\n    &#125;\n    \n    // 调用 doRefer 继续执行服务引用逻辑\n    return doRefer(cluster, registry, type, url);\n&#125;\n\n\n\n上面代码首先为 url 设置协议头，然后根据 url 参数加载注册中心实例。然后获取 group 配置，根据 group 配置决定 doRefer 第一个参数的类型。这里的重点是 doRefer 方法，如下：\nprivate &lt;T> Invoker&lt;T> doRefer(Cluster cluster, Registry registry, Class&lt;T> type, URL url) &#123;\n    // 创建 RegistryDirectory 实例\n    RegistryDirectory&lt;T> directory = new RegistryDirectory&lt;T>(type, url);\n    // 设置注册中心和协议\n    directory.setRegistry(registry);\n    directory.setProtocol(protocol);\n    Map&lt;String, String> parameters = new HashMap&lt;String, String>(directory.getUrl().getParameters());\n    // 生成服务消费者链接\n    URL subscribeUrl = new URL(Constants.CONSUMER_PROTOCOL, parameters.remove(Constants.REGISTER_IP_KEY), 0, type.getName(), parameters);\n\n    // 注册服务消费者，在 consumers 目录下新节点\n    if (!Constants.ANY_VALUE.equals(url.getServiceInterface())\n            &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true)) &#123;\n        registry.register(subscribeUrl.addParameters(Constants.CATEGORY_KEY, Constants.CONSUMERS_CATEGORY,\n                Constants.CHECK_KEY, String.valueOf(false)));\n    &#125;\n\n    // 订阅 providers、configurators、routers 等节点数据\n    directory.subscribe(subscribeUrl.addParameter(Constants.CATEGORY_KEY,\n            Constants.PROVIDERS_CATEGORY\n                    + \",\" + Constants.CONFIGURATORS_CATEGORY\n                    + \",\" + Constants.ROUTERS_CATEGORY));\n\n    // 一个注册中心可能有多个服务提供者，因此这里需要将多个服务提供者合并为一个\n    Invoker invoker = cluster.join(directory);\n    ProviderConsumerRegTable.registerConsumer(invoker, url, subscribeUrl, directory);\n    return invoker;\n&#125;\n\n\n\n如上，doRefer 方法创建一个 RegistryDirectory 实例，然后生成服务者消费者链接，并向注册中心进行注册。注册完毕后，紧接着订阅 providers、configurators、routers 等节点下的数据。完成订阅后，RegistryDirectory 会收到这几个节点下的子节点信息。由于一个服务可能部署在多台服务器上，这样就会在 providers 产生多个节点，这个时候就需要 Cluster 将多个服务节点合并为一个，并生成一个 Invoker。关于 RegistryDirectory 和 Cluster，本文不打算进行分析，相关分析将会在随后的文章中展开。\n\n3.2.2 创建代理Invoker 创建完毕后，接下来要做的事情是为服务接口生成代理对象。有了代理对象，即可进行远程调用。代理对象生成的入口方法为 ProxyFactory 的 getProxy，接下来进行分析。\npublic &lt;T> T getProxy(Invoker&lt;T> invoker) throws RpcException &#123;\n    // 调用重载方法\n    return getProxy(invoker, false);\n&#125;\n\npublic &lt;T> T getProxy(Invoker&lt;T> invoker, boolean generic) throws RpcException &#123;\n    Class&lt;?>[] interfaces = null;\n    // 获取接口列表\n    String config = invoker.getUrl().getParameter(\"interfaces\");\n    if (config != null &amp;&amp; config.length() > 0) &#123;\n        // 切分接口列表\n        String[] types = Constants.COMMA_SPLIT_PATTERN.split(config);\n        if (types != null &amp;&amp; types.length > 0) &#123;\n            interfaces = new Class&lt;?>[types.length + 2];\n            // 设置服务接口类和 EchoService.class 到 interfaces 中\n            interfaces[0] = invoker.getInterface();\n            interfaces[1] = EchoService.class;\n            for (int i = 0; i &lt; types.length; i++) &#123;\n                // 加载接口类\n                interfaces[i + 1] = ReflectUtils.forName(types[i]);\n            &#125;\n        &#125;\n    &#125;\n    if (interfaces == null) &#123;\n        interfaces = new Class&lt;?>[]&#123;invoker.getInterface(), EchoService.class&#125;;\n    &#125;\n\n    // 为 http 和 hessian 协议提供泛化调用支持，参考 pull request #1827\n    if (!invoker.getInterface().equals(GenericService.class) &amp;&amp; generic) &#123;\n        int len = interfaces.length;\n        Class&lt;?>[] temp = interfaces;\n        // 创建新的 interfaces 数组\n        interfaces = new Class&lt;?>[len + 1];\n        System.arraycopy(temp, 0, interfaces, 0, len);\n        // 设置 GenericService.class 到数组中\n        interfaces[len] = GenericService.class;\n    &#125;\n\n    // 调用重载方法\n    return getProxy(invoker, interfaces);\n&#125;\n\npublic abstract &lt;T> T getProxy(Invoker&lt;T> invoker, Class&lt;?>[] types);\n\n\n\n如上，上面大段代码都是用来获取 interfaces 数组的，我们继续往下看。getProxy(Invoker, Class&lt;?&gt;[]) 这个方法是一个抽象方法，下面我们到 JavassistProxyFactory 类中看一下该方法的实现代码。\npublic &lt;T> T getProxy(Invoker&lt;T> invoker, Class&lt;?>[] interfaces) &#123;\n    // 生成 Proxy 子类（Proxy 是抽象类）。并调用 Proxy 子类的 newInstance 方法创建 Proxy 实例\n    return (T) Proxy.getProxy(interfaces).newInstance(new InvokerInvocationHandler(invoker));\n&#125;\n\n\n\n上面代码并不多，首先是通过 Proxy 的 getProxy 方法获取 Proxy 子类，然后创建 InvokerInvocationHandler 对象，并将该对象传给 newInstance 生成 Proxy 实例。InvokerInvocationHandler 实现 JDK 的 InvocationHandler 接口，具体的用途是拦截接口类调用。该类逻辑比较简单，这里就不分析了。下面我们重点关注一下 Proxy 的 getProxy 方法，如下。\npublic static Proxy getProxy(Class&lt;?>... ics) &#123;\n    // 调用重载方法\n    return getProxy(ClassHelper.getClassLoader(Proxy.class), ics);\n&#125;\n\npublic static Proxy getProxy(ClassLoader cl, Class&lt;?>... ics) &#123;\n    if (ics.length > 65535)\n        throw new IllegalArgumentException(\"interface limit exceeded\");\n\n    StringBuilder sb = new StringBuilder();\n    // 遍历接口列表\n    for (int i = 0; i &lt; ics.length; i++) &#123;\n        String itf = ics[i].getName();\n        // 检测类型是否为接口\n        if (!ics[i].isInterface())\n            throw new RuntimeException(itf + \" is not a interface.\");\n\n        Class&lt;?> tmp = null;\n        try &#123;\n            // 重新加载接口类\n            tmp = Class.forName(itf, false, cl);\n        &#125; catch (ClassNotFoundException e) &#123;\n        &#125;\n\n        // 检测接口是否相同，这里 tmp 有可能为空\n        if (tmp != ics[i])\n            throw new IllegalArgumentException(ics[i] + \" is not visible from class loader\");\n\n        // 拼接接口全限定名，分隔符为 ;\n        sb.append(itf).append(';');\n    &#125;\n\n    // 使用拼接后的接口名作为 key\n    String key = sb.toString();\n\n    Map&lt;String, Object> cache;\n    synchronized (ProxyCacheMap) &#123;\n        cache = ProxyCacheMap.get(cl);\n        if (cache == null) &#123;\n            cache = new HashMap&lt;String, Object>();\n            ProxyCacheMap.put(cl, cache);\n        &#125;\n    &#125;\n\n    Proxy proxy = null;\n    synchronized (cache) &#123;\n        do &#123;\n            // 从缓存中获取 Reference&lt;Proxy> 实例\n            Object value = cache.get(key);\n            if (value instanceof Reference&lt;?>) &#123;\n                proxy = (Proxy) ((Reference&lt;?>) value).get();\n                if (proxy != null) &#123;\n                    return proxy;\n                &#125;\n            &#125;\n\n            // 并发控制，保证只有一个线程可以进行后续操作\n            if (value == PendingGenerationMarker) &#123;\n                try &#123;\n                    // 其他线程在此处进行等待\n                    cache.wait();\n                &#125; catch (InterruptedException e) &#123;\n                &#125;\n            &#125; else &#123;\n                // 放置标志位到缓存中，并跳出 while 循环进行后续操作\n                cache.put(key, PendingGenerationMarker);\n                break;\n            &#125;\n        &#125;\n        while (true);\n    &#125;\n\n    long id = PROXY_CLASS_COUNTER.getAndIncrement();\n    String pkg = null;\n    ClassGenerator ccp = null, ccm = null;\n    try &#123;\n        // 创建 ClassGenerator 对象\n        ccp = ClassGenerator.newInstance(cl);\n\n        Set&lt;String> worked = new HashSet&lt;String>();\n        List&lt;Method> methods = new ArrayList&lt;Method>();\n\n        for (int i = 0; i &lt; ics.length; i++) &#123;\n            // 检测接口访问级别是否为 protected 或 private\n            if (!Modifier.isPublic(ics[i].getModifiers())) &#123;\n                // 获取接口包名\n                String npkg = ics[i].getPackage().getName();\n                if (pkg == null) &#123;\n                    pkg = npkg;\n                &#125; else &#123;\n                    if (!pkg.equals(npkg))\n                        // 非 public 级别的接口必须在同一个包下，否者抛出异常\n                        throw new IllegalArgumentException(\"non-public interfaces from different packages\");\n                &#125;\n            &#125;\n            \n            // 添加接口到 ClassGenerator 中\n            ccp.addInterface(ics[i]);\n\n            // 遍历接口方法\n            for (Method method : ics[i].getMethods()) &#123;\n                // 获取方法描述，可理解为方法签名\n                String desc = ReflectUtils.getDesc(method);\n                // 如果方法描述字符串已在 worked 中，则忽略。考虑这种情况，\n                // A 接口和 B 接口中包含一个完全相同的方法\n                if (worked.contains(desc))\n                    continue;\n                worked.add(desc);\n\n                int ix = methods.size();\n                // 获取方法返回值类型\n                Class&lt;?> rt = method.getReturnType();\n                // 获取参数列表\n                Class&lt;?>[] pts = method.getParameterTypes();\n\n                // 生成 Object[] args = new Object[1...N]\n                StringBuilder code = new StringBuilder(\"Object[] args = new Object[\").append(pts.length).append(\"];\");\n                for (int j = 0; j &lt; pts.length; j++)\n                    // 生成 args[1...N] = ($w)$1...N;\n                    code.append(\" args[\").append(j).append(\"] = ($w)$\").append(j + 1).append(\";\");\n                // 生成 InvokerHandler 接口的 invoker 方法调用语句，如下：\n                // Object ret = handler.invoke(this, methods[1...N], args);\n                code.append(\" Object ret = handler.invoke(this, methods[\" + ix + \"], args);\");\n\n                // 返回值不为 void\n                if (!Void.TYPE.equals(rt))\n                    // 生成返回语句，形如 return (java.lang.String) ret;\n                    code.append(\" return \").append(asArgument(rt, \"ret\")).append(\";\");\n\n                methods.add(method);\n                // 添加方法名、访问控制符、参数列表、方法代码等信息到 ClassGenerator 中 \n                ccp.addMethod(method.getName(), method.getModifiers(), rt, pts, method.getExceptionTypes(), code.toString());\n            &#125;\n        &#125;\n\n        if (pkg == null)\n            pkg = PACKAGE_NAME;\n\n        // 构建接口代理类名称：pkg + \".proxy\" + id，比如 org.apache.dubbo.proxy0\n        String pcn = pkg + \".proxy\" + id;\n        ccp.setClassName(pcn);\n        ccp.addField(\"public static java.lang.reflect.Method[] methods;\");\n        // 生成 private java.lang.reflect.InvocationHandler handler;\n        ccp.addField(\"private \" + InvocationHandler.class.getName() + \" handler;\");\n\n        // 为接口代理类添加带有 InvocationHandler 参数的构造方法，比如：\n        // porxy0(java.lang.reflect.InvocationHandler arg0) &#123;\n        //     handler=$1;\n    \t// &#125;\n        ccp.addConstructor(Modifier.PUBLIC, new Class&lt;?>[]&#123;InvocationHandler.class&#125;, new Class&lt;?>[0], \"handler=$1;\");\n        // 为接口代理类添加默认构造方法\n        ccp.addDefaultConstructor();\n        \n        // 生成接口代理类\n        Class&lt;?> clazz = ccp.toClass();\n        clazz.getField(\"methods\").set(null, methods.toArray(new Method[0]));\n\n        // 构建 Proxy 子类名称，比如 Proxy1，Proxy2 等\n        String fcn = Proxy.class.getName() + id;\n        ccm = ClassGenerator.newInstance(cl);\n        ccm.setClassName(fcn);\n        ccm.addDefaultConstructor();\n        ccm.setSuperClass(Proxy.class);\n        // 为 Proxy 的抽象方法 newInstance 生成实现代码，形如：\n        // public Object newInstance(java.lang.reflect.InvocationHandler h) &#123; \n        //     return new org.apache.dubbo.proxy0($1);\n        // &#125;\n        ccm.addMethod(\"public Object newInstance(\" + InvocationHandler.class.getName() + \" h)&#123; return new \" + pcn + \"($1); &#125;\");\n        // 生成 Proxy 实现类\n        Class&lt;?> pc = ccm.toClass();\n        // 通过反射创建 Proxy 实例\n        proxy = (Proxy) pc.newInstance();\n    &#125; catch (RuntimeException e) &#123;\n        throw e;\n    &#125; catch (Exception e) &#123;\n        throw new RuntimeException(e.getMessage(), e);\n    &#125; finally &#123;\n        if (ccp != null)\n            // 释放资源\n            ccp.release();\n        if (ccm != null)\n            ccm.release();\n        synchronized (cache) &#123;\n            if (proxy == null)\n                cache.remove(key);\n            else\n                // 写缓存\n                cache.put(key, new WeakReference&lt;Proxy>(proxy));\n            // 唤醒其他等待线程\n            cache.notifyAll();\n        &#125;\n    &#125;\n    return proxy;\n&#125;\n\n\n\n上面代码比较复杂，我们写了大量的注释。大家在阅读这段代码时，要搞清楚 ccp 和 ccm 的用途，不然会被搞晕。ccp 用于为服务接口生成代理类，比如我们有一个 DemoService 接口，这个接口代理类就是由 ccp 生成的。ccm 则是用于为 org.apache.dubbo.common.bytecode.Proxy 抽象类生成子类，主要是实现 Proxy 类的抽象方法。下面以 org.apache.dubbo.demo.DemoService 这个接口为例，来看一下该接口代理类代码大致是怎样的（忽略 EchoService 接口）。\npackage org.apache.dubbo.common.bytecode;\n\npublic class proxy0 implements org.apache.dubbo.demo.DemoService &#123;\n\n    public static java.lang.reflect.Method[] methods;\n\n    private java.lang.reflect.InvocationHandler handler;\n\n    public proxy0() &#123;\n    &#125;\n\n    public proxy0(java.lang.reflect.InvocationHandler arg0) &#123;\n        handler = $1;\n    &#125;\n\n    public java.lang.String sayHello(java.lang.String arg0) &#123;\n        Object[] args = new Object[1];\n        args[0] = ($w) $1;\n        Object ret = handler.invoke(this, methods[0], args);\n        return (java.lang.String) ret;\n    &#125;\n&#125;\n\n\n\n好了，到这里代理类生成逻辑就分析完了。整个过程比较复杂，大家需要耐心看一下。\n\n4.总结本篇文章对服务引用的过程进行了较为详尽的分析，还有一些逻辑暂时没有分析到，比如 Directory、Cluster。这些接口及实现类功能比较独立，后续会单独成文进行分析。暂时我们可以先把这些类看成黑盒，只要知道这些类的用途即可。关于服务引用过程就分析到这里。\n\n\n\n\n\n\n\n\n\n原文地址：https://dubbo.apache.org/zh/docsv2.7/dev/source/export-service/\n作者： Dubbo 官方\n本文介绍了 Dubbo 服务导出的过程和实现细节\n服务调用过程1.简介本篇文章，我们来研究一下 Dubbo 导出服务的过程。Dubbo 服务导出过程始于 Spring 容器发布刷新事件，Dubbo 在接收到事件后，会立即执行服务导出逻辑。整个逻辑大致可分为三个部分，第一部分是前置工作，主要用于检查参数，组装 URL。第二部分是导出服务，包含导出服务到本地 (JVM)，和导出服务到远程两个过程。第三部分是向注册中心注册服务，用于服务发现。本篇文章将会对这三个部分代码进行详细的分析。\n\n2.源码分析服务导出的入口方法是 ServiceBean 的 onApplicationEvent。onApplicationEvent 是一个事件响应方法，该方法会在收到 Spring 上下文刷新事件后执行服务导出操作。方法代码如下：\npublic void onApplicationEvent(ContextRefreshedEvent event) &#123;\n    // 是否有延迟导出 &amp;&amp; 是否已导出 &amp;&amp; 是不是已被取消导出\n    if (isDelay() &amp;&amp; !isExported() &amp;&amp; !isUnexported()) &#123;\n        // 导出服务\n        export();\n    &#125;\n&#125;\n\n\n\n这个方法首先会根据条件决定是否导出服务，比如有些服务设置了延时导出，那么此时就不应该在此处导出。还有一些服务已经被导出了，或者当前服务被取消导出了，此时也不能再次导出相关服务。注意这里的 isDelay 方法，这个方法字面意思是“是否延迟导出服务”，返回 true 表示延迟导出，false 表示不延迟导出。但是该方法真实意思却并非如此，当方法返回 true 时，表示无需延迟导出。返回 false 时，表示需要延迟导出。与字面意思恰恰相反，这个需要大家注意一下。下面我们来看一下这个方法的逻辑。\n// -☆- ServiceBean\nprivate boolean isDelay() &#123;\n    // 获取 delay\n    Integer delay = getDelay();\n    ProviderConfig provider = getProvider();\n    if (delay == null &amp;&amp; provider != null) &#123;\n        // 如果前面获取的 delay 为空，这里继续获取\n        delay = provider.getDelay();\n    &#125;\n    // 判断 delay 是否为空，或者等于 -1\n    return supportedApplicationListener &amp;&amp; (delay == null || delay == -1);\n&#125;\n\n\n\n暂时忽略 supportedApplicationListener 这个条件，当 delay 为空，或者等于-1时，该方法返回 true，而不是 false。这个方法的返回值让人有点困惑。该方法目前已被重构，详细请参考 dubbo #2686。\n现在解释一下 supportedApplicationListener 变量含义，该变量用于表示当前的 Spring 容器是否支持 ApplicationListener，这个值初始为 false。在 Spring 容器将自己设置到 ServiceBean 中时，ServiceBean 的 setApplicationContext 方法会检测 Spring 容器是否支持 ApplicationListener。若支持，则将 supportedApplicationListener 置为 true。ServiceBean 是 Dubbo 与 Spring 框架进行整合的关键，可以看做是两个框架之间的桥梁。具有同样作用的类还有 ReferenceBean。\n现在我们知道了 Dubbo 服务导出过程的起点，接下来对服务导出的前置逻辑进行分析。\n\n2.1 前置工作前置工作主要包含两个部分，分别是配置检查，以及 URL 装配。在导出服务之前，Dubbo 需要检查用户的配置是否合理，或者为用户补充缺省配置。配置检查完成后，接下来需要根据这些配置组装 URL。在 Dubbo 中，URL 的作用十分重要。Dubbo 使用 URL 作为配置载体，所有的拓展点都是通过 URL 获取配置。这一点，官方文档中有所说明。\n\n\n\n\n\n\n\n\n\n采用 URL 作为配置信息的统一格式，所有扩展点都通过传递 URL 携带配置信息。\n接下来，我们先来分析配置检查部分的源码，随后再来分析 URL 组装部分的源码。\n\n2.1.1 检查配置本节我们接着前面的源码向下分析，前面说过 onApplicationEvent 方法在经过一些判断后，会决定是否调用 export 方法导出服务。那么下面我们从 export 方法开始进行分析，如下：\npublic synchronized void export() &#123;\n    if (provider != null) &#123;\n        // 获取 export 和 delay 配置\n        if (export == null) &#123;\n            export = provider.getExport();\n        &#125;\n        if (delay == null) &#123;\n            delay = provider.getDelay();\n        &#125;\n    &#125;\n    // 如果 export 为 false，则不导出服务\n    if (export != null &amp;&amp; !export) &#123;\n        return;\n    &#125;\n\n    // delay > 0，延时导出服务\n    if (delay != null &amp;&amp; delay > 0) &#123;\n        delayExportExecutor.schedule(new Runnable() &#123;\n            @Override\n            public void run() &#123;\n                doExport();\n            &#125;\n        &#125;, delay, TimeUnit.MILLISECONDS);\n        \n    // 立即导出服务\n    &#125; else &#123;\n        doExport();\n    &#125;\n&#125;\n\n\n\nexport 方法对两项配置进行了检查，并根据配置执行相应的动作。首先是 export 配置，这个配置决定了是否导出服务。有时候我们只是想本地启动服务进行一些调试工作，我们并不希望把本地启动的服务暴露出去给别人调用。此时，我们可通过配置 export 禁止服务导出，比如：\n&lt;dubbo:provider export=\"false\" />\n\n\n\ndelay 配置顾名思义，用于延迟导出服务，这个就不分析了。下面，我们继续分析源码，这次要分析的是 doExport 方法。\nprotected synchronized void doExport() &#123;\n    if (unexported) &#123;\n        throw new IllegalStateException(\"Already unexported!\");\n    &#125;\n    if (exported) &#123;\n        return;\n    &#125;\n    exported = true;\n    // 检测 interfaceName 是否合法\n    if (interfaceName == null || interfaceName.length() == 0) &#123;\n        throw new IllegalStateException(\"interface not allow null!\");\n    &#125;\n    // 检测 provider 是否为空，为空则新建一个，并通过系统变量为其初始化\n    checkDefault();\n\n    // 下面几个 if 语句用于检测 provider、application 等核心配置类对象是否为空，\n    // 若为空，则尝试从其他配置类对象中获取相应的实例。\n    if (provider != null) &#123;\n        if (application == null) &#123;\n            application = provider.getApplication();\n        &#125;\n        if (module == null) &#123;\n            module = provider.getModule();\n        &#125;\n        if (registries == null) &#123;...&#125;\n        if (monitor == null) &#123;...&#125;\n        if (protocols == null) &#123;...&#125;\n    &#125;\n    if (module != null) &#123;\n        if (registries == null) &#123;\n            registries = module.getRegistries();\n        &#125;\n        if (monitor == null) &#123;...&#125;\n    &#125;\n    if (application != null) &#123;\n        if (registries == null) &#123;\n            registries = application.getRegistries();\n        &#125;\n        if (monitor == null) &#123;...&#125;\n    &#125;\n\n    // 检测 ref 是否为泛化服务类型\n    if (ref instanceof GenericService) &#123;\n        // 设置 interfaceClass 为 GenericService.class\n        interfaceClass = GenericService.class;\n        if (StringUtils.isEmpty(generic)) &#123;\n            // 设置 generic = \"true\"\n            generic = Boolean.TRUE.toString();\n        &#125;\n        \n    // ref 非 GenericService 类型\n    &#125; else &#123;\n        try &#123;\n            interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()\n                    .getContextClassLoader());\n        &#125; catch (ClassNotFoundException e) &#123;\n            throw new IllegalStateException(e.getMessage(), e);\n        &#125;\n        // 对 interfaceClass，以及 &lt;dubbo:method> 标签中的必要字段进行检查\n        checkInterfaceAndMethods(interfaceClass, methods);\n        // 对 ref 合法性进行检测\n        checkRef();\n        // 设置 generic = \"false\"\n        generic = Boolean.FALSE.toString();\n    &#125;\n\n    // local 和 stub 在功能应该是一致的，用于配置本地存根\n    if (local != null) &#123;\n        if (\"true\".equals(local)) &#123;\n            local = interfaceName + \"Local\";\n        &#125;\n        Class&lt;?> localClass;\n        try &#123;\n            // 获取本地存根类\n            localClass = ClassHelper.forNameWithThreadContextClassLoader(local);\n        &#125; catch (ClassNotFoundException e) &#123;\n            throw new IllegalStateException(e.getMessage(), e);\n        &#125;\n        // 检测本地存根类是否可赋值给接口类，若不可赋值则会抛出异常，提醒使用者本地存根类类型不合法\n        if (!interfaceClass.isAssignableFrom(localClass)) &#123;\n            throw new IllegalStateException(\"The local implementation class \" + localClass.getName() + \" not implement interface \" + interfaceName);\n        &#125;\n    &#125;\n\n    if (stub != null) &#123;\n        // 此处的代码和上一个 if 分支的代码基本一致，这里省略\n    &#125;\n\n    // 检测各种对象是否为空，为空则新建，或者抛出异常\n    checkApplication();\n    checkRegistry();\n    checkProtocol();\n    appendProperties(this);\n    checkStubAndMock(interfaceClass);\n    if (path == null || path.length() == 0) &#123;\n        path = interfaceName;\n    &#125;\n\n    // 导出服务\n    doExportUrls();\n\n    // ProviderModel 表示服务提供者模型，此对象中存储了与服务提供者相关的信息。\n    // 比如服务的配置信息，服务实例等。每个被导出的服务对应一个 ProviderModel。\n    // ApplicationModel 持有所有的 ProviderModel。\n    ProviderModel providerModel = new ProviderModel(getUniqueServiceName(), this, ref);\n    ApplicationModel.initProviderModel(getUniqueServiceName(), providerModel);\n&#125;\n\n\n\n以上就是配置检查的相关分析，代码比较多，需要大家耐心看一下。下面对配置检查的逻辑进行简单的总结，如下：\n\n检测 dubbo:service 标签的 interface 属性合法性，不合法则抛出异常\n检测 ProviderConfig、ApplicationConfig 等核心配置类对象是否为空，若为空，则尝试从其他配置类对象中获取相应的实例。\n检测并处理泛化服务和普通服务类\n检测本地存根配置，并进行相应的处理\n对 ApplicationConfig、RegistryConfig 等配置类进行检测，为空则尝试创建，若无法创建则抛出异常\n\n配置检查并非本文重点，因此这里不打算对 doExport 方法所调用的方法进行分析（doExportUrls 方法除外）。在这些方法中，除了 appendProperties 方法稍微复杂一些，其他方法逻辑不是很复杂。因此，大家可自行分析。\n\n2.1.2 多协议多注册中心导出服务Dubbo 允许我们使用不同的协议导出服务，也允许我们向多个注册中心注册服务。Dubbo 在 doExportUrls 方法中对多协议，多注册中心进行了支持。相关代码如下：\nprivate void doExportUrls() &#123;\n    // 加载注册中心链接\n    List&lt;URL> registryURLs = loadRegistries(true);\n    // 遍历 protocols，并在每个协议下导出服务\n    for (ProtocolConfig protocolConfig : protocols) &#123;\n        doExportUrlsFor1Protocol(protocolConfig, registryURLs);\n    &#125;\n&#125;\n\n\n\n上面代码首先是通过 loadRegistries 加载注册中心链接，然后再遍历 ProtocolConfig 集合导出每个服务。并在导出服务的过程中，将服务注册到注册中心。下面，我们先来看一下 loadRegistries 方法的逻辑。\nprotected List&lt;URL> loadRegistries(boolean provider) &#123;\n    // 检测是否存在注册中心配置类，不存在则抛出异常\n    checkRegistry();\n    List&lt;URL> registryList = new ArrayList&lt;URL>();\n    if (registries != null &amp;&amp; !registries.isEmpty()) &#123;\n        for (RegistryConfig config : registries) &#123;\n            String address = config.getAddress();\n            if (address == null || address.length() == 0) &#123;\n                // 若 address 为空，则将其设为 0.0.0.0\n                address = Constants.ANYHOST_VALUE;\n            &#125;\n\n            // 从系统属性中加载注册中心地址\n            String sysaddress = System.getProperty(\"dubbo.registry.address\");\n            if (sysaddress != null &amp;&amp; sysaddress.length() > 0) &#123;\n                address = sysaddress;\n            &#125;\n            // 检测 address 是否合法\n            if (address.length() > 0 &amp;&amp; !RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) &#123;\n                Map&lt;String, String> map = new HashMap&lt;String, String>();\n                // 添加 ApplicationConfig 中的字段信息到 map 中\n                appendParameters(map, application);\n                // 添加 RegistryConfig 字段信息到 map 中\n                appendParameters(map, config);\n                \n                // 添加 path、pid，protocol 等信息到 map 中\n                map.put(\"path\", RegistryService.class.getName());\n                map.put(\"dubbo\", Version.getProtocolVersion());\n                map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n                if (ConfigUtils.getPid() > 0) &#123;\n                    map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n                &#125;\n                if (!map.containsKey(\"protocol\")) &#123;\n                    if (ExtensionLoader.getExtensionLoader(RegistryFactory.class).hasExtension(\"remote\")) &#123;\n                        map.put(\"protocol\", \"remote\");\n                    &#125; else &#123;\n                        map.put(\"protocol\", \"dubbo\");\n                    &#125;\n                &#125;\n\n                // 解析得到 URL 列表，address 可能包含多个注册中心 ip，\n                // 因此解析得到的是一个 URL 列表\n                List&lt;URL> urls = UrlUtils.parseURLs(address, map);\n                for (URL url : urls) &#123;\n                    url = url.addParameter(Constants.REGISTRY_KEY, url.getProtocol());\n                    // 将 URL 协议头设置为 registry\n                    url = url.setProtocol(Constants.REGISTRY_PROTOCOL);\n                    // 通过判断条件，决定是否添加 url 到 registryList 中，条件如下：\n                    // (服务提供者 &amp;&amp; register = true 或 null) \n                    //    || (非服务提供者 &amp;&amp; subscribe = true 或 null)\n                    if ((provider &amp;&amp; url.getParameter(Constants.REGISTER_KEY, true))\n                            || (!provider &amp;&amp; url.getParameter(Constants.SUBSCRIBE_KEY, true))) &#123;\n                        registryList.add(url);\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return registryList;\n&#125;\n\n\n\nloadRegistries 方法主要包含如下的逻辑：\n\n检测是否存在注册中心配置类，不存在则抛出异常\n构建参数映射集合，也就是 map\n构建注册中心链接列表\n遍历链接列表，并根据条件决定是否将其添加到 registryList 中\n\n关于多协议多注册中心导出服务就先分析到这，代码不是很多，接下来分析 URL 组装过程。\n\n2.1.3 组装 URL配置检查完毕后，紧接着要做的事情是根据配置，以及其他一些信息组装 URL。前面说过，URL 是 Dubbo 配置的载体，通过 URL 可让 Dubbo 的各种配置在各个模块之间传递。URL 之于 Dubbo，犹如水之于鱼，非常重要。大家在阅读 Dubbo 服务导出相关源码的过程中，要注意 URL 内容的变化。既然 URL 如此重要，那么下面我们来了解一下 URL 组装的过程。\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL> registryURLs) &#123;\n    String name = protocolConfig.getName();\n    // 如果协议名为空，或空串，则将协议名变量设置为 dubbo\n    if (name == null || name.length() == 0) &#123;\n        name = \"dubbo\";\n    &#125;\n\n    Map&lt;String, String> map = new HashMap&lt;String, String>();\n    // 添加 side、版本、时间戳以及进程号等信息到 map 中\n    map.put(Constants.SIDE_KEY, Constants.PROVIDER_SIDE);\n    map.put(Constants.DUBBO_VERSION_KEY, Version.getProtocolVersion());\n    map.put(Constants.TIMESTAMP_KEY, String.valueOf(System.currentTimeMillis()));\n    if (ConfigUtils.getPid() > 0) &#123;\n        map.put(Constants.PID_KEY, String.valueOf(ConfigUtils.getPid()));\n    &#125;\n\n    // 通过反射将对象的字段信息添加到 map 中\n    appendParameters(map, application);\n    appendParameters(map, module);\n    appendParameters(map, provider, Constants.DEFAULT_KEY);\n    appendParameters(map, protocolConfig);\n    appendParameters(map, this);\n\n    // methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method> 标签的配置信息\n    if (methods != null &amp;&amp; !methods.isEmpty()) &#123;\n        // 这段代码用于添加 Callback 配置到 map 中，代码太长，待会单独分析\n    &#125;\n\n    // 检测 generic 是否为 \"true\"，并根据检测结果向 map 中添加不同的信息\n    if (ProtocolUtils.isGeneric(generic)) &#123;\n        map.put(Constants.GENERIC_KEY, generic);\n        map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n    &#125; else &#123;\n        String revision = Version.getVersion(interfaceClass, version);\n        if (revision != null &amp;&amp; revision.length() > 0) &#123;\n            map.put(\"revision\", revision);\n        &#125;\n\n        // 为接口生成包裹类 Wrapper，Wrapper 中包含了接口的详细信息，比如接口方法名数组，字段信息等\n        String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();\n        // 添加方法名到 map 中，如果包含多个方法名，则用逗号隔开，比如 method = init,destroy\n        if (methods.length == 0) &#123;\n            logger.warn(\"NO method found in service interface ...\");\n            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);\n        &#125; else &#123;\n            // 将逗号作为分隔符连接方法名，并将连接后的字符串放入 map 中\n            map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet&lt;String>(Arrays.asList(methods)), \",\"));\n        &#125;\n    &#125;\n\n    // 添加 token 到 map 中\n    if (!ConfigUtils.isEmpty(token)) &#123;\n        if (ConfigUtils.isDefault(token)) &#123;\n            // 随机生成 token\n            map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());\n        &#125; else &#123;\n            map.put(Constants.TOKEN_KEY, token);\n        &#125;\n    &#125;\n    // 判断协议名是否为 injvm\n    if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) &#123;\n        protocolConfig.setRegister(false);\n        map.put(\"notify\", \"false\");\n    &#125;\n\n    // 获取上下文路径\n    String contextPath = protocolConfig.getContextpath();\n    if ((contextPath == null || contextPath.length() == 0) &amp;&amp; provider != null) &#123;\n        contextPath = provider.getContextpath();\n    &#125;\n\n    // 获取 host 和 port\n    String host = this.findConfigedHosts(protocolConfig, registryURLs, map);\n    Integer port = this.findConfigedPorts(protocolConfig, name, map);\n    // 组装 URL\n    URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? \"\" : contextPath + \"/\") + path, map);\n    \n    // 省略无关代码\n&#125;\n\n\n\n上面的代码首先是将一些信息，比如版本、时间戳、方法名以及各种配置对象的字段信息放入到 map 中，map 中的内容将作为 URL 的查询字符串。构建好 map 后，紧接着是获取上下文路径、主机名以及端口号等信息。最后将 map 和主机名等数据传给 URL 构造方法创建 URL 对象。需要注意的是，这里出现的 URL 并非 java.net.URL，而是 com.alibaba.dubbo.common.URL。\n上面省略了一段代码，这里简单分析一下。这段代码用于检测 dubbo:method 标签中的配置信息，并将相关配置添加到 map 中。代码如下：\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL> registryURLs) &#123;\n    // ...\n\n    // methods 为 MethodConfig 集合，MethodConfig 中存储了 &lt;dubbo:method> 标签的配置信息\n    if (methods != null &amp;&amp; !methods.isEmpty()) &#123;\n        for (MethodConfig method : methods) &#123;\n            // 添加 MethodConfig 对象的字段信息到 map 中，键 = 方法名.属性名。\n            // 比如存储 &lt;dubbo:method name=\"sayHello\" retries=\"2\"> 对应的 MethodConfig，\n            // 键 = sayHello.retries，map = &#123;\"sayHello.retries\": 2, \"xxx\": \"yyy\"&#125;\n            appendParameters(map, method, method.getName());\n\n            String retryKey = method.getName() + \".retry\";\n            if (map.containsKey(retryKey)) &#123;\n                String retryValue = map.remove(retryKey);\n                // 检测 MethodConfig retry 是否为 false，若是，则设置重试次数为0\n                if (\"false\".equals(retryValue)) &#123;\n                    map.put(method.getName() + \".retries\", \"0\");\n                &#125;\n            &#125;\n            \n            // 获取 ArgumentConfig 列表\n            List&lt;ArgumentConfig> arguments = method.getArguments();\n            if (arguments != null &amp;&amp; !arguments.isEmpty()) &#123;\n                for (ArgumentConfig argument : arguments) &#123;\n                    // 检测 type 属性是否为空，或者空串（分支1 ⭐️）\n                    if (argument.getType() != null &amp;&amp; argument.getType().length() > 0) &#123;\n                        Method[] methods = interfaceClass.getMethods();\n                        if (methods != null &amp;&amp; methods.length > 0) &#123;\n                            for (int i = 0; i &lt; methods.length; i++) &#123;\n                                String methodName = methods[i].getName();\n                                // 比对方法名，查找目标方法\n                                if (methodName.equals(method.getName())) &#123;\n                                    Class&lt;?>[] argtypes = methods[i].getParameterTypes();\n                                    if (argument.getIndex() != -1) &#123;\n                                        // 检测 ArgumentConfig 中的 type 属性与方法参数列表\n                                        // 中的参数名称是否一致，不一致则抛出异常(分支2 ⭐️)\n                                        if (argtypes[argument.getIndex()].getName().equals(argument.getType())) &#123;\n                                            // 添加 ArgumentConfig 字段信息到 map 中，\n                                            // 键前缀 = 方法名.index，比如:\n                                            // map = &#123;\"sayHello.3\": true&#125;\n                                            appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                                        &#125; else &#123;\n                                            throw new IllegalArgumentException(\"argument config error: ...\");\n                                        &#125;\n                                    &#125; else &#123;    // 分支3 ⭐️\n                                        for (int j = 0; j &lt; argtypes.length; j++) &#123;\n                                            Class&lt;?> argclazz = argtypes[j];\n                                            // 从参数类型列表中查找类型名称为 argument.type 的参数\n                                            if (argclazz.getName().equals(argument.getType())) &#123;\n                                                appendParameters(map, argument, method.getName() + \".\" + j);\n                                                if (argument.getIndex() != -1 &amp;&amp; argument.getIndex() != j) &#123;\n                                                    throw new IllegalArgumentException(\"argument config error: ...\");\n                                                &#125;\n                                            &#125;\n                                        &#125;\n                                    &#125;\n                                &#125;\n                            &#125;\n                        &#125;\n\n                    // 用户未配置 type 属性，但配置了 index 属性，且 index != -1\n                    &#125; else if (argument.getIndex() != -1) &#123;    // 分支4 ⭐️\n                        // 添加 ArgumentConfig 字段信息到 map 中\n                        appendParameters(map, argument, method.getName() + \".\" + argument.getIndex());\n                    &#125; else &#123;\n                        throw new IllegalArgumentException(\"argument config must set index or type\");\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n上面这段代码 for 循环和 if else 分支嵌套太多，导致层次太深，不利于阅读，需要耐心看一下。大家在看这段代码时，注意把几个重要的条件分支找出来。只要理解了这几个分支的意图，就可以弄懂这段代码。请注意上面代码中⭐️符号，这几个符号标识出了4个重要的分支，下面用伪代码解释一下这几个分支的含义。\n// 获取 ArgumentConfig 列表\nfor (遍历 ArgumentConfig 列表) &#123;\n    if (type 不为 null，也不为空串) &#123;    // 分支1\n        1. 通过反射获取 interfaceClass 的方法列表\n        for (遍历方法列表) &#123;\n            1. 比对方法名，查找目标方法\n        \t2. 通过反射获取目标方法的参数类型数组 argtypes\n            if (index != -1) &#123;    // 分支2\n                1. 从 argtypes 数组中获取下标 index 处的元素 argType\n                2. 检测 argType 的名称与 ArgumentConfig 中的 type 属性是否一致\n                3. 添加 ArgumentConfig 字段信息到 map 中，或抛出异常\n            &#125; else &#123;    // 分支3\n                1. 遍历参数类型数组 argtypes，查找 argument.type 类型的参数\n                2. 添加 ArgumentConfig 字段信息到 map 中\n            &#125;\n        &#125;\n    &#125; else if (index != -1) &#123;    // 分支4\n\t\t1. 添加 ArgumentConfig 字段信息到 map 中\n    &#125;\n&#125;\n\n\n\n在本节分析的源码中，appendParameters 这个方法出现的次数比较多，该方法用于将对象字段信息添加到 map 中。实现上则是通过反射获取目标对象的 getter 方法，并调用该方法获取属性值。然后再通过 getter 方法名解析出属性名，比如从方法名 getName 中可解析出属性 name。如果用户传入了属性名前缀，此时需要将属性名加入前缀内容。最后将 &lt;属性名，属性值&gt; 键值对存入到 map 中就行了。限于篇幅原因，这里就不分析 appendParameters 方法的源码了，大家请自行分析。\n\n2.2 导出 Dubbo 服务前置工作做完，接下来就可以进行服务导出了。服务导出分为导出到本地 (JVM)，和导出到远程。在深入分析服务导出的源码前，我们先来从宏观层面上看一下服务导出逻辑。如下：\nprivate void doExportUrlsFor1Protocol(ProtocolConfig protocolConfig, List&lt;URL> registryURLs) &#123;\n    \n    // 省略无关代码\n    \n    if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n            .hasExtension(url.getProtocol())) &#123;\n        // 加载 ConfiguratorFactory，并生成 Configurator 实例，然后通过实例配置 url\n        url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)\n                .getExtension(url.getProtocol()).getConfigurator(url).configure(url);\n    &#125;\n\n    String scope = url.getParameter(Constants.SCOPE_KEY);\n    // 如果 scope = none，则什么都不做\n    if (!Constants.SCOPE_NONE.toString().equalsIgnoreCase(scope)) &#123;\n        // scope != remote，导出到本地\n        if (!Constants.SCOPE_REMOTE.toString().equalsIgnoreCase(scope)) &#123;\n            exportLocal(url);\n        &#125;\n\n        // scope != local，导出到远程\n        if (!Constants.SCOPE_LOCAL.toString().equalsIgnoreCase(scope)) &#123;\n            if (registryURLs != null &amp;&amp; !registryURLs.isEmpty()) &#123;\n                for (URL registryURL : registryURLs) &#123;\n                    url = url.addParameterIfAbsent(Constants.DYNAMIC_KEY, registryURL.getParameter(Constants.DYNAMIC_KEY));\n                    // 加载监视器链接\n                    URL monitorUrl = loadMonitor(registryURL);\n                    if (monitorUrl != null) &#123;\n                        // 将监视器链接作为参数添加到 url 中\n                        url = url.addParameterAndEncoded(Constants.MONITOR_KEY, monitorUrl.toFullString());\n                    &#125;\n\n                    String proxy = url.getParameter(Constants.PROXY_KEY);\n                    if (StringUtils.isNotEmpty(proxy)) &#123;\n                        registryURL = registryURL.addParameter(Constants.PROXY_KEY, proxy);\n                    &#125;\n\n                    // 为服务提供类(ref)生成 Invoker\n                    Invoker&lt;?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(Constants.EXPORT_KEY, url.toFullString()));\n                    // DelegateProviderMetaDataInvoker 用于持有 Invoker 和 ServiceConfig\n                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                    // 导出服务，并生成 Exporter\n                    Exporter&lt;?> exporter = protocol.export(wrapperInvoker);\n                    exporters.add(exporter);\n                &#125;\n                \n            // 不存在注册中心，仅导出服务\n            &#125; else &#123;\n                Invoker&lt;?> invoker = proxyFactory.getInvoker(ref, (Class) interfaceClass, url);\n                DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);\n\n                Exporter&lt;?> exporter = protocol.export(wrapperInvoker);\n                exporters.add(exporter);\n            &#125;\n        &#125;\n    &#125;\n    this.urls.add(url);\n&#125;\n\n\n\n上面代码根据 url 中的 scope 参数决定服务导出方式，分别如下：\n\nscope &#x3D; none，不导出服务\nscope !&#x3D; remote，导出到本地\nscope !&#x3D; local，导出到远程\n\n不管是导出到本地，还是远程。进行服务导出之前，均需要先创建 Invoker，这是一个很重要的步骤。因此下面先来分析 Invoker 的创建过程。\n\n2.2.1 Invoker 创建过程在 Dubbo 中，Invoker 是一个非常重要的模型。在服务提供端，以及服务引用端均会出现 Invoker。Dubbo 官方文档中对 Invoker 进行了说明，这里引用一下。\n\n\n\n\n\n\n\n\n\nInvoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。\n既然 Invoker 如此重要，那么我们很有必要搞清楚 Invoker 的用途。Invoker 是由 ProxyFactory 创建而来，Dubbo 默认的 ProxyFactory 实现类是 JavassistProxyFactory。下面我们到 JavassistProxyFactory 代码中，探索 Invoker 的创建过程。如下：\npublic &lt;T> Invoker&lt;T> getInvoker(T proxy, Class&lt;T> type, URL url) &#123;\n\t// 为目标类创建 Wrapper\n    final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') &lt; 0 ? proxy.getClass() : type);\n    // 创建匿名 Invoker 类对象，并实现 doInvoke 方法。\n    return new AbstractProxyInvoker&lt;T>(proxy, type, url) &#123;\n        @Override\n        protected Object doInvoke(T proxy, String methodName,\n                                  Class&lt;?>[] parameterTypes,\n                                  Object[] arguments) throws Throwable &#123;\n\t\t\t// 调用 Wrapper 的 invokeMethod 方法，invokeMethod 最终会调用目标方法\n            return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);\n        &#125;\n    &#125;;\n&#125;\n\n\n\n如上，JavassistProxyFactory 创建了一个继承自 AbstractProxyInvoker 类的匿名对象，并覆写了抽象方法 doInvoke。覆写后的 doInvoke 逻辑比较简单，仅是将调用请求转发给了 Wrapper 类的 invokeMethod 方法。Wrapper 用于“包裹”目标类，Wrapper 是一个抽象类，仅可通过 getWrapper(Class) 方法创建子类。在创建 Wrapper 子类的过程中，子类代码生成逻辑会对 getWrapper 方法传入的 Class 对象进行解析，拿到诸如类方法，类成员变量等信息。以及生成 invokeMethod 方法代码和其他一些方法代码。代码生成完毕后，通过 Javassist 生成 Class 对象，最后再通过反射创建 Wrapper 实例。相关的代码如下：\n public static Wrapper getWrapper(Class&lt;?> c) &#123;\t\n    while (ClassGenerator.isDynamicClass(c))\n        c = c.getSuperclass();\n\n    if (c == Object.class)\n        return OBJECT_WRAPPER;\n\n    // 从缓存中获取 Wrapper 实例\n    Wrapper ret = WRAPPER_MAP.get(c);\n    if (ret == null) &#123;\n        // 缓存未命中，创建 Wrapper\n        ret = makeWrapper(c);\n        // 写入缓存\n        WRAPPER_MAP.put(c, ret);\n    &#125;\n    return ret;\n&#125;\n\n\n\ngetWrapper 方法仅包含一些缓存操作逻辑，不难理解。下面我们看一下 makeWrapper 方法。\nprivate static Wrapper makeWrapper(Class&lt;?> c) &#123;\n    // 检测 c 是否为基本类型，若是则抛出异常\n    if (c.isPrimitive())\n        throw new IllegalArgumentException(\"Can not create wrapper for primitive type: \" + c);\n\n    String name = c.getName();\n    ClassLoader cl = ClassHelper.getClassLoader(c);\n\n    // c1 用于存储 setPropertyValue 方法代码\n    StringBuilder c1 = new StringBuilder(\"public void setPropertyValue(Object o, String n, Object v)&#123; \");\n    // c2 用于存储 getPropertyValue 方法代码\n    StringBuilder c2 = new StringBuilder(\"public Object getPropertyValue(Object o, String n)&#123; \");\n    // c3 用于存储 invokeMethod 方法代码\n    StringBuilder c3 = new StringBuilder(\"public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws \" + InvocationTargetException.class.getName() + \"&#123; \");\n\n    // 生成类型转换代码及异常捕捉代码，比如：\n    //   DemoService w; try &#123; w = ((DemoServcie) $1); &#125;&#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\n    c1.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\");\n    c2.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\");\n    c3.append(name).append(\" w; try&#123; w = ((\").append(name).append(\")$1); &#125;catch(Throwable e)&#123; throw new IllegalArgumentException(e); &#125;\");\n\n    // pts 用于存储成员变量名和类型\n    Map&lt;String, Class&lt;?>> pts = new HashMap&lt;String, Class&lt;?>>();\n    // ms 用于存储方法描述信息（可理解为方法签名）及 Method 实例\n    Map&lt;String, Method> ms = new LinkedHashMap&lt;String, Method>();\n    // mns 为方法名列表\n    List&lt;String> mns = new ArrayList&lt;String>();\n    // dmns 用于存储“定义在当前类中的方法”的名称\n    List&lt;String> dmns = new ArrayList&lt;String>();\n\n    // --------------------------------✨ 分割线1 ✨-------------------------------------\n\n    // 获取 public 访问级别的字段，并为所有字段生成条件判断语句\n    for (Field f : c.getFields()) &#123;\n        String fn = f.getName();\n        Class&lt;?> ft = f.getType();\n        if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers()))\n            // 忽略关键字 static 或 transient 修饰的变量\n            continue;\n\n        // 生成条件判断及赋值语句，比如：\n        // if( $2.equals(\"name\") ) &#123; w.name = (java.lang.String) $3; return;&#125;\n        // if( $2.equals(\"age\") ) &#123; w.age = ((Number) $3).intValue(); return;&#125;\n        c1.append(\" if( $2.equals(\\\"\").append(fn).append(\"\\\") )&#123; w.\").append(fn).append(\"=\").append(arg(ft, \"$3\")).append(\"; return; &#125;\");\n\n        // 生成条件判断及返回语句，比如：\n        // if( $2.equals(\"name\") ) &#123; return ($w)w.name; &#125;\n        c2.append(\" if( $2.equals(\\\"\").append(fn).append(\"\\\") )&#123; return ($w)w.\").append(fn).append(\"; &#125;\");\n\n        // 存储 &lt;字段名, 字段类型> 键值对到 pts 中\n        pts.put(fn, ft);\n    &#125;\n\n    // --------------------------------✨ 分割线2 ✨-------------------------------------\n\n    Method[] methods = c.getMethods();\n    // 检测 c 中是否包含在当前类中声明的方法\n    boolean hasMethod = hasMethods(methods);\n    if (hasMethod) &#123;\n        c3.append(\" try&#123;\");\n    &#125;\n    for (Method m : methods) &#123;\n        if (m.getDeclaringClass() == Object.class)\n            // 忽略 Object 中定义的方法\n            continue;\n\n        String mn = m.getName();\n        // 生成方法名判断语句，比如：\n        // if ( \"sayHello\".equals( $2 )\n        c3.append(\" if( \\\"\").append(mn).append(\"\\\".equals( $2 ) \");\n        int len = m.getParameterTypes().length;\n        // 生成“运行时传入的参数数量与方法参数列表长度”判断语句，比如：\n        // &amp;&amp; $3.length == 2\n        c3.append(\" &amp;&amp; \").append(\" $3.length == \").append(len);\n\n        boolean override = false;\n        for (Method m2 : methods) &#123;\n            // 检测方法是否存在重载情况，条件为：方法对象不同 &amp;&amp; 方法名相同\n            if (m != m2 &amp;&amp; m.getName().equals(m2.getName())) &#123;\n                override = true;\n                break;\n            &#125;\n        &#125;\n        // 对重载方法进行处理，考虑下面的方法：\n        //    1. void sayHello(Integer, String)\n        //    2. void sayHello(Integer, Integer)\n        // 方法名相同，参数列表长度也相同，因此不能仅通过这两项判断两个方法是否相等。\n        // 需要进一步判断方法的参数类型\n        if (override) &#123;\n            if (len > 0) &#123;\n                for (int l = 0; l &lt; len; l++) &#123;\n                    // 生成参数类型进行检测代码，比如：\n                    // &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") \n                    //    &amp;&amp; $3[1].getName().equals(\"java.lang.String\")\n                    c3.append(\" &amp;&amp; \").append(\" $3[\").append(l).append(\"].getName().equals(\\\"\")\n                            .append(m.getParameterTypes()[l].getName()).append(\"\\\")\");\n                &#125;\n            &#125;\n        &#125;\n\n        // 添加 ) &#123;，完成方法判断语句，此时生成的代码可能如下（已格式化）：\n        // if (\"sayHello\".equals($2) \n        //     &amp;&amp; $3.length == 2\n        //     &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") \n        //     &amp;&amp; $3[1].getName().equals(\"java.lang.String\")) &#123;\n        c3.append(\" ) &#123; \");\n\n        // 根据返回值类型生成目标方法调用语句\n        if (m.getReturnType() == Void.TYPE)\n            // w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); return null;\n            c3.append(\" w.\").append(mn).append('(').append(args(m.getParameterTypes(), \"$4\")).append(\");\").append(\" return null;\");\n        else\n            // return w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);\n            c3.append(\" return ($w)w.\").append(mn).append('(').append(args(m.getParameterTypes(), \"$4\")).append(\");\");\n\n        // 添加 &#125;, 生成的代码形如（已格式化）：\n        // if (\"sayHello\".equals($2) \n        //     &amp;&amp; $3.length == 2\n        //     &amp;&amp; $3[0].getName().equals(\"java.lang.Integer\") \n        //     &amp;&amp; $3[1].getName().equals(\"java.lang.String\")) &#123;\n        //\n        //     w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); \n        //     return null;\n        // &#125;\n        c3.append(\" &#125;\");\n\n        // 添加方法名到 mns 集合中\n        mns.add(mn);\n        // 检测当前方法是否在 c 中被声明的\n        if (m.getDeclaringClass() == c)\n            // 若是，则将当前方法名添加到 dmns 中\n            dmns.add(mn);\n        ms.put(ReflectUtils.getDesc(m), m);\n    &#125;\n    if (hasMethod) &#123;\n        // 添加异常捕捉语句\n        c3.append(\" &#125; catch(Throwable e) &#123; \");\n        c3.append(\"     throw new java.lang.reflect.InvocationTargetException(e); \");\n        c3.append(\" &#125;\");\n    &#125;\n\n    // 添加 NoSuchMethodException 异常抛出代码\n    c3.append(\" throw new \" + NoSuchMethodException.class.getName() + \"(\\\"Not found method \\\\\\\"\\\"+$2+\\\"\\\\\\\" in class \" + c.getName() + \".\\\"); &#125;\");\n\n    // --------------------------------✨ 分割线3 ✨-------------------------------------\n\n    Matcher matcher;\n    // 处理 get/set 方法\n    for (Map.Entry&lt;String, Method> entry : ms.entrySet()) &#123;\n        String md = entry.getKey();\n        Method method = (Method) entry.getValue();\n        // 匹配以 get 开头的方法\n        if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;\n            // 获取属性名\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及返回语句，示例如下：\n            // if( $2.equals(\"name\") ) &#123; return ($w).w.getName(); &#125;\n            c2.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; return ($w)w.\").append(method.getName()).append(\"(); &#125;\");\n            pts.put(pn, method.getReturnType());\n\n        // 匹配以 is/has/can 开头的方法\n        &#125; else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及返回语句，示例如下：\n            // if( $2.equals(\"dream\") ) &#123; return ($w).w.hasDream(); &#125;\n            c2.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; return ($w)w.\").append(method.getName()).append(\"(); &#125;\");\n            pts.put(pn, method.getReturnType());\n\n        // 匹配以 set 开头的方法\n        &#125; else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) &#123;\n            Class&lt;?> pt = method.getParameterTypes()[0];\n            String pn = propertyName(matcher.group(1));\n            // 生成属性判断以及 setter 调用语句，示例如下：\n            // if( $2.equals(\"name\") ) &#123; w.setName((java.lang.String)$3); return; &#125;\n            c1.append(\" if( $2.equals(\\\"\").append(pn).append(\"\\\") )&#123; w.\").append(method.getName()).append(\"(\").append(arg(pt, \"$3\")).append(\"); return; &#125;\");\n            pts.put(pn, pt);\n        &#125;\n    &#125;\n\n    // 添加 NoSuchPropertyException 异常抛出代码\n    c1.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); &#125;\");\n    c2.append(\" throw new \" + NoSuchPropertyException.class.getName() + \"(\\\"Not found property \\\\\\\"\\\"+$2+\\\"\\\\\\\" filed or setter method in class \" + c.getName() + \".\\\"); &#125;\");\n\n    // --------------------------------✨ 分割线4 ✨-------------------------------------\n\n    long id = WRAPPER_CLASS_COUNTER.getAndIncrement();\n    // 创建类生成器\n    ClassGenerator cc = ClassGenerator.newInstance(cl);\n    // 设置类名及超类\n    cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + \"$sw\") + id);\n    cc.setSuperClass(Wrapper.class);\n\n    // 添加默认构造方法\n    cc.addDefaultConstructor();\n\n    // 添加字段\n    cc.addField(\"public static String[] pns;\");\n    cc.addField(\"public static \" + Map.class.getName() + \" pts;\");\n    cc.addField(\"public static String[] mns;\");\n    cc.addField(\"public static String[] dmns;\");\n    for (int i = 0, len = ms.size(); i &lt; len; i++)\n        cc.addField(\"public static Class[] mts\" + i + \";\");\n\n    // 添加方法代码\n    cc.addMethod(\"public String[] getPropertyNames()&#123; return pns; &#125;\");\n    cc.addMethod(\"public boolean hasProperty(String n)&#123; return pts.containsKey($1); &#125;\");\n    cc.addMethod(\"public Class getPropertyType(String n)&#123; return (Class)pts.get($1); &#125;\");\n    cc.addMethod(\"public String[] getMethodNames()&#123; return mns; &#125;\");\n    cc.addMethod(\"public String[] getDeclaredMethodNames()&#123; return dmns; &#125;\");\n    cc.addMethod(c1.toString());\n    cc.addMethod(c2.toString());\n    cc.addMethod(c3.toString());\n\n    try &#123;\n        // 生成类\n        Class&lt;?> wc = cc.toClass();\n        \n        // 设置字段值\n        wc.getField(\"pts\").set(null, pts);\n        wc.getField(\"pns\").set(null, pts.keySet().toArray(new String[0]));\n        wc.getField(\"mns\").set(null, mns.toArray(new String[0]));\n        wc.getField(\"dmns\").set(null, dmns.toArray(new String[0]));\n        int ix = 0;\n        for (Method m : ms.values())\n            wc.getField(\"mts\" + ix++).set(null, m.getParameterTypes());\n\n        // 创建 Wrapper 实例\n        return (Wrapper) wc.newInstance();\n    &#125; catch (RuntimeException e) &#123;\n        throw e;\n    &#125; catch (Throwable e) &#123;\n        throw new RuntimeException(e.getMessage(), e);\n    &#125; finally &#123;\n        cc.release();\n        ms.clear();\n        mns.clear();\n        dmns.clear();\n    &#125;\n&#125;\n\n\n\n上面代码很长，大家耐心看一下。我们在上面代码中做了大量的注释，并按功能对代码进行了分块，以帮助大家理解代码逻辑。下面对这段代码进行讲解。首先我们把目光移到分割线1之上的代码，这段代码主要用于进行一些初始化操作。比如创建 c1、c2、c3 以及 pts、ms、mns 等变量，以及向 c1、c2、c3 中添加方法定义和类型转换代码。接下来是分割线1到分割线2之间的代码，这段代码用于为 public 级别的字段生成条件判断取值与赋值代码。这段代码不是很难看懂，就不多说了。继续向下看，分割线2和分隔线3之间的代码用于为定义在当前类中的方法生成判断语句，和方法调用语句。因为需要对方法重载进行校验，因此到这这段代码看起来有点复杂。不过耐心看一下，也不是很难理解。接下来是分割线3和分隔线4之间的代码，这段代码用于处理 getter、setter 以及以 is&#x2F;has&#x2F;can 开头的方法。处理方式是通过正则表达式获取方法类型（get&#x2F;set&#x2F;is&#x2F;…），以及属性名。之后为属性名生成判断语句，然后为方法生成调用语句。最后我们再来看一下分隔线4以下的代码，这段代码通过 ClassGenerator 为刚刚生成的代码构建 Class 类，并通过反射创建对象。ClassGenerator 是 Dubbo 自己封装的，该类的核心是 toClass() 的重载方法 toClass(ClassLoader, ProtectionDomain)，该方法通过 javassist 构建 Class。这里就不分析 toClass 方法了，大家请自行分析。\n阅读 Wrapper 类代码需要对 javassist 框架有所了解。关于 javassist，大家如果不熟悉，请自行查阅资料，本节不打算介绍 javassist 相关内容。\n好了，关于 Wrapper 类生成过程就分析到这。如果大家看的不是很明白，可以单独为 Wrapper 创建单元测试，然后单步调试。并将生成的代码拷贝出来，格式化后再进行观察和理解。\n\n2.2.2 导出服务到本地本节我们来看一下服务导出相关的代码，按照代码执行顺序，本节先来分析导出服务到本地的过程。相关代码如下：\nprivate void exportLocal(URL url) &#123;\n    // 如果 URL 的协议头等于 injvm，说明已经导出到本地了，无需再次导出\n    if (!Constants.LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) &#123;\n        URL local = URL.valueOf(url.toFullString())\n            .setProtocol(Constants.LOCAL_PROTOCOL)    // 设置协议头为 injvm\n            .setHost(LOCALHOST)\n            .setPort(0);\n        ServiceClassHolder.getInstance().pushServiceClass(getServiceClass(ref));\n        // 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法\n        Exporter&lt;?> exporter = protocol.export(\n            proxyFactory.getInvoker(ref, (Class) interfaceClass, local));\n        exporters.add(exporter);\n    &#125;\n&#125;\n\n\n\nexportLocal 方法比较简单，首先根据 URL 协议头决定是否导出服务。若需导出，则创建一个新的 URL 并将协议头、主机名以及端口设置成新的值。然后创建 Invoker，并调用 InjvmProtocol 的 export 方法导出服务。下面我们来看一下 InjvmProtocol 的 export 方法都做了哪些事情。\npublic &lt;T> Exporter&lt;T> export(Invoker&lt;T> invoker) throws RpcException &#123;\n    // 创建 InjvmExporter\n    return new InjvmExporter&lt;T>(invoker, invoker.getUrl().getServiceKey(), exporterMap);\n&#125;\n\n\n\n如上，InjvmProtocol 的 export 方法仅创建了一个 InjvmExporter，无其他逻辑。到此导出服务到本地就分析完了，接下来，我们继续分析导出服务到远程的过程。\n\n2.2.3 导出服务到远程与导出服务到本地相比，导出服务到远程的过程要复杂不少，其包含了服务导出与服务注册两个过程。这两个过程涉及到了大量的调用，比较复杂。按照代码执行顺序，本节先来分析服务导出逻辑，服务注册逻辑将在下一节进行分析。下面开始分析，我们把目光移动到 RegistryProtocol 的 export 方法上。\npublic &lt;T> Exporter&lt;T> export(final Invoker&lt;T> originInvoker) throws RpcException &#123;\n    // 导出服务\n    final ExporterChangeableWrapper&lt;T> exporter = doLocalExport(originInvoker);\n\n    // 获取注册中心 URL，以 zookeeper 注册中心为例，得到的示例 URL 如下：\n    // zookeeper://127.0.0.1:2181/com.alibaba.dubbo.registry.RegistryService?application=demo-provider&amp;dubbo=2.0.2&amp;export=dubbo%3A%2F%2F172.17.48.52%3A20880%2Fcom.alibaba.dubbo.demo.DemoService%3Fanyhost%3Dtrue%26application%3Ddemo-provider\n    URL registryUrl = getRegistryUrl(originInvoker);\n\n    // 根据 URL 加载 Registry 实现类，比如 ZookeeperRegistry\n    final Registry registry = getRegistry(originInvoker);\n    \n    // 获取已注册的服务提供者 URL，比如：\n    // dubbo://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello\n    final URL registeredProviderUrl = getRegisteredProviderUrl(originInvoker);\n\n    // 获取 register 参数\n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n\n    // 向服务提供者与消费者注册表中注册服务提供者\n    ProviderConsumerRegTable.registerProvider(originInvoker, registryUrl, registeredProviderUrl);\n\n    // 根据 register 的值决定是否注册服务\n    if (register) &#123;\n        // 向注册中心注册服务\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    &#125;\n\n    // 获取订阅 URL，比如：\n    // provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&amp;check=false&amp;anyhost=true&amp;application=demo-provider&amp;dubbo=2.0.2&amp;generic=false&amp;interface=com.alibaba.dubbo.demo.DemoService&amp;methods=sayHello\n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    // 创建监听器\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    // 向注册中心进行订阅 override 数据\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n    // 创建并返回 DestroyableExporter\n    return new DestroyableExporter&lt;T>(exporter, originInvoker, overrideSubscribeUrl, registeredProviderUrl);\n&#125;\n\n\n\n\n上面代码看起来比较复杂，主要做如下一些操作：\n\n调用 doLocalExport 导出服务\n向注册中心注册服务\n向注册中心进行订阅 override 数据\n创建并返回 DestroyableExporter\n\n在以上操作中，除了创建并返回 DestroyableExporter 没什么难度外，其他几步操作都不是很简单。这其中，导出服务和注册服务是本章要重点分析的逻辑。 订阅 override 数据并非本文重点内容，后面会简单介绍一下。下面先来分析 doLocalExport 方法的逻辑，如下：\nprivate &lt;T> ExporterChangeableWrapper&lt;T> doLocalExport(final Invoker&lt;T> originInvoker) &#123;\n    String key = getCacheKey(originInvoker);\n    // 访问缓存\n    ExporterChangeableWrapper&lt;T> exporter = (ExporterChangeableWrapper&lt;T>) bounds.get(key);\n    if (exporter == null) &#123;\n        synchronized (bounds) &#123;\n            exporter = (ExporterChangeableWrapper&lt;T>) bounds.get(key);\n            if (exporter == null) &#123;\n                // 创建 Invoker 为委托类对象\n                final Invoker&lt;?> invokerDelegete = new InvokerDelegete&lt;T>(originInvoker, getProviderUrl(originInvoker));\n                // 调用 protocol 的 export 方法导出服务\n                exporter = new ExporterChangeableWrapper&lt;T>((Exporter&lt;T>) protocol.export(invokerDelegete), originInvoker);\n                \n                // 写缓存\n                bounds.put(key, exporter);\n            &#125;\n        &#125;\n    &#125;\n    return exporter;\n&#125;\n\n\n\n\n上面的代码是典型的双重检查锁，大家在阅读 Dubbo 的源码中，会多次见到。接下来，我们把重点放在 Protocol 的 export 方法上。假设运行时协议为 dubbo，此处的 protocol 变量会在运行时加载 DubboProtocol，并调用 DubboProtocol 的 export 方法。所以，接下来我们目光转移到 DubboProtocol 的 export 方法上，相关分析如下：\npublic &lt;T> Exporter&lt;T> export(Invoker&lt;T> invoker) throws RpcException &#123;\n    URL url = invoker.getUrl();\n\n    // 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：\n    // demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880\n    String key = serviceKey(url);\n    // 创建 DubboExporter\n    DubboExporter&lt;T> exporter = new DubboExporter&lt;T>(invoker, key, exporterMap);\n    // 将 &lt;key, exporter> 键值对放入缓存中\n    exporterMap.put(key, exporter);\n\n    // 本地存根相关代码\n    Boolean isStubSupportEvent = url.getParameter(Constants.STUB_EVENT_KEY, Constants.DEFAULT_STUB_EVENT);\n    Boolean isCallbackservice = url.getParameter(Constants.IS_CALLBACK_SERVICE, false);\n    if (isStubSupportEvent &amp;&amp; !isCallbackservice) &#123;\n        String stubServiceMethods = url.getParameter(Constants.STUB_EVENT_METHODS_KEY);\n        if (stubServiceMethods == null || stubServiceMethods.length() == 0) &#123;\n            // 省略日志打印代码\n        &#125; else &#123;\n            stubServiceMethodsMap.put(url.getServiceKey(), stubServiceMethods);\n        &#125;\n    &#125;\n\n    // 启动服务器\n    openServer(url);\n    // 优化序列化\n    optimizeSerialization(url);\n    return exporter;\n&#125;\n\n\n\n\n如上，我们重点关注 DubboExporter 的创建以及 openServer 方法，其他逻辑看不懂也没关系，不影响理解服务导出过程。另外，DubboExporter 的代码比较简单，就不分析了。下面分析 openServer 方法。\nprivate void openServer(URL url) &#123;\n    // 获取 host:port，并将其作为服务器实例的 key，用于标识当前的服务器实例\n    String key = url.getAddress();\n    boolean isServer = url.getParameter(Constants.IS_SERVER_KEY, true);\n    if (isServer) &#123;\n        // 访问缓存\n        ExchangeServer server = serverMap.get(key);\n        if (server == null) &#123;\n            // 创建服务器实例\n            serverMap.put(key, createServer(url));\n        &#125; else &#123;\n            // 服务器已创建，则根据 url 中的配置重置服务器\n            server.reset(url);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n如上，在同一台机器上（单网卡），同一个端口上仅允许启动一个服务器实例。若某个端口上已有服务器实例，此时则调用 reset 方法重置服务器的一些配置。考虑到篇幅问题，关于服务器实例重置的代码就不分析了。接下来分析服务器实例的创建过程。如下：\nprivate ExchangeServer createServer(URL url) &#123;\n    url = url.addParameterIfAbsent(Constants.CHANNEL_READONLYEVENT_SENT_KEY,\n    // 添加心跳检测配置到 url 中\n    url = url.addParameterIfAbsent(Constants.HEARTBEAT_KEY, String.valueOf(Constants.DEFAULT_HEARTBEAT));\n\t// 获取 server 参数，默认为 netty\n    String str = url.getParameter(Constants.SERVER_KEY, Constants.DEFAULT_REMOTING_SERVER);\n\n\t// 通过 SPI 检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常\n    if (str != null &amp;&amp; str.length() > 0 &amp;&amp; !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str))\n        throw new RpcException(\"Unsupported server type: \" + str + \", url: \" + url);\n\n    // 添加编码解码器参数\n    url = url.addParameter(Constants.CODEC_KEY, DubboCodec.NAME);\n    ExchangeServer server;\n    try &#123;\n        // 创建 ExchangeServer\n        server = Exchangers.bind(url, requestHandler);\n    &#125; catch (RemotingException e) &#123;\n        throw new RpcException(\"Fail to start server...\");\n    &#125;\n                                   \n\t// 获取 client 参数，可指定 netty，mina\n    str = url.getParameter(Constants.CLIENT_KEY);\n    if (str != null &amp;&amp; str.length() > 0) &#123;\n        // 获取所有的 Transporter 实现类名称集合，比如 supportedTypes = [netty, mina]\n        Set&lt;String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();\n        // 检测当前 Dubbo 所支持的 Transporter 实现类名称列表中，\n        // 是否包含 client 所表示的 Transporter，若不包含，则抛出异常\n        if (!supportedTypes.contains(str)) &#123;\n            throw new RpcException(\"Unsupported client type...\");\n        &#125;\n    &#125;\n    return server;\n&#125;\n\n\n\n\n如上，createServer 包含三个核心的逻辑。第一是检测是否存在 server 参数所代表的 Transporter 拓展，不存在则抛出异常。第二是创建服务器实例。第三是检测是否支持 client 参数所表示的 Transporter 拓展，不存在也是抛出异常。两次检测操作所对应的代码比较直白了，无需多说。但创建服务器的操作目前还不是很清晰，我们继续往下看。\npublic static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;\n    if (url == null) &#123;\n        throw new IllegalArgumentException(\"url == null\");\n    &#125;\n    if (handler == null) &#123;\n        throw new IllegalArgumentException(\"handler == null\");\n    &#125;\n    url = url.addParameterIfAbsent(Constants.CODEC_KEY, \"exchange\");\n    // 获取 Exchanger，默认为 HeaderExchanger。\n    // 紧接着调用 HeaderExchanger 的 bind 方法创建 ExchangeServer 实例\n    return getExchanger(url).bind(url, handler);\n&#125;\n\n\n\n\n上面代码比较简单，就不多说了。下面看一下 HeaderExchanger 的 bind 方法。\npublic ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException &#123;\n\t// 创建 HeaderExchangeServer 实例，该方法包含了多个逻辑，分别如下：\n\t//   1. new HeaderExchangeHandler(handler)\n\t//\t 2. new DecodeHandler(new HeaderExchangeHandler(handler))\n\t//   3. Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler)))\n    return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));\n&#125;\n\n\n\n\nHeaderExchanger 的 bind 方法包含的逻辑比较多，但目前我们仅需关心 Transporters 的 bind 方法逻辑即可。该方法的代码如下：\npublic static Server bind(URL url, ChannelHandler... handlers) throws RemotingException &#123;\n    if (url == null) &#123;\n        throw new IllegalArgumentException(\"url == null\");\n    &#125;\n    if (handlers == null || handlers.length == 0) &#123;\n        throw new IllegalArgumentException(\"handlers == null\");\n    &#125;\n    ChannelHandler handler;\n    if (handlers.length == 1) &#123;\n        handler = handlers[0];\n    &#125; else &#123;\n    \t// 如果 handlers 元素数量大于1，则创建 ChannelHandler 分发器\n        handler = new ChannelHandlerDispatcher(handlers);\n    &#125;\n    // 获取自适应 Transporter 实例，并调用实例方法\n    return getTransporter().bind(url, handler);\n&#125;\n\n\n\n\n如上，getTransporter() 方法获取的 Transporter 是在运行时动态创建的，类名为 TransporterAdaptive 会在运行时根据传入的 URL 参数决定加载什么类型的 Transporter，默认为 NettyTransporter。下面我们继续跟下去，这次分析的是 NettyTransporter 的 bind 方法。\npublic Server bind(URL url, ChannelHandler listener) throws RemotingException &#123;\n\t// 创建 NettyServer\n\treturn new NettyServer(url, listener);\n&#125;\n\n\n\n\n这里仅有一句创建 NettyServer 的代码，无需多说，我们继续向下看。\npublic class NettyServer extends AbstractServer implements Server &#123;\n    public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123;\n        // 调用父类构造方法\n        super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));\n    &#125;\n&#125;\n\n\npublic abstract class AbstractServer extends AbstractEndpoint implements Server &#123;\n    public AbstractServer(URL url, ChannelHandler handler) throws RemotingException &#123;\n        // 调用父类构造方法，这里就不用跟进去了，没什么复杂逻辑\n        super(url, handler);\n        localAddress = getUrl().toInetSocketAddress();\n\n        // 获取 ip 和端口\n        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());\n        int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());\n        if (url.getParameter(Constants.ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) &#123;\n            // 设置 ip 为 0.0.0.0\n            bindIp = NetUtils.ANYHOST;\n        &#125;\n        bindAddress = new InetSocketAddress(bindIp, bindPort);\n        // 获取最大可接受连接数\n        this.accepts = url.getParameter(Constants.ACCEPTS_KEY, Constants.DEFAULT_ACCEPTS);\n        this.idleTimeout = url.getParameter(Constants.IDLE_TIMEOUT_KEY, Constants.DEFAULT_IDLE_TIMEOUT);\n        try &#123;\n            // 调用模板方法 doOpen 启动服务器\n            doOpen();\n        &#125; catch (Throwable t) &#123;\n            throw new RemotingException(\"Failed to bind \");\n        &#125;\n\n        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();\n        executor = (ExecutorService) dataStore.get(Constants.EXECUTOR_SERVICE_COMPONENT_KEY, Integer.toString(url.getPort()));\n    &#125;\n    \n    protected abstract void doOpen() throws Throwable;\n\n    protected abstract void doClose() throws Throwable;\n&#125;\n\n\n\n\n上面代码多为赋值代码，不需要多讲。我们重点关注 doOpen 抽象方法，该方法需要子类实现。下面回到 NettyServer 中。\nprotected void doOpen() throws Throwable &#123;\n    NettyHelper.setNettyLoggerFactory();\n    // 创建 boss 和 worker 线程池\n    ExecutorService boss = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerBoss\", true));\n    ExecutorService worker = Executors.newCachedThreadPool(new NamedThreadFactory(\"NettyServerWorker\", true));\n    ChannelFactory channelFactory = new NioServerSocketChannelFactory(boss, worker, getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS));\n    \n    // 创建 ServerBootstrap\n    bootstrap = new ServerBootstrap(channelFactory);\n\n    final NettyHandler nettyHandler = new NettyHandler(getUrl(), this);\n    channels = nettyHandler.getChannels();\n    bootstrap.setOption(\"child.tcpNoDelay\", true);\n    // 设置 PipelineFactory\n    bootstrap.setPipelineFactory(new ChannelPipelineFactory() &#123;\n        @Override\n        public ChannelPipeline getPipeline() &#123;\n            NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);\n            ChannelPipeline pipeline = Channels.pipeline();\n            pipeline.addLast(\"decoder\", adapter.getDecoder());\n            pipeline.addLast(\"encoder\", adapter.getEncoder());\n            pipeline.addLast(\"handler\", nettyHandler);\n            return pipeline;\n        &#125;\n    &#125;);\n    // 绑定到指定的 ip 和端口上\n    channel = bootstrap.bind(getBindAddress());\n&#125;\n\n\n\n\n以上就是 NettyServer 创建的过程，dubbo 默认使用的 NettyServer 是基于 netty 3.x 版本实现的，比较老了。因此 Dubbo 另外提供了 netty 4.x 版本的 NettyServer，大家可在使用 Dubbo 的过程中按需进行配置。\n到此，关于服务导出的过程就分析完了。整个过程比较复杂，大家在分析的过程中耐心一些。并且多写 Demo 进行调试，以便能够更好的理解代码逻辑。\n本节内容先到这里，接下来分析服务导出的另一块逻辑 — 服务注册。\n\n2.2.4 服务注册本节我们来分析服务注册过程，服务注册操作对于 Dubbo 来说不是必需的，通过服务直连的方式就可以绕过注册中心。但通常我们不会这么做，直连方式不利于服务治理，仅推荐在测试服务时使用。对于 Dubbo 来说，注册中心虽不是必需，但却是必要的。因此，关于注册中心以及服务注册相关逻辑，我们也需要搞懂。\n本节内容以 Zookeeper 注册中心作为分析目标，其他类型注册中心大家可自行分析。下面从服务注册的入口方法开始分析，我们把目光再次移到 RegistryProtocol 的 export 方法上。如下：\npublic &lt;T> Exporter&lt;T> export(final Invoker&lt;T> originInvoker) throws RpcException &#123;\n    \n    // $&#123;导出服务&#125;\n    \n    // 省略其他代码\n    \n    boolean register = registeredProviderUrl.getParameter(\"register\", true);\n    if (register) &#123;\n        // 注册服务\n        register(registryUrl, registeredProviderUrl);\n        ProviderConsumerRegTable.getProviderWrapper(originInvoker).setReg(true);\n    &#125;\n    \n    final URL overrideSubscribeUrl = getSubscribedOverrideUrl(registeredProviderUrl);\n    final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);\n    overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);\n    // 订阅 override 数据\n    registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);\n\n    // 省略部分代码\n&#125;\n\n\n\n\nRegistryProtocol 的 export 方法包含了服务导出，注册，以及数据订阅等逻辑。其中服务导出逻辑上一节已经分析过了，本节将分析服务注册逻辑，相关代码如下：\npublic void register(URL registryUrl, URL registedProviderUrl) &#123;\n    // 获取 Registry\n    Registry registry = registryFactory.getRegistry(registryUrl);\n    // 注册服务\n    registry.register(registedProviderUrl);\n&#125;\n\n\n\n\nregister 方法包含两步操作，第一步是获取注册中心实例，第二步是向注册中心注册服务。接下来分两节内容对这两步操作进行分析。\n\n2.2.4.1 创建注册中心本节内容以 Zookeeper 注册中心为例进行分析。下面先来看一下 getRegistry 方法的源码，这个方法由 AbstractRegistryFactory 实现。如下：\npublic Registry getRegistry(URL url) &#123;\n    url = url.setPath(RegistryService.class.getName())\n            .addParameter(Constants.INTERFACE_KEY, RegistryService.class.getName())\n            .removeParameters(Constants.EXPORT_KEY, Constants.REFER_KEY);\n    String key = url.toServiceString();\n    LOCK.lock();\n    try &#123;\n    \t// 访问缓存\n        Registry registry = REGISTRIES.get(key);\n        if (registry != null) &#123;\n            return registry;\n        &#125;\n        \n        // 缓存未命中，创建 Registry 实例\n        registry = createRegistry(url);\n        if (registry == null) &#123;\n            throw new IllegalStateException(\"Can not create registry...\");\n        &#125;\n        \n        // 写入缓存\n        REGISTRIES.put(key, registry);\n        return registry;\n    &#125; finally &#123;\n        LOCK.unlock();\n    &#125;\n&#125;\n\nprotected abstract Registry createRegistry(URL url);\n\n\n\n\n如上，getRegistry 方法先访问缓存，缓存未命中则调用 createRegistry 创建 Registry，然后写入缓存。这里的 createRegistry 是一个模板方法，由具体的子类实现。因此，下面我们到 ZookeeperRegistryFactory 中探究一番。\npublic class ZookeeperRegistryFactory extends AbstractRegistryFactory &#123;\n\n    // zookeeperTransporter 由 SPI 在运行时注入，类型为 ZookeeperTransporter$Adaptive\n    private ZookeeperTransporter zookeeperTransporter;\n\n    public void setZookeeperTransporter(ZookeeperTransporter zookeeperTransporter) &#123;\n        this.zookeeperTransporter = zookeeperTransporter;\n    &#125;\n\n    @Override\n    public Registry createRegistry(URL url) &#123;\n        // 创建 ZookeeperRegistry\n        return new ZookeeperRegistry(url, zookeeperTransporter);\n    &#125;\n&#125;\n\n\n\n\nZookeeperRegistryFactory 的 createRegistry 方法仅包含一句代码，无需解释，继续跟下去。\npublic ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) &#123;\n    super(url);\n    if (url.isAnyHost()) &#123;\n        throw new IllegalStateException(\"registry address == null\");\n    &#125;\n    \n    // 获取组名，默认为 dubbo\n    String group = url.getParameter(Constants.GROUP_KEY, DEFAULT_ROOT);\n    if (!group.startsWith(Constants.PATH_SEPARATOR)) &#123;\n        // group = \"/\" + group\n        group = Constants.PATH_SEPARATOR + group;\n    &#125;\n    this.root = group;\n    // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter\n    zkClient = zookeeperTransporter.connect(url);\n    // 添加状态监听器\n    zkClient.addStateListener(new StateListener() &#123;\n        @Override\n        public void stateChanged(int state) &#123;\n            if (state == RECONNECTED) &#123;\n                try &#123;\n                    recover();\n                &#125; catch (Exception e) &#123;\n                    logger.error(e.getMessage(), e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;);\n&#125;\n\n\n\n\n在上面的代码代码中，我们重点关注 ZookeeperTransporter 的 connect 方法调用，这个方法用于创建 Zookeeper 客户端。创建好 Zookeeper 客户端，意味着注册中心的创建过程就结束了。接下来，再来分析一下 Zookeeper 客户端的创建过程。\n前面说过，这里的 zookeeperTransporter 类型为自适应拓展类，因此 connect 方法会在被调用时决定加载什么类型的 ZookeeperTransporter 拓展，默认为 CuratorZookeeperTransporter。下面我们到 CuratorZookeeperTransporter 中看一看。\npublic ZookeeperClient connect(URL url) &#123;\n    // 创建 CuratorZookeeperClient\n    return new CuratorZookeeperClient(url);\n&#125;\n\n\n\n\n继续向下看。\npublic class CuratorZookeeperClient extends AbstractZookeeperClient&lt;CuratorWatcher> &#123;\n\n    private final CuratorFramework client;\n    \n    public CuratorZookeeperClient(URL url) &#123;\n        super(url);\n        try &#123;\n            // 创建 CuratorFramework 构造器\n            CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()\n                    .connectString(url.getBackupAddress())\n                    .retryPolicy(new RetryNTimes(1, 1000))\n                    .connectionTimeoutMs(5000);\n            String authority = url.getAuthority();\n            if (authority != null &amp;&amp; authority.length() > 0) &#123;\n                builder = builder.authorization(\"digest\", authority.getBytes());\n            &#125;\n            // 构建 CuratorFramework 实例\n            client = builder.build();\n            // 添加监听器\n            client.getConnectionStateListenable().addListener(new ConnectionStateListener() &#123;\n                @Override\n                public void stateChanged(CuratorFramework client, ConnectionState state) &#123;\n                    if (state == ConnectionState.LOST) &#123;\n                        CuratorZookeeperClient.this.stateChanged(StateListener.DISCONNECTED);\n                    &#125; else if (state == ConnectionState.CONNECTED) &#123;\n                        CuratorZookeeperClient.this.stateChanged(StateListener.CONNECTED);\n                    &#125; else if (state == ConnectionState.RECONNECTED) &#123;\n                        CuratorZookeeperClient.this.stateChanged(StateListener.RECONNECTED);\n                    &#125;\n                &#125;\n            &#125;);\n            \n            // 启动客户端\n            client.start();\n        &#125; catch (Exception e) &#123;\n            throw new IllegalStateException(e.getMessage(), e);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\nCuratorZookeeperClient 构造方法主要用于创建和启动 CuratorFramework 实例。以上基本上都是 Curator 框架的代码，大家如果对 Curator 框架不是很了解，可以参考 Curator 官方文档。\n本节分析了 ZookeeperRegistry 实例的创建过程，整个过程并不是很复杂。大家在看完分析后，可以自行调试，以加深理解。现在注册中心实例创建好了，接下来要做的事情是向注册中心注册服务，我们继续往下看。\n\n2.2.4.2 节点创建以 Zookeeper 为例，所谓的服务注册，本质上是将服务配置数据写入到 Zookeeper 的某个路径的节点下。为了让大家有一个直观的了解，下面我们将 Dubbo 的 demo 跑起来，然后通过 Zookeeper 可视化客户端 ZooInspector 查看节点数据。如下：\n\n从上图中可以看到 com.alibaba.dubbo.demo.DemoService 这个服务对应的配置信息（存储在 URL 中）最终被注册到了 &#x2F;dubbo&#x2F;com.alibaba.dubbo.demo.DemoService&#x2F;providers&#x2F; 节点下。搞懂了服务注册的本质，那么接下来我们就可以去阅读服务注册的代码了。服务注册的接口为 register(URL)，这个方法定义在 FailbackRegistry 抽象类中。代码如下：\npublic void register(URL url) &#123;\n    super.register(url);\n    failedRegistered.remove(url);\n    failedUnregistered.remove(url);\n    try &#123;\n        // 模板方法，由子类实现\n        doRegister(url);\n    &#125; catch (Exception e) &#123;\n        Throwable t = e;\n\n        // 获取 check 参数，若 check = true 将会直接抛出异常\n        boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)\n                &amp;&amp; url.getParameter(Constants.CHECK_KEY, true)\n                &amp;&amp; !Constants.CONSUMER_PROTOCOL.equals(url.getProtocol());\n        boolean skipFailback = t instanceof SkipFailbackWrapperException;\n        if (check || skipFailback) &#123;\n            if (skipFailback) &#123;\n                t = t.getCause();\n            &#125;\n            throw new IllegalStateException(\"Failed to register\");\n        &#125; else &#123;\n            logger.error(\"Failed to register\");\n        &#125;\n\n        // 记录注册失败的链接\n        failedRegistered.add(url);\n    &#125;\n&#125;\n\nprotected abstract void doRegister(URL url);\n\n\n\n\n如上，我们重点关注 doRegister 方法调用即可，其他的代码先忽略。doRegister 方法是一个模板方法，因此我们到 FailbackRegistry 子类 ZookeeperRegistry 中进行分析。如下：\nprotected void doRegister(URL url) &#123;\n    try &#123;\n        // 通过 Zookeeper 客户端创建节点，节点路径由 toUrlPath 方法生成，路径格式如下:\n        //   /$&#123;group&#125;/$&#123;serviceInterface&#125;/providers/$&#123;url&#125;\n        // 比如\n        //   /dubbo/org.apache.dubbo.DemoService/providers/dubbo%3A%2F%2F127.0.0.1......\n        zkClient.create(toUrlPath(url), url.getParameter(Constants.DYNAMIC_KEY, true));\n    &#125; catch (Throwable e) &#123;\n        throw new RpcException(\"Failed to register...\");\n    &#125;\n&#125;\n\n\n\n\n如上，ZookeeperRegistry 在 doRegister 中调用了 Zookeeper 客户端创建服务节点。节点路径由 toUrlPath 方法生成，该方法逻辑不难理解，就不分析了。接下来分析 create 方法，如下：\npublic void create(String path, boolean ephemeral) &#123;\n    if (!ephemeral) &#123;\n        // 如果要创建的节点类型非临时节点，那么这里要检测节点是否存在\n        if (checkExists(path)) &#123;\n            return;\n        &#125;\n    &#125;\n    int i = path.lastIndexOf('/');\n    if (i > 0) &#123;\n        // 递归创建上一级路径\n        create(path.substring(0, i), false);\n    &#125;\n    \n    // 根据 ephemeral 的值创建临时或持久节点\n    if (ephemeral) &#123;\n        createEphemeral(path);\n    &#125; else &#123;\n        createPersistent(path);\n    &#125;\n&#125;\n\n\n\n\n上面方法先是通过递归创建当前节点的上一级路径，然后再根据 ephemeral 的值决定创建临时还是持久节点。createEphemeral 和 createPersistent 这两个方法都比较简单，这里简单分析其中的一个。如下：\npublic void createEphemeral(String path) &#123;\n    try &#123;\n        // 通过 Curator 框架创建节点\n        client.create().withMode(CreateMode.EPHEMERAL).forPath(path);\n    &#125; catch (NodeExistsException e) &#123;\n    &#125; catch (Exception e) &#123;\n        throw new IllegalStateException(e.getMessage(), e);\n    &#125;\n&#125;\n\n好了，到此关于服务注册的过程就分析完了。整个过程可简单总结为：先创建注册中心实例，之后再通过注册中心实例注册服务。本节先到这，接下来分析数据订阅过程。\n\n2.2.5 订阅 override 数据&#x2F;&#x2F; 待补充\n\n3.总结本篇文章详细分析了 Dubbo 服务导出过程，包括配置检测，URL 组装，Invoker 创建过程、导出服务以及注册服务等等。篇幅比较大，需要大家耐心阅读。本篇文章先就到这，如果文章有不妥错误之处，希望大家能够进行反馈或修正。\n","slug":"Dubbo源码分析","date":"2022-06-11T08:15:34.680Z","categories_index":"源码","tags_index":"java,源码,Dubbo","author_index":"小李不在_"},{"id":"bc567916c4dc0d8169bd26d18e348d36","title":"test","content":"hello1","slug":"1","date":"2022-06-10T06:31:32.558Z","categories_index":"1","tags_index":"1","author_index":"小李不在_"},{"id":"fceed54d2b78e915f81cbddb878dcc7f","title":"SpringSecurity","content":"\n\n\n0. 简介Spring Security 是 Spring 家族中的一个安全管理框架。相比与另外一个安全框架Shiro，它提供了更丰富的功能，社区资源也比Shiro丰富。\n\n一般来说中大型的项目都是使用SpringSecurity 来做安全框架。小项目有Shiro的比较多，因为相比与SpringSecurity，Shiro的上手更加的简单。\n\n 一般Web应用的需要进行认证和授权。\n\n    认证：验证当前访问系统的是不是本系统的用户，并且要确认具体是哪个用户\n\n    授权：经过认证后判断当前用户是否有权限进行某个操作\n\n而认证和授权也是SpringSecurity作为安全框架的核心功能。\n\n\n1. 快速入门\n1.1 准备工作我们先要搭建一个简单的SpringBoot工程\n\n① 设置父工程 添加依赖\n&lt;parent>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n    &lt;version>2.5.0&lt;/version>\n&lt;/parent>\n&lt;dependencies>\n    &lt;dependency>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n    &lt;/dependency>\n    &lt;dependency>\n        &lt;groupId>org.projectlombok&lt;/groupId>\n        &lt;artifactId>lombok&lt;/artifactId>\n        &lt;optional>true&lt;/optional>\n    &lt;/dependency>\n&lt;/dependencies>\n\n② 创建启动类\n@SpringBootApplication\npublic class SecurityApplication &#123;\n\n    public static void main(String[] args) &#123;\n        SpringApplication.run(SecurityApplication.class,args);\n    &#125;\n&#125;\n\n③ 创建Controller\n\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class HelloController &#123;\n\n    @RequestMapping(\"/hello\")\n    public String hello()&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n\n1.2 引入SpringSecurity在SpringBoot项目中使用SpringSecurity我们只需要引入依赖即可实现入门案例。\n\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-security&lt;/artifactId>\n&lt;/dependency>\n\n引入依赖后我们在尝试去访问之前的接口就会自动跳转到一个SpringSecurity的默认登陆页面，默认用户名是user,密码会输出在控制台。\n\n必须登陆之后才能对接口进行访问。\n\n\n2. 认证\n2.1 登陆校验流程\n\n2.2 原理初探想要知道如何实现自己的登陆流程就必须要先知道入门案例中SpringSecurity的流程。\n\n\n2.2.1 SpringSecurity完整流程SpringSecurity的原理其实就是一个过滤器链，内部包含了提供各种功能的过滤器。这里我们可以看看入门案例中的过滤器。\n\n\n图中只展示了核心过滤器，其它的非核心过滤器并没有在图中展示。\n\nUsernamePasswordAuthenticationFilter:负责处理我们在登陆页面填写了用户名密码后的登陆请求。入门案例的认证工作主要有它负责。\nExceptionTranslationFilter：处理过滤器链中抛出的任何AccessDeniedException和AuthenticationException 。\nFilterSecurityInterceptor：负责权限校验的过滤器。\n我们可以通过Debug查看当前系统中SpringSecurity过滤器链中有哪些过滤器及它们的顺序。\n\n\n\n2.2.2 认证流程详解\n概念速查:\nAuthentication接口: 它的实现类，表示当前访问系统的用户，封装了用户相关信息。\nAuthenticationManager接口：定义了认证Authentication的方法\nUserDetailsService接口：加载用户特定数据的核心接口。里面定义了一个根据用户名查询用户信息的方法。\nUserDetails接口：提供核心用户信息。通过UserDetailsService根据用户名获取处理的用户信息要封装成UserDetails对象返回。然后将这些信息封装到Authentication对象中。\n\n2.3 解决问题\n2.3.1 思路分析登录\n①自定义登录接口\n\n            调用ProviderManager的方法进行认证 如果认证通过生成jwt\n\n            把用户信息存入redis中\n\n②自定义UserDetailsService\n\n            在这个实现类中去查询数据库\n\n校验：\n①定义Jwt认证过滤器\n\n            获取token\n\n            解析token获取其中的userid\n\n            从redis中获取用户信息\n\n            存入SecurityContextHolder\n\n\n2.3.2 准备工作①添加依赖\n&lt;!--redis依赖-->\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-data-redis&lt;/artifactId>\n&lt;/dependency>\n&lt;!--fastjson依赖-->\n&lt;dependency>\n    &lt;groupId>com.alibaba&lt;/groupId>\n    &lt;artifactId>fastjson&lt;/artifactId>\n    &lt;version>1.2.33&lt;/version>\n&lt;/dependency>\n&lt;!--jwt依赖-->\n&lt;dependency>\n    &lt;groupId>io.jsonwebtoken&lt;/groupId>\n    &lt;artifactId>jjwt&lt;/artifactId>\n    &lt;version>0.9.0&lt;/version>\n&lt;/dependency>\n\n② 添加Redis相关配置\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.serializer.SerializerFeature;\nimport com.fasterxml.jackson.databind.JavaType;\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport com.fasterxml.jackson.databind.type.TypeFactory;\nimport org.springframework.data.redis.serializer.RedisSerializer;\nimport org.springframework.data.redis.serializer.SerializationException;\nimport com.alibaba.fastjson.parser.ParserConfig;\nimport org.springframework.util.Assert;\nimport java.nio.charset.Charset;\n\n/**\n * Redis使用FastJson序列化\n * \n * @author sg\n */\npublic class FastJsonRedisSerializer&lt;T> implements RedisSerializer&lt;T>\n&#123;\n\n    public static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n\n    private Class&lt;T> clazz;\n\n    static\n    &#123;\n        ParserConfig.getGlobalInstance().setAutoTypeSupport(true);\n    &#125;\n\n    public FastJsonRedisSerializer(Class&lt;T> clazz)\n    &#123;\n        super();\n        this.clazz = clazz;\n    &#125;\n\n    @Override\n    public byte[] serialize(T t) throws SerializationException\n    &#123;\n        if (t == null)\n        &#123;\n            return new byte[0];\n        &#125;\n        return JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);\n    &#125;\n\n    @Override\n    public T deserialize(byte[] bytes) throws SerializationException\n    &#123;\n        if (bytes == null || bytes.length &lt;= 0)\n        &#123;\n            return null;\n        &#125;\n        String str = new String(bytes, DEFAULT_CHARSET);\n\n        return JSON.parseObject(str, clazz);\n    &#125;\n\n\n    protected JavaType getJavaType(Class&lt;?> clazz)\n    &#123;\n        return TypeFactory.defaultInstance().constructType(clazz);\n    &#125;\n&#125;\n\n\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.data.redis.connection.RedisConnectionFactory;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.data.redis.serializer.StringRedisSerializer;\n\n@Configuration\npublic class RedisConfig &#123;\n\n    @Bean\n    @SuppressWarnings(value = &#123; \"unchecked\", \"rawtypes\" &#125;)\n    public RedisTemplate&lt;Object, Object> redisTemplate(RedisConnectionFactory connectionFactory)\n    &#123;\n        RedisTemplate&lt;Object, Object> template = new RedisTemplate&lt;>();\n        template.setConnectionFactory(connectionFactory);\n\n        FastJsonRedisSerializer serializer = new FastJsonRedisSerializer(Object.class);\n\n        // 使用StringRedisSerializer来序列化和反序列化redis的key值\n        template.setKeySerializer(new StringRedisSerializer());\n        template.setValueSerializer(serializer);\n\n        // Hash的key也采用StringRedisSerializer的序列化方式\n        template.setHashKeySerializer(new StringRedisSerializer());\n        template.setHashValueSerializer(serializer);\n\n        template.afterPropertiesSet();\n        return template;\n    &#125;\n&#125;\n\n③ 响应类\n\nimport com.fasterxml.jackson.annotation.JsonInclude;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class ResponseResult&lt;T> &#123;\n    /**\n     * 状态码\n     */\n    private Integer code;\n    /**\n     * 提示信息，如果有错误时，前端可以获取该字段进行提示\n     */\n    private String msg;\n    /**\n     * 查询到的结果数据，\n     */\n    private T data;\n\n    public ResponseResult(Integer code, String msg) &#123;\n        this.code = code;\n        this.msg = msg;\n    &#125;\n\n    public ResponseResult(Integer code, T data) &#123;\n        this.code = code;\n        this.data = data;\n    &#125;\n\n    public Integer getCode() &#123;\n        return code;\n    &#125;\n\n    public void setCode(Integer code) &#123;\n        this.code = code;\n    &#125;\n\n    public String getMsg() &#123;\n        return msg;\n    &#125;\n\n    public void setMsg(String msg) &#123;\n        this.msg = msg;\n    &#125;\n\n    public T getData() &#123;\n        return data;\n    &#125;\n\n    public void setData(T data) &#123;\n        this.data = data;\n    &#125;\n\n    public ResponseResult(Integer code, String msg, T data) &#123;\n        this.code = code;\n        this.msg = msg;\n        this.data = data;\n    &#125;\n&#125;\n\n④工具类\n\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\n\nimport javax.crypto.SecretKey;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.util.Base64;\nimport java.util.Date;\nimport java.util.UUID;\n\n/**\n * JWT工具类\n */\npublic class JwtUtil &#123;\n\n    //有效期为\n    public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000  一个小时\n    //设置秘钥明文\n    public static final String JWT_KEY = \"sangeng\";\n\n    public static String getUUID()&#123;\n        String token = UUID.randomUUID().toString().replaceAll(\"-\", \"\");\n        return token;\n    &#125;\n    \n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @return\n     */\n    public static String createJWT(String subject) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, null, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    /**\n     * 生成jtw\n     * @param subject token中要存放的数据（json格式）\n     * @param ttlMillis token超时时间\n     * @return\n     */\n    public static String createJWT(String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, getUUID());// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    private static JwtBuilder getJwtBuilder(String subject, Long ttlMillis, String uuid) &#123;\n        SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256;\n        SecretKey secretKey = generalKey();\n        long nowMillis = System.currentTimeMillis();\n        Date now = new Date(nowMillis);\n        if(ttlMillis==null)&#123;\n            ttlMillis=JwtUtil.JWT_TTL;\n        &#125;\n        long expMillis = nowMillis + ttlMillis;\n        Date expDate = new Date(expMillis);\n        return Jwts.builder()\n                .setId(uuid)              //唯一的ID\n                .setSubject(subject)   // 主题  可以是JSON数据\n                .setIssuer(\"sg\")     // 签发者\n                .setIssuedAt(now)      // 签发时间\n                .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥\n                .setExpiration(expDate);\n    &#125;\n\n    /**\n     * 创建token\n     * @param id\n     * @param subject\n     * @param ttlMillis\n     * @return\n     */\n    public static String createJWT(String id, String subject, Long ttlMillis) &#123;\n        JwtBuilder builder = getJwtBuilder(subject, ttlMillis, id);// 设置过期时间\n        return builder.compact();\n    &#125;\n\n    public static void main(String[] args) throws Exception &#123;\n        String token = \"eyJhbGciOiJIUzI1NiJ9.eyJqdGkiOiJjYWM2ZDVhZi1mNjVlLTQ0MDAtYjcxMi0zYWEwOGIyOTIwYjQiLCJzdWIiOiJzZyIsImlzcyI6InNnIiwiaWF0IjoxNjM4MTA2NzEyLCJleHAiOjE2MzgxMTAzMTJ9.JVsSbkP94wuczb4QryQbAke3ysBDIL5ou8fWsbt_ebg\";\n        Claims claims = parseJWT(token);\n        System.out.println(claims);\n    &#125;\n\n    /**\n     * 生成加密后的秘钥 secretKey\n     * @return\n     */\n    public static SecretKey generalKey() &#123;\n        byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY);\n        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\");\n        return key;\n    &#125;\n    \n    /**\n     * 解析\n     *\n     * @param jwt\n     * @return\n     * @throws Exception\n     */\n    public static Claims parseJWT(String jwt) throws Exception &#123;\n        SecretKey secretKey = generalKey();\n        return Jwts.parser()\n                .setSigningKey(secretKey)\n                .parseClaimsJws(jwt)\n                .getBody();\n    &#125;\n\n\n&#125;\n\n\nimport java.util.*;\nimport java.util.concurrent.TimeUnit;\n\n@SuppressWarnings(value = &#123; \"unchecked\", \"rawtypes\" &#125;)\n@Component\npublic class RedisCache\n&#123;\n    @Autowired\n    public RedisTemplate redisTemplate;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     */\n    public &lt;T> void setCacheObject(final String key, final T value)\n    &#123;\n        redisTemplate.opsForValue().set(key, value);\n    &#125;\n\n    /**\n     * 缓存基本的对象，Integer、String、实体类等\n     *\n     * @param key 缓存的键值\n     * @param value 缓存的值\n     * @param timeout 时间\n     * @param timeUnit 时间颗粒度\n     */\n    public &lt;T> void setCacheObject(final String key, final T value, final Integer timeout, final TimeUnit timeUnit)\n    &#123;\n        redisTemplate.opsForValue().set(key, value, timeout, timeUnit);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout)\n    &#123;\n        return expire(key, timeout, TimeUnit.SECONDS);\n    &#125;\n\n    /**\n     * 设置有效时间\n     *\n     * @param key Redis键\n     * @param timeout 超时时间\n     * @param unit 时间单位\n     * @return true=设置成功；false=设置失败\n     */\n    public boolean expire(final String key, final long timeout, final TimeUnit unit)\n    &#123;\n        return redisTemplate.expire(key, timeout, unit);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象。\n     *\n     * @param key 缓存键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T> T getCacheObject(final String key)\n    &#123;\n        ValueOperations&lt;String, T> operation = redisTemplate.opsForValue();\n        return operation.get(key);\n    &#125;\n\n    /**\n     * 删除单个对象\n     *\n     * @param key\n     */\n    public boolean deleteObject(final String key)\n    &#123;\n        return redisTemplate.delete(key);\n    &#125;\n\n    /**\n     * 删除集合对象\n     *\n     * @param collection 多个对象\n     * @return\n     */\n    public long deleteObject(final Collection collection)\n    &#123;\n        return redisTemplate.delete(collection);\n    &#125;\n\n    /**\n     * 缓存List数据\n     *\n     * @param key 缓存的键值\n     * @param dataList 待缓存的List数据\n     * @return 缓存的对象\n     */\n    public &lt;T> long setCacheList(final String key, final List&lt;T> dataList)\n    &#123;\n        Long count = redisTemplate.opsForList().rightPushAll(key, dataList);\n        return count == null ? 0 : count;\n    &#125;\n\n    /**\n     * 获得缓存的list对象\n     *\n     * @param key 缓存的键值\n     * @return 缓存键值对应的数据\n     */\n    public &lt;T> List&lt;T> getCacheList(final String key)\n    &#123;\n        return redisTemplate.opsForList().range(key, 0, -1);\n    &#125;\n\n    /**\n     * 缓存Set\n     *\n     * @param key 缓存键值\n     * @param dataSet 缓存的数据\n     * @return 缓存数据的对象\n     */\n    public &lt;T> BoundSetOperations&lt;String, T> setCacheSet(final String key, final Set&lt;T> dataSet)\n    &#123;\n        BoundSetOperations&lt;String, T> setOperation = redisTemplate.boundSetOps(key);\n        Iterator&lt;T> it = dataSet.iterator();\n        while (it.hasNext())\n        &#123;\n            setOperation.add(it.next());\n        &#125;\n        return setOperation;\n    &#125;\n\n    /**\n     * 获得缓存的set\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T> Set&lt;T> getCacheSet(final String key)\n    &#123;\n        return redisTemplate.opsForSet().members(key);\n    &#125;\n\n    /**\n     * 缓存Map\n     *\n     * @param key\n     * @param dataMap\n     */\n    public &lt;T> void setCacheMap(final String key, final Map&lt;String, T> dataMap)\n    &#123;\n        if (dataMap != null) &#123;\n            redisTemplate.opsForHash().putAll(key, dataMap);\n        &#125;\n    &#125;\n\n    /**\n     * 获得缓存的Map\n     *\n     * @param key\n     * @return\n     */\n    public &lt;T> Map&lt;String, T> getCacheMap(final String key)\n    &#123;\n        return redisTemplate.opsForHash().entries(key);\n    &#125;\n\n    /**\n     * 往Hash中存入数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @param value 值\n     */\n    public &lt;T> void setCacheMapValue(final String key, final String hKey, final T value)\n    &#123;\n        redisTemplate.opsForHash().put(key, hKey, value);\n    &#125;\n\n    /**\n     * 获取Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKey Hash键\n     * @return Hash中的对象\n     */\n    public &lt;T> T getCacheMapValue(final String key, final String hKey)\n    &#123;\n        HashOperations&lt;String, String, T> opsForHash = redisTemplate.opsForHash();\n        return opsForHash.get(key, hKey);\n    &#125;\n\n    /**\n     * 删除Hash中的数据\n     * \n     * @param key\n     * @param hkey\n     */\n    public void delCacheMapValue(final String key, final String hkey)\n    &#123;\n        HashOperations hashOperations = redisTemplate.opsForHash();\n        hashOperations.delete(key, hkey);\n    &#125;\n\n    /**\n     * 获取多个Hash中的数据\n     *\n     * @param key Redis键\n     * @param hKeys Hash键集合\n     * @return Hash对象集合\n     */\n    public &lt;T> List&lt;T> getMultiCacheMapValue(final String key, final Collection&lt;Object> hKeys)\n    &#123;\n        return redisTemplate.opsForHash().multiGet(key, hKeys);\n    &#125;\n\n    /**\n     * 获得缓存的基本对象列表\n     *\n     * @param pattern 字符串前缀\n     * @return 对象列表\n     */\n    public Collection&lt;String> keys(final String pattern)\n    &#123;\n        return redisTemplate.keys(pattern);\n    &#125;\n&#125;\n\n\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class WebUtils\n&#123;\n    /**\n     * 将字符串渲染到客户端\n     * \n     * @param response 渲染对象\n     * @param string 待渲染的字符串\n     * @return null\n     */\n    public static String renderString(HttpServletResponse response, String string) &#123;\n        try\n        &#123;\n            response.setStatus(200);\n            response.setContentType(\"application/json\");\n            response.setCharacterEncoding(\"utf-8\");\n            response.getWriter().print(string);\n        &#125;\n        catch (IOException e)\n        &#123;\n            e.printStackTrace();\n        &#125;\n        return null;\n    &#125;\n&#125;\n\n⑤实体类\nimport java.io.Serializable;\nimport java.util.Date;\n\n\n/**\n * 用户表(User)实体类\n *\n * @author 三更\n */\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class User implements Serializable &#123;\n    private static final long serialVersionUID = -40356785423868312L;\n    \n    /**\n    * 主键\n    */\n    private Long id;\n    /**\n    * 用户名\n    */\n    private String userName;\n    /**\n    * 昵称\n    */\n    private String nickName;\n    /**\n    * 密码\n    */\n    private String password;\n    /**\n    * 账号状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 邮箱\n    */\n    private String email;\n    /**\n    * 手机号\n    */\n    private String phonenumber;\n    /**\n    * 用户性别（0男，1女，2未知）\n    */\n    private String sex;\n    /**\n    * 头像\n    */\n    private String avatar;\n    /**\n    * 用户类型（0管理员，1普通用户）\n    */\n    private String userType;\n    /**\n    * 创建人的用户id\n    */\n    private Long createBy;\n    /**\n    * 创建时间\n    */\n    private Date createTime;\n    /**\n    * 更新人\n    */\n    private Long updateBy;\n    /**\n    * 更新时间\n    */\n    private Date updateTime;\n    /**\n    * 删除标志（0代表未删除，1代表已删除）\n    */\n    private Integer delFlag;\n&#125;\n\n\n2.3.3 实现\n2.3.3.1 数据库校验用户从之前的分析我们可以知道，我们可以自定义一个UserDetailsService,让SpringSecurity使用我们的UserDetailsService。我们自己的UserDetailsService可以从数据库中查询用户名和密码。\n\n\n准备工作我们先创建一个用户表， 建表语句如下：\n\nCREATE TABLE &#96;sys_user&#96; (\n  &#96;id&#96; BIGINT(20) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,\n  &#96;user_name&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;用户名&#39;,\n  &#96;nick_name&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;昵称&#39;,\n  &#96;password&#96; VARCHAR(64) NOT NULL DEFAULT &#39;NULL&#39; COMMENT &#39;密码&#39;,\n  &#96;status&#96; CHAR(1) DEFAULT &#39;0&#39; COMMENT &#39;账号状态（0正常 1停用）&#39;,\n  &#96;email&#96; VARCHAR(64) DEFAULT NULL COMMENT &#39;邮箱&#39;,\n  &#96;phonenumber&#96; VARCHAR(32) DEFAULT NULL COMMENT &#39;手机号&#39;,\n  &#96;sex&#96; CHAR(1) DEFAULT NULL COMMENT &#39;用户性别（0男，1女，2未知）&#39;,\n  &#96;avatar&#96; VARCHAR(128) DEFAULT NULL COMMENT &#39;头像&#39;,\n  &#96;user_type&#96; CHAR(1) NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;用户类型（0管理员，1普通用户）&#39;,\n  &#96;create_by&#96; BIGINT(20) DEFAULT NULL COMMENT &#39;创建人的用户id&#39;,\n  &#96;create_time&#96; DATETIME DEFAULT NULL COMMENT &#39;创建时间&#39;,\n  &#96;update_by&#96; BIGINT(20) DEFAULT NULL COMMENT &#39;更新人&#39;,\n  &#96;update_time&#96; DATETIME DEFAULT NULL COMMENT &#39;更新时间&#39;,\n  &#96;del_flag&#96; INT(11) DEFAULT &#39;0&#39; COMMENT &#39;删除标志（0代表未删除，1代表已删除）&#39;,\n  PRIMARY KEY (&#96;id&#96;)\n) ENGINE&#x3D;INNODB AUTO_INCREMENT&#x3D;2 DEFAULT CHARSET&#x3D;utf8mb4 COMMENT&#x3D;&#39;用户表&#39;\n\n    引入MybatisPuls和mysql驱动的依赖\n\n&lt;dependency>\n    &lt;groupId>com.baomidou&lt;/groupId>\n    &lt;artifactId>mybatis-plus-boot-starter&lt;/artifactId>\n    &lt;version>3.4.3&lt;/version>\n&lt;/dependency>\n&lt;dependency>\n    &lt;groupId>mysql&lt;/groupId>\n    &lt;artifactId>mysql-connector-java&lt;/artifactId>\n&lt;/dependency>\n\n    配置数据库信息\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n\n    定义Mapper接口\n\npublic interface UserMapper extends BaseMapper&lt;User> &#123;\n&#125;\n\n    修改User实体类\n\n类名上加@TableName(value = \"sys_user\") ,id字段上加 @TableId\n\n    配置Mapper扫描\n\n@SpringBootApplication\n@MapperScan(\"com.sangeng.mapper\")\npublic class SimpleSecurityApplication &#123;\n    public static void main(String[] args) &#123;\n        ConfigurableApplicationContext run = SpringApplication.run(SimpleSecurityApplication.class);\n        System.out.println(run);\n    &#125;\n&#125;\n\n    添加junit依赖\n\n&lt;dependency>\n    &lt;groupId>org.springframework.boot&lt;/groupId>\n    &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n&lt;/dependency>\n\n   测试MP是否能正常使用\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@SpringBootTest\npublic class MapperTest &#123;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Test\n    public void testUserMapper()&#123;\n        List&lt;User> users = userMapper.selectList(null);\n        System.out.println(users);\n    &#125;\n&#125;\n\n\n核心代码实现创建一个类实现UserDetailsService接口，重写其中的方法。更加用户名从数据库中查询用户信息\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        //根据用户名查询用户信息\n        LambdaQueryWrapper&lt;User> wrapper = new LambdaQueryWrapper&lt;>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        //如果查询不到数据就通过抛出异常来给出提示\n        if(Objects.isNull(user))&#123;\n            throw new RuntimeException(\"用户名或密码错误\");\n        &#125;\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        \n        //封装成UserDetails对象返回 \n        return new LoginUser(user);\n    &#125;\n&#125;\n\n因为UserDetailsService方法的返回值是UserDetails类型，所以需要定义一个类，实现该接口，把用户信息封装在其中。\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Data\n@NoArgsConstructor\n@AllArgsConstructor\npublic class LoginUser implements UserDetails &#123;\n\n    private User user;\n\n\n    @Override\n    public Collection&lt;? extends GrantedAuthority> getAuthorities() &#123;\n        return null;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUserName();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n\n注意：如果要测试，需要往用户表中写入用户数据，并且如果你想让用户的密码是明文存储，需要在密码前加{noop}。例如\n\n这样登陆的时候就可以用sg作为用户名，1234作为密码来登陆了。\n\n2.3.3.2 密码加密存储实际项目中我们不会把密码明文存储在数据库中。\n\n默认使用的PasswordEncoder要求数据库中的密码格式为：&#123;id&#125;password 。它会根据id去判断密码的加密方式。但是我们一般不会采用这种方式。所以就需要替换PasswordEncoder。\n\n我们一般使用SpringSecurity为我们提供的BCryptPasswordEncoder。\n\n我们只需要使用把BCryptPasswordEncoder对象注入Spring容器中，SpringSecurity就会使用该PasswordEncoder来进行密码校验。\n\n我们可以定义一个SpringSecurity的配置类，SpringSecurity要求这个配置类要继承WebSecurityConfigurerAdapter。\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n&#125;\n\n\n2.3.3.3 登陆接口接下我们需要自定义登陆接口，然后让SpringSecurity对这个接口放行,让用户访问这个接口的时候不用登录也能访问。\n\n在接口中我们通过AuthenticationManager的authenticate方法来进行用户认证,所以需要在SecurityConfig中配置把AuthenticationManager注入容器。\n\n认证成功的话要生成一个jwt，放入响应中返回。并且为了让用户下回请求时能通过jwt识别出具体的是哪个用户，我们需要把用户信息存入redis，可以把用户id作为key。\n\n@RestController\npublic class LoginController &#123;\n\n    @Autowired\n    private LoginServcie loginServcie;\n\n    @PostMapping(\"/user/login\")\n    public ResponseResult login(@RequestBody User user)&#123;\n        return loginServcie.login(user);\n    &#125;\n&#125;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n\n\n\n@Service\npublic class LoginServiceImpl implements LoginServcie &#123;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) &#123;\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate))&#123;\n            throw new RuntimeException(\"用户名或密码错误\");\n        &#125;\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap&lt;String,String> map = new HashMap&lt;>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    &#125;\n&#125;\n\n\n2.3.3.4 认证过滤器我们需要自定义一个过滤器，这个过滤器会去获取请求头中的token，对token进行解析取出其中的userid。\n\n使用userid去redis中获取对应的LoginUser对象。\n\n然后封装Authentication对象存入SecurityContextHolder\n\n@Component\npublic class JwtAuthenticationTokenFilter extends OncePerRequestFilter &#123;\n\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123;\n        //获取token\n        String token = request.getHeader(\"token\");\n        if (!StringUtils.hasText(token)) &#123;\n            //放行\n            filterChain.doFilter(request, response);\n            return;\n        &#125;\n        //解析token\n        String userid;\n        try &#123;\n            Claims claims = JwtUtil.parseJWT(token);\n            userid = claims.getSubject();\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n            throw new RuntimeException(\"token非法\");\n        &#125;\n        //从redis中获取用户信息\n        String redisKey = \"login:\" + userid;\n        LoginUser loginUser = redisCache.getCacheObject(redisKey);\n        if(Objects.isNull(loginUser))&#123;\n            throw new RuntimeException(\"用户未登录\");\n        &#125;\n        //存入SecurityContextHolder\n        //TODO 获取权限信息封装到Authentication中\n        UsernamePasswordAuthenticationToken authenticationToken =\n                new UsernamePasswordAuthenticationToken(loginUser,null,null);\n        SecurityContextHolder.getContext().setAuthentication(authenticationToken);\n        //放行\n        filterChain.doFilter(request, response);\n    &#125;\n&#125;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n\n    @Bean\n    public PasswordEncoder passwordEncoder()&#123;\n        return new BCryptPasswordEncoder();\n    &#125;\n\n\n    @Autowired\n    JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http\n                //关闭csrf\n                .csrf().disable()\n                //不通过Session获取SecurityContext\n                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n                .and()\n                .authorizeRequests()\n                // 对于登录接口 允许匿名访问\n                .antMatchers(\"/user/login\").anonymous()\n                // 除上面外的所有请求全部需要鉴权认证\n                .anyRequest().authenticated();\n\n        //把token校验过滤器添加到过滤器链中\n        http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n    &#125;\n\n    @Bean\n    @Override\n    public AuthenticationManager authenticationManagerBean() throws Exception &#123;\n        return super.authenticationManagerBean();\n    &#125;\n&#125;\n\n\n2.3.3.5 退出登陆我们只需要定义一个登陆接口，然后获取SecurityContextHolder中的认证信息，删除redis中对应的数据即可。\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class LoginServiceImpl implements LoginServcie &#123;\n\n    @Autowired\n    private AuthenticationManager authenticationManager;\n    @Autowired\n    private RedisCache redisCache;\n\n    @Override\n    public ResponseResult login(User user) &#123;\n        UsernamePasswordAuthenticationToken authenticationToken = new UsernamePasswordAuthenticationToken(user.getUserName(),user.getPassword());\n        Authentication authenticate = authenticationManager.authenticate(authenticationToken);\n        if(Objects.isNull(authenticate))&#123;\n            throw new RuntimeException(\"用户名或密码错误\");\n        &#125;\n        //使用userid生成token\n        LoginUser loginUser = (LoginUser) authenticate.getPrincipal();\n        String userId = loginUser.getUser().getId().toString();\n        String jwt = JwtUtil.createJWT(userId);\n        //authenticate存入redis\n        redisCache.setCacheObject(\"login:\"+userId,loginUser);\n        //把token响应给前端\n        HashMap&lt;String,String> map = new HashMap&lt;>();\n        map.put(\"token\",jwt);\n        return new ResponseResult(200,\"登陆成功\",map);\n    &#125;\n\n    @Override\n    public ResponseResult logout() &#123;\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        Long userid = loginUser.getUser().getId();\n        redisCache.deleteObject(\"login:\"+userid);\n        return new ResponseResult(200,\"退出成功\");\n    &#125;\n&#125;\n\n\n3. 授权\n3.0 权限系统的作用例如一个学校图书馆的管理系统，如果是普通学生登录就能看到借书还书相关的功能，不可能让他看到并且去使用添加书籍信息，删除书籍信息等功能。但是如果是一个图书馆管理员的账号登录了，应该就能看到并使用添加书籍信息，删除书籍信息等功能。\n\n总结起来就是**不同的用户可以使用不同的功能**。这就是权限系统要去实现的效果。\n\n我们不能只依赖前端去判断用户的权限来选择显示哪些菜单哪些按钮。因为如果只是这样，如果有人知道了对应功能的接口地址就可以不通过前端，直接去发送请求来实现相关功能操作。\n\n所以我们还需要在后台进行用户权限的判断，判断当前用户是否有相应的权限，必须具有所需权限才能进行相应的操作。\n\n\n3.1 授权基本流程在SpringSecurity中，会使用默认的FilterSecurityInterceptor来进行权限校验。在FilterSecurityInterceptor中会从SecurityContextHolder获取其中的Authentication，然后获取其中的权限信息。当前用户是否拥有访问当前资源所需的权限。\n\n所以我们在项目中只需要把当前登录用户的权限信息也存入Authentication。\n\n然后设置我们的资源所需要的权限即可。\n\n\n3.2 授权实现\n3.2.1 限制访问资源所需权限SpringSecurity为我们提供了基于注解的权限控制方案，这也是我们项目中主要采用的方式。我们可以使用注解去指定访问对应的资源所需的权限。\n\n但是要使用它我们需要先开启相关配置。\n\n@EnableGlobalMethodSecurity(prePostEnabled = true)\n\n然后就可以使用对应的注解。[@PreAuthorize ](/PreAuthorize ) \n\n@RestController\npublic class HelloController &#123;\n\n    @RequestMapping(\"/hello\")\n    @PreAuthorize(\"hasAuthority('test')\")\n    public String hello()&#123;\n        return \"hello\";\n    &#125;\n&#125;\n\n\n3.2.2 封装权限信息我们前面在写UserDetailsServiceImpl的时候说过，在查询出用户后还要获取对应的权限信息，封装到UserDetails中返回。\n\n我们先直接把权限信息写死封装到UserDetails中进行测试。\n\n我们之前定义了UserDetails的实现类LoginUser，想要让其能封装权限信息就要对其进行修改。\n\npackage com.sangeng.domain;\n\nimport com.alibaba.fastjson.annotation.JSONField;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Data\n@NoArgsConstructor\npublic class LoginUser implements UserDetails &#123;\n\n    private User user;\n        \n    //存储权限信息\n    private List&lt;String> permissions;\n    \n    \n    public LoginUser(User user,List&lt;String> permissions) &#123;\n        this.user = user;\n        this.permissions = permissions;\n    &#125;\n\n\n    //存储SpringSecurity所需要的权限信息的集合\n    @JSONField(serialize = false)\n    private List&lt;GrantedAuthority> authorities;\n\n    @Override\n    public  Collection&lt;? extends GrantedAuthority> getAuthorities() &#123;\n        if(authorities!=null)&#123;\n            return authorities;\n        &#125;\n        //把permissions中字符串类型的权限信息转换成GrantedAuthority对象存入authorities中\n        authorities = permissions.stream().\n                map(SimpleGrantedAuthority::new)\n                .collect(Collectors.toList());\n        return authorities;\n    &#125;\n\n    @Override\n    public String getPassword() &#123;\n        return user.getPassword();\n    &#125;\n\n    @Override\n    public String getUsername() &#123;\n        return user.getUserName();\n    &#125;\n\n    @Override\n    public boolean isAccountNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isAccountNonLocked() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isCredentialsNonExpired() &#123;\n        return true;\n    &#125;\n\n    @Override\n    public boolean isEnabled() &#123;\n        return true;\n    &#125;\n&#125;\n\n    LoginUser修改完后我们就可以在UserDetailsServiceImpl中去把权限信息封装到LoginUser中了。我们写死权限进行测试，后面我们再从数据库中查询权限信息。\n\npackage com.sangeng.service.impl;\n\nimport com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;\nimport com.baomidou.mybatisplus.core.conditions.query.QueryWrapper;\nimport com.baomidou.mybatisplus.extension.conditions.query.LambdaQueryChainWrapper;\nimport com.sangeng.domain.LoginUser;\nimport com.sangeng.domain.User;\nimport com.sangeng.mapper.UserMapper;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User> wrapper = new LambdaQueryWrapper&lt;>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user))&#123;\n            throw new RuntimeException(\"用户名或密码错误\");\n        &#125;\n        //TODO 根据用户查询权限信息 添加到LoginUser中\n        List&lt;String> list = new ArrayList&lt;>(Arrays.asList(\"test\"));\n        return new LoginUser(user,list);\n    &#125;\n&#125;\n\n\n3.2.3 从数据库查询权限信息\n3.2.3.1 RBAC权限模型RBAC权限模型（Role-Based Access Control）即：基于角色的权限控制。这是目前最常被开发者使用也是相对易用、通用权限模型。\n\n![image-20211222110249727.png](https://cdn.nlark.com/yuque/0/2022/png/26737039/1654678998174-ddf9e502-0eb7-46de-8f1e-b21c87914758.png#clientId=u30b1fcc0-d450-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=drop&amp;id=u8ac9a782&amp;name=image-20211222110249727.png&amp;originHeight=716&amp;originWidth=1187&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=59299&amp;status=done&amp;style=none&amp;taskId=ucc024657-450e-4d8f-936a-42ecaee0d1f&amp;title=)\n\n\n3.2.3.2 准备工作\nCREATE DATABASE /*!32312 IF NOT EXISTS*/`sg_security` /*!40100 DEFAULT CHARACTER SET utf8mb4 */;\n\nUSE `sg_security`;\n\n/*Table structure for table `sys_menu` */\n\nDROP TABLE IF EXISTS `sys_menu`;\n\nCREATE TABLE `sys_menu` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `menu_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '菜单名',\n  `path` varchar(200) DEFAULT NULL COMMENT '路由地址',\n  `component` varchar(255) DEFAULT NULL COMMENT '组件路径',\n  `visible` char(1) DEFAULT '0' COMMENT '菜单状态（0显示 1隐藏）',\n  `status` char(1) DEFAULT '0' COMMENT '菜单状态（0正常 1停用）',\n  `perms` varchar(100) DEFAULT NULL COMMENT '权限标识',\n  `icon` varchar(100) DEFAULT '#' COMMENT '菜单图标',\n  `create_by` bigint(20) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(20) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `del_flag` int(11) DEFAULT '0' COMMENT '是否删除（0未删除 1已删除）',\n  `remark` varchar(500) DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4 COMMENT='菜单表';\n\n/*Table structure for table `sys_role` */\n\nDROP TABLE IF EXISTS `sys_role`;\n\nCREATE TABLE `sys_role` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\n  `name` varchar(128) DEFAULT NULL,\n  `role_key` varchar(100) DEFAULT NULL COMMENT '角色权限字符串',\n  `status` char(1) DEFAULT '0' COMMENT '角色状态（0正常 1停用）',\n  `del_flag` int(1) DEFAULT '0' COMMENT 'del_flag',\n  `create_by` bigint(200) DEFAULT NULL,\n  `create_time` datetime DEFAULT NULL,\n  `update_by` bigint(200) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  `remark` varchar(500) DEFAULT NULL COMMENT '备注',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='角色表';\n\n/*Table structure for table `sys_role_menu` */\n\nDROP TABLE IF EXISTS `sys_role_menu`;\n\nCREATE TABLE `sys_role_menu` (\n  `role_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '角色ID',\n  `menu_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '菜单id',\n  PRIMARY KEY (`role_id`,`menu_id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n/*Table structure for table `sys_user` */\n\nDROP TABLE IF EXISTS `sys_user`;\n\nCREATE TABLE `sys_user` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键',\n  `user_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '用户名',\n  `nick_name` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '昵称',\n  `password` varchar(64) NOT NULL DEFAULT 'NULL' COMMENT '密码',\n  `status` char(1) DEFAULT '0' COMMENT '账号状态（0正常 1停用）',\n  `email` varchar(64) DEFAULT NULL COMMENT '邮箱',\n  `phonenumber` varchar(32) DEFAULT NULL COMMENT '手机号',\n  `sex` char(1) DEFAULT NULL COMMENT '用户性别（0男，1女，2未知）',\n  `avatar` varchar(128) DEFAULT NULL COMMENT '头像',\n  `user_type` char(1) NOT NULL DEFAULT '1' COMMENT '用户类型（0管理员，1普通用户）',\n  `create_by` bigint(20) DEFAULT NULL COMMENT '创建人的用户id',\n  `create_time` datetime DEFAULT NULL COMMENT '创建时间',\n  `update_by` bigint(20) DEFAULT NULL COMMENT '更新人',\n  `update_time` datetime DEFAULT NULL COMMENT '更新时间',\n  `del_flag` int(11) DEFAULT '0' COMMENT '删除标志（0代表未删除，1代表已删除）',\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4 COMMENT='用户表';\n\n/*Table structure for table `sys_user_role` */\n\nDROP TABLE IF EXISTS `sys_user_role`;\n\nCREATE TABLE `sys_user_role` (\n  `user_id` bigint(200) NOT NULL AUTO_INCREMENT COMMENT '用户id',\n  `role_id` bigint(200) NOT NULL DEFAULT '0' COMMENT '角色id',\n  PRIMARY KEY (`user_id`,`role_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;\n\nSELECT \n\tDISTINCT m.&#96;perms&#96;\nFROM\n\tsys_user_role ur\n\tLEFT JOIN &#96;sys_role&#96; r ON ur.&#96;role_id&#96; &#x3D; r.&#96;id&#96;\n\tLEFT JOIN &#96;sys_role_menu&#96; rm ON ur.&#96;role_id&#96; &#x3D; rm.&#96;role_id&#96;\n\tLEFT JOIN &#96;sys_menu&#96; m ON m.&#96;id&#96; &#x3D; rm.&#96;menu_id&#96;\nWHERE\n\tuser_id &#x3D; 2\n\tAND r.&#96;status&#96; &#x3D; 0\n\tAND m.&#96;status&#96; &#x3D; 0\n\npackage com.sangeng.domain;\n\nimport com.baomidou.mybatisplus.annotation.TableId;\nimport com.baomidou.mybatisplus.annotation.TableName;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport java.io.Serializable;\nimport java.util.Date;\n\n/**\n * 菜单表(Menu)实体类\n *\n * @author makejava\n * @since 2021-11-24 15:30:08\n */\n@TableName(value=\"sys_menu\")\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@JsonInclude(JsonInclude.Include.NON_NULL)\npublic class Menu implements Serializable &#123;\n    private static final long serialVersionUID = -54979041104113736L;\n    \n        @TableId\n    private Long id;\n    /**\n    * 菜单名\n    */\n    private String menuName;\n    /**\n    * 路由地址\n    */\n    private String path;\n    /**\n    * 组件路径\n    */\n    private String component;\n    /**\n    * 菜单状态（0显示 1隐藏）\n    */\n    private String visible;\n    /**\n    * 菜单状态（0正常 1停用）\n    */\n    private String status;\n    /**\n    * 权限标识\n    */\n    private String perms;\n    /**\n    * 菜单图标\n    */\n    private String icon;\n    \n    private Long createBy;\n    \n    private Date createTime;\n    \n    private Long updateBy;\n    \n    private Date updateTime;\n    /**\n    * 是否删除（0未删除 1已删除）\n    */\n    private Integer delFlag;\n    /**\n    * 备注\n    */\n    private String remark;\n&#125;\n\n\n3.2.3.3 代码实现我们只需要根据用户id去查询到其所对应的权限信息即可。\n\n所以我们可以先定义个mapper，其中提供一个方法可以根据userid查询权限信息。\n\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.sangeng.domain.Menu;\n\nimport java.util.List;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\npublic interface MenuMapper extends BaseMapper&lt;Menu> &#123;\n    List&lt;String> selectPermsByUserId(Long id);\n&#125;\n\n尤其是自定义方法，所以需要创建对应的mapper文件，定义对应的sql语句\n\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?>\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" >\n&lt;mapper namespace=\"com.sangeng.mapper.MenuMapper\">\n\n\n    &lt;select id=\"selectPermsByUserId\" resultType=\"java.lang.String\">\n        SELECT\n            DISTINCT m.`perms`\n        FROM\n            sys_user_role ur\n            LEFT JOIN `sys_role` r ON ur.`role_id` = r.`id`\n            LEFT JOIN `sys_role_menu` rm ON ur.`role_id` = rm.`role_id`\n            LEFT JOIN `sys_menu` m ON m.`id` = rm.`menu_id`\n        WHERE\n            user_id = #&#123;userid&#125;\n            AND r.`status` = 0\n            AND m.`status` = 0\n    &lt;/select>\n&lt;/mapper>\n\n在application.yml中配置mapperXML文件的位置\n\nspring:\n  datasource:\n    url: jdbc:mysql://localhost:3306/sg_security?characterEncoding=utf-8&amp;serverTimezone=UTC\n    username: root\n    password: root\n    driver-class-name: com.mysql.cj.jdbc.Driver\n  redis:\n    host: localhost\n    port: 6379\nmybatis-plus:\n  mapper-locations: classpath*:/mapper/**/*.xml\n\n然后我们可以在UserDetailsServiceImpl中去调用该mapper的方法查询权限信息封装到LoginUser对象中即可。\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService &#123;\n\n    @Autowired\n    private UserMapper userMapper;\n\n    @Autowired\n    private MenuMapper menuMapper;\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123;\n        LambdaQueryWrapper&lt;User> wrapper = new LambdaQueryWrapper&lt;>();\n        wrapper.eq(User::getUserName,username);\n        User user = userMapper.selectOne(wrapper);\n        if(Objects.isNull(user))&#123;\n            throw new RuntimeException(\"用户名或密码错误\");\n        &#125;\n        List&lt;String> permissionKeyList =  menuMapper.selectPermsByUserId(user.getId());\n//        //测试写法\n//        List&lt;String> list = new ArrayList&lt;>(Arrays.asList(\"test\"));\n        return new LoginUser(user,permissionKeyList);\n    &#125;\n&#125;\n\n\n4. 自定义失败处理我们还希望在认证失败或者是授权失败的情况下也能和我们的接口一样返回相同结构的json，这样可以让前端能对响应进行统一的处理。要实现这个功能我们需要知道SpringSecurity的异常处理机制。\n\n在SpringSecurity中，如果我们在认证或者授权的过程中出现了异常会被ExceptionTranslationFilter捕获到。在ExceptionTranslationFilter中会去判断是认证失败还是授权失败出现的异常。\n\n如果是认证过程中出现的异常会被封装成AuthenticationException然后调用**AuthenticationEntryPoint**对象的方法去进行异常处理。\n\n如果是授权过程中出现的异常会被封装成AccessDeniedException然后调用**AccessDeniedHandler**对象的方法去进行异常处理。\n\n所以如果我们需要自定义异常处理，我们只需要自定义AuthenticationEntryPoint和AccessDeniedHandler然后配置给SpringSecurity即可。\n\n①自定义实现类\n@Component\npublic class AccessDeniedHandlerImpl implements AccessDeniedHandler &#123;\n    @Override\n    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.FORBIDDEN.value(), \"权限不足\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n\n    &#125;\n&#125;\n\n/**\n * @Author 三更  B站： https://space.bilibili.com/663528522\n */\n@Component\npublic class AuthenticationEntryPointImpl implements AuthenticationEntryPoint &#123;\n    @Override\n    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException &#123;\n        ResponseResult result = new ResponseResult(HttpStatus.UNAUTHORIZED.value(), \"认证失败请重新登录\");\n        String json = JSON.toJSONString(result);\n        WebUtils.renderString(response,json);\n    &#125;\n&#125;\n\n②配置给SpringSecurity\n先注入对应的处理器\n\n@Autowired\nprivate AuthenticationEntryPoint authenticationEntryPoint;\n\n@Autowired\nprivate AccessDeniedHandler accessDeniedHandler;\n\n然后我们可以使用HttpSecurity对象的方法去配置。\n\nhttp.exceptionHandling().authenticationEntryPoint(authenticationEntryPoint).\n        accessDeniedHandler(accessDeniedHandler);\n\n\n5. 跨域浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。\n\n前后端分离项目，前端项目和后端项目一般都不是同源的，所以肯定会存在跨域请求的问题。\n\n所以我们就要处理一下，让前端能进行跨域请求。\n\n①先对SpringBoot配置，运行跨域请求\n@Configuration\npublic class CorsConfig implements WebMvcConfigurer &#123;\n\n    @Override\n    public void addCorsMappings(CorsRegistry registry) &#123;\n      // 设置允许跨域的路径\n        registry.addMapping(\"/**\")\n                // 设置允许跨域请求的域名\n                .allowedOriginPatterns(\"*\")\n                // 是否允许cookie\n                .allowCredentials(true)\n                // 设置允许的请求方式\n                .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\")\n                // 设置允许的header属性\n                .allowedHeaders(\"*\")\n                // 跨域允许时间\n                .maxAge(3600);\n    &#125;\n&#125;\n\n②开启SpringSecurity的跨域访问\n由于我们的资源都会收到SpringSecurity的保护，所以想要跨域访问还要让SpringSecurity运行跨域访问。\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            //关闭csrf\n            .csrf().disable()\n            //不通过Session获取SecurityContext\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .authorizeRequests()\n            // 对于登录接口 允许匿名访问\n            .antMatchers(\"/user/login\").anonymous()\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated();\n\n    //添加过滤器\n    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n    //配置异常处理器\n    http.exceptionHandling()\n            //配置认证失败处理器\n            .authenticationEntryPoint(authenticationEntryPoint)\n            .accessDeniedHandler(accessDeniedHandler);\n\n    //允许跨域\n    http.cors();\n&#125;\n\n\n6. 遗留小问题\n其它权限校验方法我们前面都是使用@PreAuthorize注解，然后在在其中使用的是hasAuthority方法进行校验。SpringSecurity还为我们提供了其它方法例如：hasAnyAuthority，hasRole，hasAnyRole等。\n\n\n\n这里我们先不急着去介绍这些方法，我们先去理解hasAuthority的原理，然后再去学习其他方法你就更容易理解，而不是死记硬背区别。并且我们也可以选择定义校验方法，实现我们自己的校验逻辑。\n\nhasAuthority方法实际是执行到了SecurityExpressionRoot的hasAuthority，大家只要断点调试既可知道它内部的校验原理。\n\n它内部其实是调用authentication的getAuthorities方法获取用户的权限列表。然后判断我们存入的方法参数数据在权限列表中。\n\nhasAnyAuthority方法可以传入多个权限，只有用户有其中任意一个权限都可以访问对应资源。\n\n@PreAuthorize(\"hasAnyAuthority('admin','test','system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n\nhasRole要求有对应的角色才可以访问，但是它内部会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n@PreAuthorize(\"hasRole('system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n\nhasAnyRole 有任意的角色就可以访问。它内部也会把我们传入的参数拼接上 **ROLE_** 后再去比较。所以这种情况下要用用户对应的权限也要有 **ROLE_** 这个前缀才可以。\n\n@PreAuthorize(\"hasAnyRole('admin','system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n\n\n自定义权限校验方法我们也可以定义自己的权限校验方法，在@PreAuthorize注解中使用我们的方法。\n\n@Component(\"ex\")\npublic class SGExpressionRoot &#123;\n\n    public boolean hasAuthority(String authority)&#123;\n        //获取当前用户的权限\n        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();\n        LoginUser loginUser = (LoginUser) authentication.getPrincipal();\n        List&lt;String> permissions = loginUser.getPermissions();\n        //判断用户权限集合中是否存在authority\n        return permissions.contains(authority);\n    &#125;\n&#125;\n\n 在SPEL表达式中使用 @ex相当于获取容器中bean的名字未ex的对象。然后再调用这个对象的hasAuthority方法\n\n@RequestMapping(\"/hello\")\n@PreAuthorize(\"@ex.hasAuthority('system:dept:list')\")\npublic String hello()&#123;\n    return \"hello\";\n&#125;\n\n\n基于配置的权限控制我们也可以在配置类中使用使用配置的方式对资源进行权限控制。\n\n@Override\nprotected void configure(HttpSecurity http) throws Exception &#123;\n    http\n            //关闭csrf\n            .csrf().disable()\n            //不通过Session获取SecurityContext\n            .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)\n            .and()\n            .authorizeRequests()\n            // 对于登录接口 允许匿名访问\n            .antMatchers(\"/user/login\").anonymous()\n            .antMatchers(\"/testCors\").hasAuthority(\"system:dept:list222\")\n            // 除上面外的所有请求全部需要鉴权认证\n            .anyRequest().authenticated();\n\n    //添加过滤器\n    http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter.class);\n\n    //配置异常处理器\n    http.exceptionHandling()\n            //配置认证失败处理器\n            .authenticationEntryPoint(authenticationEntryPoint)\n            .accessDeniedHandler(accessDeniedHandler);\n\n    //允许跨域\n    http.cors();\n&#125;\n\n\nCSRFCSRF是指跨站请求伪造（Cross-site request forgery），是web常见的攻击之一。\n\n[https://blog.csdn.net/freeking101/article/details/86537087](https://blog.csdn.net/freeking101/article/details/86537087)\n\nSpringSecurity去防止CSRF攻击的方式就是通过csrf_token。后端会生成一个csrf_token，前端发起请求的时候需要携带这个csrf_token,后端会有过滤器进行校验，如果没有携带或者是伪造的就不允许访问。\n\n我们可以发现CSRF攻击依靠的是cookie中所携带的认证信息。但是在前后端分离的项目中我们的认证信息其实是token，而token并不是存储中cookie中，并且需要前端代码去把token设置到请求头中才可以，所以CSRF攻击也就不用担心了。\n\n\n认证成功处理器实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果登录成功了是会调用AuthenticationSuccessHandler的方法进行认证成功后的处理的。AuthenticationSuccessHandler就是登录成功处理器。\n\n我们也可以自己去自定义成功处理器进行成功后的相应处理。\n\n@Component\npublic class SGSuccessHandler implements AuthenticationSuccessHandler &#123;\n\n    @Override\n    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;\n        System.out.println(\"认证成功了\");\n    &#125;\n&#125;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.formLogin().successHandler(successHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    &#125;\n&#125;\n\n\n认证失败处理器实际上在UsernamePasswordAuthenticationFilter进行登录认证的时候，如果认证失败了是会调用AuthenticationFailureHandler的方法进行认证失败后的处理的。AuthenticationFailureHandler就是登录失败处理器。\n\n我们也可以自己去自定义失败处理器进行失败后的相应处理。\n\n@Component\npublic class SGFailureHandler implements AuthenticationFailureHandler &#123;\n    @Override\n    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException &#123;\n        System.out.println(\"认证失败了\");\n    &#125;\n&#125;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    &#125;\n&#125;\n\n\n登出成功处理器@Component\npublic class SGLogoutSuccessHandler implements LogoutSuccessHandler &#123;\n    @Override\n    public void onLogoutSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException &#123;\n        System.out.println(\"注销成功\");\n    &#125;\n&#125;\n\n@Configuration\npublic class SecurityConfig extends WebSecurityConfigurerAdapter &#123;\n\n    @Autowired\n    private AuthenticationSuccessHandler successHandler;\n\n    @Autowired\n    private AuthenticationFailureHandler failureHandler;\n\n    @Autowired\n    private LogoutSuccessHandler logoutSuccessHandler;\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception &#123;\n        http.formLogin()\n//                配置认证成功处理器\n                .successHandler(successHandler)\n//                配置认证失败处理器\n                .failureHandler(failureHandler);\n\n        http.logout()\n                //配置注销成功处理器\n                .logoutSuccessHandler(logoutSuccessHandler);\n\n        http.authorizeRequests().anyRequest().authenticated();\n    &#125;\n&#125;\n\n","slug":"SpringSecurity","date":"2022-06-09T08:30:49.418Z","categories_index":"SpringSecurity","tags_index":"SpringSecurity,Spring,java","author_index":"小李不在_"}]
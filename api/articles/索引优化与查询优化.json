{"title":"索引优化与查询优化","uid":"70425fba86b2c28266d9c33de675b2d8","slug":"索引优化与查询优化","date":"2022-06-11T12:12:38.267Z","updated":"2022-06-11T12:21:33.664Z","comments":true,"path":"api/articles/索引优化与查询优化.json","keywords":null,"cover":[],"content":"<h1 id=\"索引优化与查询优化\"><a href=\"#索引优化与查询优化\" class=\"headerlink\" title=\"索引优化与查询优化\"></a>索引优化与查询优化</h1><h2 id=\"哪些维度可以进行数据库调优？\"><a href=\"#哪些维度可以进行数据库调优？\" class=\"headerlink\" title=\"哪些维度可以进行数据库调优？\"></a>哪些维度可以进行数据库调优？</h2><p><a name=\"532dbb5d\"></a></p>\n<h4 id=\"1-索引失效、没有充分利用索引-—-建立索引\"><a href=\"#1-索引失效、没有充分利用索引-—-建立索引\" class=\"headerlink\" title=\"1.索引失效、没有充分利用索引 — 建立索引\"></a>1.索引失效、没有充分利用索引 — 建立索引</h4><p><a name=\"26fa4992\"></a></p>\n<h4 id=\"2-关联查询太多join（设计缺陷或不得已的需求）-–-sql优化\"><a href=\"#2-关联查询太多join（设计缺陷或不得已的需求）-–-sql优化\" class=\"headerlink\" title=\"2.关联查询太多join（设计缺陷或不得已的需求） – sql优化\"></a>2.关联查询太多join（设计缺陷或不得已的需求） – sql优化</h4><p><a name=\"64b3fadf\"></a></p>\n<h5 id=\"3-服务器调优及各个参数设置（缓冲，线程数等）-–-调整my-cnf\"><a href=\"#3-服务器调优及各个参数设置（缓冲，线程数等）-–-调整my-cnf\" class=\"headerlink\" title=\"3..服务器调优及各个参数设置（缓冲，线程数等） – 调整my.cnf\"></a>3..服务器调优及各个参数设置（缓冲，线程数等） – 调整my.cnf</h5><p><a name=\"26dfa81a\"></a></p>\n<h5 id=\"4-数据过多-–-分库分表\"><a href=\"#4-数据过多-–-分库分表\" class=\"headerlink\" title=\"4.数据过多 – 分库分表\"></a>4.数据过多 – 分库分表</h5><p><a name=\"98909a09\"></a></p>\n<h4 id=\"sql查询优化的大体方向-—\"><a href=\"#sql查询优化的大体方向-—\" class=\"headerlink\" title=\"sql查询优化的大体方向 —\"></a>sql查询优化的大体方向 —</h4><p><a name=\"dcf83efe\"></a></p>\n<p><strong>物理查询优化：通过索引和表连接等奇数来进行优化</strong></p>\n<p><a name=\"15f36a4a\"></a></p>\n<p><strong>逻辑查询优化：通过SQL等价变换提升查询效率，也就是换一种查询写法</strong></p>\n<p><a name=\"e833899b\"></a></p>\n<h2 id=\"关联查询优化：\"><a href=\"#关联查询优化：\" class=\"headerlink\" title=\"关联查询优化：\"></a>关联查询优化：</h2><p><a name=\"a68e1968\"></a></p>\n<h4 id=\"情况一：左外连接\"><a href=\"#情况一：左外连接\" class=\"headerlink\" title=\"情况一：左外连接\"></a>情况一：左外连接</h4><p><a name=\"c2dc447a\"></a></p>\n<h4 id=\"情况二：内连接\"><a href=\"#情况二：内连接\" class=\"headerlink\" title=\"情况二：内连接\"></a>情况二：内连接</h4><p>内连接中若只能有一个字段有索引，则被驱动表的字段有索引成本较低</p>\n<p>对于内连接中，在两个表的连接条件都存在索引的情况下，会选择数据少的表作为驱动表（小表驱动大表）</p>\n<p>均没有索引也符合\t小表驱动大表的规则</p>\n<p><a name=\"8c9d507e\"></a></p>\n<h4 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>小的结果集驱动大的结果集（过滤之后的表的行数*每行的大小，并不是表中的总数据）</p>\n<p>为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数）</p>\n<p>增大join buffer size的大小（一次缓存的数据越多，那么内层包的扫描的次数就越少）</p>\n<p>减少驱动表不必要的字段的查询（字段越少，join buffer 缓存的数据就越多）</p>\n<p>MySQL8.0新特性：废弃了之前的BNLJ 加入hash join且默认使用</p>\n<p><img src=\"/../assets/1647330671117-b8c2aaef-5d20-4fc4-81e5-c8e55417cd7c.png\" alt=\"1646391675179.png\"></p>\n<p><a name=\"28d9c180\"></a></p>\n<h2 id=\"排序优化：\"><a href=\"#排序优化：\" class=\"headerlink\" title=\"排序优化：\"></a>排序优化：</h2><p>问题：在where条件字段上添加索引，为什么还要在order by 字段上添加索引呢？</p>\n<p>在MySQL中支持两种排序方式，分别是filesort和index方式（filesort比较耗时间）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">index排序中，索引可以保证数据的有序性，不需要再次进行排序，效率更高\n\nfilesort排序一般在内存中进行，占用的CPU过多，如果待排序的结果较大，会产生临时文件io到磁盘进行排序，效率低<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"e0425ccf\"></a></p>\n<h4 id=\"优化建议：\"><a href=\"#优化建议：\" class=\"headerlink\" title=\"优化建议：\"></a>优化建议：</h4><p>1.SQL中，可以在where语句和order by 语句中使用到索引，目的是避免where的全表扫描和order by的File Sort排序，<strong>但是在某些极端的情况下，也有不使用索引可能比使用索引的效率要高</strong></p>\n<p>2.尽量使用index完成order by排序，如果where和order by后面是相同的列就使用单列索引，不同的列就使用联合索引</p>\n<p>3.无法使用index时，需要对FileSort方式进行调优</p>\n<hr>\n<p>order by顺序错误也会导致索引失效，也是最左前缀法则</p>\n<p>order by排序方向反了也会导致索引失效（如id升序，age降序）字段的排序方向要相同（都升序或降序）</p>\n<p>数据未进行过滤（where未过滤）导致数据过多可能导致索引失效</p>\n<p><a name=\"8c9d507e\"></a></p>\n<h4 id=\"总结：-1\"><a href=\"#总结：-1\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>1.当两个索引同时存在的时候，MySQL会自动选择最优的方案，但是随着数据量的变化，选择的索引也会随之变化</p>\n<p>2.当范围条件和group by或者order by 的字段出现二选一时，优先观察条件字段的过滤数量，如果过滤的数据足够多，而需要排序的数据并不多时，优先把索引放在范围字段上，反之，同理</p>\n<hr>\n<p><a name=\"c50796ea\"></a></p>\n<h4 id=\"FileSort算法：双路排序和单路排序\"><a href=\"#FileSort算法：双路排序和单路排序\" class=\"headerlink\" title=\"FileSort算法：双路排序和单路排序\"></a>FileSort算法：双路排序和单路排序</h4><p>排序的字段若不在索引列上，则filesort会有两种算法：双路排序和单路排序</p>\n<p>双路排序 （慢）<br /><br>MySQL 4.1之前是使用双路排序 ，字面意思就是两次扫描磁盘，最终得到数据， 读取行指针和<br /><br>order by列 ，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取<br /><br>对应的数据输出</p>\n<p>从磁盘取排序字段，在buffer进行排序，再从 磁盘取其他字段 。</p>\n<p>取一批数据，要对磁盘进行两次扫描，众所周知，IO是很耗时的，所以在mysql4.1之后，出现了第二种<br /><br>改进的算法，就是单路排序。</p>\n<p>单路排序 （快）<br /><br>从磁盘读取查询需要的 所有列 ，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输<br /><br>出， 它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO，但是它会使用更多的空<br /><br>间， 因为它把每一行都保存在内存中了。</p>\n<p><a name=\"e1daf7fd\"></a></p>\n<h2 id=\"普通索引和唯一索引优化：\"><a href=\"#普通索引和唯一索引优化：\" class=\"headerlink\" title=\"普通索引和唯一索引优化：\"></a>普通索引和唯一索引优化：</h2><p><strong>11.1 查询过程</strong><br /><br>假设，执行查询的语句是 select id from test where k&#x3D;5。<br /><br>对于普通索引来说，查找到满足条件的第一个记录(5,500)后，需要查找下一个记录，直到碰到第一<br /><br>个不满足k&#x3D;5条件的记录。<br /><br>对于唯一索引来说，由于索引定义了唯一性，查找到第一个满足条件的记录后，就会停止继续检<br /><br>索。<br /><br>那么，这个不同带来的性能差距会有多少呢？答案是， 微乎其微 。</p>\n<p><strong>11.2 更新过程</strong><br /><br>为了说明普通索引和唯一索引对更新语句性能的影响这个问题，介绍一下change buffer。<br /><br>当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，<br /><br>在不影响数据一致性的前提下， InooDB会将这些更新操作缓存在change buffer中 ，这样就不需要从磁<br /><br>盘中读入这个数据页了。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change<br /><br>buffer中与这个页有关的操作。通过这种方式就能保证这个数据逻辑的正确性。<br /><br>将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge 。除了 访问这个数据页 会触<br /><br>发merge外，系统有 后台线程会定期 merge。在 数据库正常关闭（shutdown） 的过程中，也会执行merge<br /><br>操作。<br /><br>如果能够将更新操作先记录在change buffer， 减少读磁盘 ，语句的执行速度会得到明显的提升。而且，<br /><br>数据读入内存是需要占用 buffer pool 的，所以这种方式还能够 避免占用内存 ，提高内存利用率。<br /><br>唯一索引的更新就不能使用change buffer ，实际上也只有普通索引可以使用。<br /><br>如果要在这张表中插入一个新记录(4,400)的话，InnoDB的处理流程是怎样的？</p>\n<p><strong>11.3 change buffer的使用场景</strong>：只能使用于普通索引</p>\n<ol>\n<li>普通索引和唯一索引应该怎么选择？其实，这两类索引在查询能力上是没差别的，主要考虑的是<br /><br>对 更新性能 的影响。所以，建议你 尽量选择普通索引 。</li>\n<li>在实际使用中会发现， 普通索引 和 change buffer 的配合使用，对于 数据量大 的表的更新优化<br /><br>还是很明显的。</li>\n<li>如果所有的更新后面，都马上 伴随着对这个记录的查询 ，那么你应该 关闭change buffer 。而在<br /><br>其他情况下，change buffer都能提升更新性能。</li>\n<li>由于唯一索引用不上change buffer的优化机制，因此如果 业务可以接受 ，从性能角度出发建议优<br /><br>先考虑非唯一索引。但是如果”业务可能无法确保”的情况下，怎么处理呢？<br /><br>首先， 业务正确性优先 。我们的前提是“业务代码已经保证不会写入重复数据”的情况下，讨论性能<br /><br>问题。如果业务不能保证，或者业务就是要求数据库来做约束，那么没得选，必须创建唯一索引。<br /><br>这种情况下，本节的意义在于，如果碰上了大量插入数据慢、内存命中率低的时候，给你多提供一<br /><br>个排查思路。<br /><br>然后，在一些“ 归档库 ”的场景，你是可以考虑使用唯一索引的。比如，线上数据只需要保留半年，<br /><br>然后历史数据保存在归档库。这时候，归档数据已经是确保没有唯一键冲突了。要提高归档效率，<br /><br>可以考虑把表里面的唯一索引改成普通索引。</li>\n</ol>\n<p><a name=\"cf46edb8\"></a></p>\n<h2 id=\"其他查询优化策略：\"><a href=\"#其他查询优化策略：\" class=\"headerlink\" title=\"其他查询优化策略：\"></a>其他查询优化策略：</h2><p><a name=\"15342591\"></a></p>\n<h5 id=\"1-EXISTS-和-IN：\"><a href=\"#1-EXISTS-和-IN：\" class=\"headerlink\" title=\"1.EXISTS 和 IN：\"></a>1.EXISTS 和 IN：</h5><p>具体看表的大小，要符合小表驱动大表的原则</p>\n<p>如</p>\n<p>SELECT * FROM A WHERE id IN (SELECT id FROM B)；——————①</p>\n<p>SELECT * FROM A WHERE EXISTS (SELECT id FROM B WHERE B.id &#x3D; A.id)；——————②</p>\n<p>若A为小表，则使用②EXISTS</p>\n<p>若B为小表，则使用①IN</p>\n<p><a name=\"ea0ce293\"></a></p>\n<h5 id=\"2-COUNT-he-COUNT-具体字段-：\"><a href=\"#2-COUNT-he-COUNT-具体字段-：\" class=\"headerlink\" title=\"2.COUNT(*) he COUNT(具体字段)：\"></a>2.COUNT(*) he COUNT(具体字段)：</h5><p>问：在 MySQL 中统计数据表的行数，可以使用三种方式： SELECT COUNT(*) 、 SELECT COUNT(1) 和<br /><br>SELECT COUNT(具体字段) ，使用这三者之间的查询效率是怎样的？</p>\n<p>答：</p>\n<p>1.COUNT(*)和COUNT(1)都是对所有结果进行COUNT，本质上没有区别，</p>\n<p>①如果使用MyISAM存储引擎，则复杂度为O(1)，因为MyISAM存储引擎中有一个mata信息记录了表中的记录数（row_count）而一致性则由表级锁来保证</p>\n<p>②如果使用InnoDB存储引擎则复杂度为O(n)，因为InnoDB支持事务，采用行级锁和MVCC机制，无法像MyISAM一样维护一个row_count变量，需要全表扫描</p>\n<p>2.在InnoDB存储引擎中，如果采用COUNT(具体字段)来统计数据行数，要尽量使用二级索引，因为主键索引使用的是聚簇索引，包含的信息较多，而对于COUNT(*)和COUNT(1)来说，它们不需要查找具体的行，只是统计行数，系统会自动采用占用空间更小的二级索引来进行统计</p>\n<p>如果存在多个二级索引，则会使用key_len更小的二级索引进行扫描，当没有二级索引的时候，才会使用主键索引来进行统计</p>\n<p><a name=\"7ae10766\"></a></p>\n<h5 id=\"3-关于SELECT-FROM-某个表：\"><a href=\"#3-关于SELECT-FROM-某个表：\" class=\"headerlink\" title=\"3.关于SELECT * FROM 某个表：\"></a>3.关于SELECT * FROM 某个表：</h5><p>在表查询中，建议明确字段，不要使用*作为查询的字段列表，推荐使用SELECT 具体字段 来进行查询</p>\n<p><a name=\"7e87cede\"></a></p>\n<h6 id=\"原因：\"><a href=\"#原因：\" class=\"headerlink\" title=\"原因：\"></a>原因：</h6><p>①：MySQL在解析的过程中，会通过查询数据字典将  ‘*‘  转换为所有字段的名称，会大大的耗费资源和时间</p>\n<p>②：无法使用覆盖索引</p>\n<p><a name=\"3128c31b\"></a></p>\n<h5 id=\"4-LIMIT-1-对优化的影响\"><a href=\"#4-LIMIT-1-对优化的影响\" class=\"headerlink\" title=\"4.LIMIT 1 对优化的影响\"></a>4.LIMIT 1 对优化的影响</h5><p>针对的是会扫描全表的SQL语句，如果你可以确定结果集只有一条，那么加上LIMIT 1 的时候，当找到一条结果的时候就不会继续进行扫描了，这样会加快查询速度</p>\n<p>如果数据表对字段已经建立了唯一索引，那么可以通过索引进行查询，不会对全表进行扫描，那么就不需要再加LIMIT 1</p>\n<p><a name=\"98dace36\"></a></p>\n<h5 id=\"5-多使用COMMIT进行手动提交\"><a href=\"#5-多使用COMMIT进行手动提交\" class=\"headerlink\" title=\"5.多使用COMMIT进行手动提交\"></a>5.多使用COMMIT进行手动提交</h5><p>COMMIT会释放资源：</p>\n<p>​\t1.回滚段上用户恢复数据的信息</p>\n<p>​\t2.被程序语句获得的锁</p>\n<p>​\t3.redo &#x2F; undo log buffer中的空间</p>\n<p>​\t4.管理上述三种资源中的内部花费</p>\n<p><a name=\"7951a229\"></a></p>\n<h2 id=\"索引失效的情况\"><a href=\"#索引失效的情况\" class=\"headerlink\" title=\"索引失效的情况\"></a>索引失效的情况</h2><p><a name=\"lxZQM\"></a></p>\n<h5 id=\"全值匹配\"><a href=\"#全值匹配\" class=\"headerlink\" title=\"全值匹配\"></a>全值匹配</h5><p>查询字段与所有的索引一一对应才可以使所有索引都生效</p>\n<p><a name=\"kN7rG\"></a></p>\n<h5 id=\"最左前缀法则\"><a href=\"#最左前缀法则\" class=\"headerlink\" title=\"最左前缀法则\"></a>最左前缀法则</h5><p>如由id，name，phone组成的联合索引，只查询name和phone则索引不生效，必须严格按照创建索引的顺序</p>\n<p><a name=\"QwYdY\"></a></p>\n<h5 id=\"计算、函数、类型转换（手动或自动）导致索引失效\"><a href=\"#计算、函数、类型转换（手动或自动）导致索引失效\" class=\"headerlink\" title=\"计算、函数、类型转换（手动或自动）导致索引失效\"></a>计算、函数、类型转换（手动或自动）导致索引失效</h5><p>如：EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE ‘abc%’;</p>\n<p>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) &#x3D; ‘abc’;</p>\n<p>使用left则会导致索引失效  原因是不知道name的值，而是把所有的值全取出再去前三个字符，判断是否与abc相等，并不会使用到索引</p>\n<p><a name=\"xPOIj\"></a></p>\n<h5 id=\"返回条件右边的列索引失效\"><a href=\"#返回条件右边的列索引失效\" class=\"headerlink\" title=\"返回条件右边的列索引失效\"></a>返回条件右边的列索引失效</h5><p>create index idx_age_name_classid on student(age，<strong>classid</strong>，<strong>name</strong>);   &#x2F;&#x2F;创建索引</p>\n<p>EXPLAIN SELECT SQL_NO_CACHE * FROM student<br />WHERE student.age&#x3D;30 AND student.classId&gt;20 AND student.name &#x3D; ‘abc’ ;</p>\n<p>上述sql name未使用索引（与写的条件的顺序无关 ）</p>\n<p><a name=\"NTWBY\"></a></p>\n<h6 id=\"改正：创建索引的时候把name写到返回条件classid的前面\"><a href=\"#改正：创建索引的时候把name写到返回条件classid的前面\" class=\"headerlink\" title=\"改正：创建索引的时候把name写到返回条件classid的前面\"></a>改正：创建索引的时候把name写到返回条件classid的前面</h6><p>create index idx_age_name_classid on student(age,<strong>name</strong>,<strong>classid</strong>);</p>\n<p><a name=\"aOmar\"></a></p>\n<h5 id=\"不等于-x3D-或者-lt-gt-导致索引失效\"><a href=\"#不等于-x3D-或者-lt-gt-导致索引失效\" class=\"headerlink\" title=\"不等于(!&#x3D;或者&lt;&gt;)导致索引失效\"></a>不等于(!&#x3D;或者&lt;&gt;)导致索引失效</h5><p>原因：在B+树中，若查找具体某个值如（where id &#x3D; 1） 则可以精确查找，但是不等于则无法查找，所以不等于会导致索引失效，只能一个一个去查找再判断是否相等</p>\n<p><a name=\"J4TIj\"></a></p>\n<h5 id=\"is-null可以使用索引，is-not-null-不能使用索引\"><a href=\"#is-null可以使用索引，is-not-null-不能使用索引\" class=\"headerlink\" title=\"is null可以使用索引，is not null 不能使用索引\"></a>is null可以使用索引，is not null 不能使用索引</h5><p>与上述不等于的情况类似，is null相当于等于某个值（值为null） 而is not null 相当于不等于某个值，不能使用索引判断</p>\n<p><a name=\"w8CuF\"></a></p>\n<h5 id=\"like以通配符-开头导致索引失效\"><a href=\"#like以通配符-开头导致索引失效\" class=\"headerlink\" title=\"like以通配符%开头导致索引失效\"></a>like以通配符%开头导致索引失效</h5><p>如where name like ‘%abc’；</p>\n<p><a name=\"Sz4qs\"></a></p>\n<h5 id=\"or前后存在非索引的列导致索引失效\"><a href=\"#or前后存在非索引的列导致索引失效\" class=\"headerlink\" title=\"or前后存在非索引的列导致索引失效\"></a>or前后存在非索引的列导致索引失效</h5><p>EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE age &#x3D; 10 OR classid &#x3D; 100;</p>\n<p>若上述SQL只有age或classid作为索引则会导致索引失效，只有or前后的字段有索引才可以生效</p>\n<p><a name=\"hSD69\"></a></p>\n<h5 id=\"数据库和表的字符集统一\"><a href=\"#数据库和表的字符集统一\" class=\"headerlink\" title=\"数据库和表的字符集统一\"></a>数据库和表的字符集统一</h5><p>不同的字符集进行比较之前需要进行转换，使用到转换函数，导致索引失效</p>\n<p><a name=\"8c9d507e\"></a></p>\n<h4 id=\"总结：-2\"><a href=\"#总结：-2\" class=\"headerlink\" title=\"总结：\"></a>总结：</h4><p>1.对于单列索引，尽量选择针对当前查询过滤性更好的索引</p>\n<p>2.在选择组合索引的时候，当前查询中过滤性最好的索引越靠前越好</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">过滤性越好，筛选剩余的数据越少，给后面查询的压力越小<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>3.在选择组合索引的时候，尽量选择能够包含当前查询中的where子句中更多字段的索引</p>\n<p>4.在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面</p>\n<h2 id=\"索引（条件）下推：（ICP）\"><a href=\"#索引（条件）下推：（ICP）\" class=\"headerlink\" title=\"索引（条件）下推：（ICP）\"></a>索引（条件）下推：（ICP）</h2><p>例如：</p>\n<p>聚合索引 <strong>zipcode_lastname_id</strong></p>\n<p>EXPLAIN SELECT * FROM people</p>\n<p>WHERE zipcode &#x3D; ‘00001’</p>\n<p>AND lastname LIKE ‘%张%’</p>\n<p>AND address LIKE ‘%北京%’</p>\n<p>上述SQL语句就使用到索引下推，lastname的模糊查询导致索引失效，但是优化器并没有在使用完zipcode字段索引后就进行回表去查询数据，而是直接对lastname进行模糊查询，再过滤掉一部分数据后再进行回表，这种情况就叫索引下推（ICP)</p>\n<p><a name=\"99e2be14\"></a></p>\n<h4 id=\"ICP使用条件：\"><a href=\"#ICP使用条件：\" class=\"headerlink\" title=\"ICP使用条件：\"></a>ICP使用条件：</h4><p>1.ICP可以用于InnoDB和MyISAM表，对于InnoDB表，ICP仅用于二级索引。ICP的目标是减少全行读取次数，从而减少IO操作</p>\n<p>2.当SQL使用覆盖索引时，不支持ICP</p>\n<p>3.相关子查询不能使用ICP</p>\n<p><a name=\"c0ad4430\"></a></p>\n<h2 id=\"优先考虑覆盖索引\"><a href=\"#优先考虑覆盖索引\" class=\"headerlink\" title=\"优先考虑覆盖索引\"></a>优先考虑覆盖索引</h2><p>1.覆盖索引：一个索引包含了满足查询结果的数据就叫做覆盖索引</p>\n<p>简单来说就是：索引列+主键 包含select 到 from 之间查询的列</p>\n<p><a name=\"GU3ah\"></a></p>\n<h4 id=\"好处：\"><a href=\"#好处：\" class=\"headerlink\" title=\"好处：\"></a>好处：</h4><p>1.避免Innodb表进行索引的二次查询（回表）</p>\n<p>Innodb中，二级索引在叶子节点中保存的数据是行的主键信息，如果是用二级索引查询数据，在查到相应的键值后，还需要进行二次查询来获取真实数据</p>\n<p>在覆盖索引中，二级索引的键值可以获取我们需要的数据，避免了对主键的二次查询，减少了IO操作，提升了查询效率</p>\n<p>2.可以把随机IO成顺序IO加快查询效率</p>\n<p>由于覆盖索引是按照键值的顺序存储的，对于IO密集型的范围查找来说，对比随机从磁盘读取每一行的数据IO要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取IO转变为顺序IO。</p>\n<p>若不使用覆盖索引，需要进行回表操作，而不同的区可能处于不同的位置，会导致加载更多的磁盘数据</p>\n<p><a name=\"lkfSP\"></a></p>\n<h4 id=\"弊端：\"><a href=\"#弊端：\" class=\"headerlink\" title=\"弊端：\"></a>弊端：</h4><p>索引字段的维护需要付出代价，因此在建立冗余索引来支持覆盖索引时就需要权衡考虑</p>\n<p><a name=\"4acaf05e\"></a></p>\n<h2 id=\"主键的设计：\"><a href=\"#主键的设计：\" class=\"headerlink\" title=\"主键的设计：\"></a>主键的设计：</h2><p><a name=\"04d0163f\"></a></p>\n<h4 id=\"1-自增id存在的问题：\"><a href=\"#1-自增id存在的问题：\" class=\"headerlink\" title=\"1.自增id存在的问题：\"></a>1.自增id存在的问题：</h4><p><a name=\"17f62567\"></a></p>\n<h5 id=\"1-可靠性不高：\"><a href=\"#1-可靠性不高：\" class=\"headerlink\" title=\"1.可靠性不高：\"></a>1.可靠性不高：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">存在自增id回溯的问题，8.0版本进行了修复<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"6d0b0f57\"></a></p>\n<h5 id=\"2-安全性不高\"><a href=\"#2-安全性不高\" class=\"headerlink\" title=\"2.安全性不高\"></a>2.安全性不高</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">对外暴漏的接口可以非常容易的猜测对应的信息，如：user&#x2F;1这样的接口，从而对数据进行爬取<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"9ab30ee4\"></a></p>\n<h5 id=\"3-性能差：\"><a href=\"#3-性能差：\" class=\"headerlink\" title=\"3.性能差：\"></a>3.性能差：</h5><p>自增id的性能差，需要再数据库服务器端生成</p>\n<p><a name=\"e61baecb\"></a></p>\n<h5 id=\"4-交互多：\"><a href=\"#4-交互多：\" class=\"headerlink\" title=\"4.交互多：\"></a>4.交互多：</h5><p>业务还需要额外执行一次类似last_insert_id()的函数才能知道刚才插入的自增值，再多进行一次网络交互，在海量的并发系统中，多一条sql就多一次性能的开销</p>\n<p><a name=\"442653ff\"></a></p>\n<h5 id=\"5-局部唯一性：\"><a href=\"#5-局部唯一性：\" class=\"headerlink\" title=\"5.局部唯一性：\"></a>5.局部唯一性：</h5><p><strong>最重要的一点</strong>，自增id是局部唯一，只是在当前数据库实例中唯一，而不是全局唯一（在任意服务器间都是唯一的），在分布式系统说是噩梦</p>\n<p><a name=\"07732c4b\"></a></p>\n<h4 id=\"2-业务字段作为主键：不太合适\"><a href=\"#2-业务字段作为主键：不太合适\" class=\"headerlink\" title=\"2.业务字段作为主键：不太合适\"></a>2.业务字段作为主键：不太合适</h4><p>1.不能使用会员卡号作为主键</p>\n<p>​\t如果会员卡号不再使用注销了，就可以再给其他人用该卡号，会导致数据库中查询出该卡号的消费信息是上一个人的</p>\n<p>2.身份证号或电话也不能作为主键</p>\n<p>​\t电话注销，手机也存在被运营商收回再利用的情况</p>\n<p>​\t身份证号属于个人隐私，也不能使用</p>\n<hr>\n<p><a name=\"63f87851\"></a></p>\n<h4 id=\"设计主键的建议\"><a href=\"#设计主键的建议\" class=\"headerlink\" title=\"设计主键的建议:\"></a>设计主键的建议:</h4><p>非核心业务：对应表的主键自增ID 如日志，监控等信息</p>\n<p>核心业务：<strong>主键的设计应该是全局唯一且单调自增</strong>，全局唯一保证各个系统中都是唯一的，单调递增是希望插入时不影响数据库性能</p>\n<p><a name=\"0ccd566d\"></a></p>\n<h2 id=\"子查询优化\"><a href=\"#子查询优化\" class=\"headerlink\" title=\"子查询优化\"></a>子查询优化</h2><p><a name=\"dff36623\"></a></p>\n<h5 id=\"子查询执行效率不高的原因：\"><a href=\"#子查询执行效率不高的原因：\" class=\"headerlink\" title=\"子查询执行效率不高的原因：\"></a>子查询执行效率不高的原因：</h5><p>1.执行子查询时，MySQL需要为内层查询语句的查询结果建立一个临时表，然后外层查询语句从临时表中查询记录，查询完毕后再撤销临时表，这样会消耗过多的CPU和IO资源，产生大量慢查询</p>\n<p>2.子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响</p>\n<p>3.对于返回结果集比较大的子查询，其对查询性能也有一定的影响</p>\n<p><a name=\"a9ad4aab\"></a></p>\n<h5 id=\"优化：\"><a href=\"#优化：\" class=\"headerlink\" title=\"优化：\"></a>优化：</h5><p>建议在MySQL中使用连接（join）查询来替代子查询，连接查询不需要建立临时表，其速度比子查询要快，而且可以添加索引进一步优化性能</p>\n","text":"索引优化与查询优化哪些维度可以进行数据库调优？ 1.索引失效、没有充分利用索引 — 建立索引 2.关联查询太多join（设计缺陷或不得已的需求） – sql优化 3..服务器调优及各个参数设置（缓冲，线程数等） – 调整my.cnf 4.数据过多 – 分库分表 sql查询优化的大...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E4%B8%8E%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">索引优化与查询优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E7%BB%B4%E5%BA%A6%E5%8F%AF%E4%BB%A5%E8%BF%9B%E8%A1%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E8%B0%83%E4%BC%98%EF%BC%9F\"><span class=\"toc-text\">哪些维度可以进行数据库调优？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E3%80%81%E6%B2%A1%E6%9C%89%E5%85%85%E5%88%86%E5%88%A9%E7%94%A8%E7%B4%A2%E5%BC%95-%E2%80%94-%E5%BB%BA%E7%AB%8B%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">1.索引失效、没有充分利用索引 — 建立索引</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E5%A4%AA%E5%A4%9Ajoin%EF%BC%88%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7%E6%88%96%E4%B8%8D%E5%BE%97%E5%B7%B2%E7%9A%84%E9%9C%80%E6%B1%82%EF%BC%89-%E2%80%93-sql%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">2.关联查询太多join（设计缺陷或不得已的需求） – sql优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%B0%83%E4%BC%98%E5%8F%8A%E5%90%84%E4%B8%AA%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%EF%BC%88%E7%BC%93%E5%86%B2%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%AD%89%EF%BC%89-%E2%80%93-%E8%B0%83%E6%95%B4my-cnf\"><span class=\"toc-text\">3..服务器调优及各个参数设置（缓冲，线程数等） – 调整my.cnf</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%95%B0%E6%8D%AE%E8%BF%87%E5%A4%9A-%E2%80%93-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8\"><span class=\"toc-text\">4.数据过多 – 分库分表</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#sql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%9A%84%E5%A4%A7%E4%BD%93%E6%96%B9%E5%90%91-%E2%80%94\"><span class=\"toc-text\">sql查询优化的大体方向 —</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B3%E8%81%94%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">关联查询优化：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%83%85%E5%86%B5%E4%B8%80%EF%BC%9A%E5%B7%A6%E5%A4%96%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">情况一：左外连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%83%85%E5%86%B5%E4%BA%8C%EF%BC%9A%E5%86%85%E8%BF%9E%E6%8E%A5\"><span class=\"toc-text\">情况二：内连接</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">排序优化：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE%EF%BC%9A\"><span class=\"toc-text\">优化建议：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A-1\"><span class=\"toc-text\">总结：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#FileSort%E7%AE%97%E6%B3%95%EF%BC%9A%E5%8F%8C%E8%B7%AF%E6%8E%92%E5%BA%8F%E5%92%8C%E5%8D%95%E8%B7%AF%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">FileSort算法：双路排序和单路排序</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95%E5%92%8C%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">普通索引和唯一索引优化：</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%E7%AD%96%E7%95%A5%EF%BC%9A\"><span class=\"toc-text\">其他查询优化策略：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-EXISTS-%E5%92%8C-IN%EF%BC%9A\"><span class=\"toc-text\">1.EXISTS 和 IN：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-COUNT-he-COUNT-%E5%85%B7%E4%BD%93%E5%AD%97%E6%AE%B5-%EF%BC%9A\"><span class=\"toc-text\">2.COUNT(*) he COUNT(具体字段)：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%85%B3%E4%BA%8ESELECT-FROM-%E6%9F%90%E4%B8%AA%E8%A1%A8%EF%BC%9A\"><span class=\"toc-text\">3.关于SELECT * FROM 某个表：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">原因：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-LIMIT-1-%E5%AF%B9%E4%BC%98%E5%8C%96%E7%9A%84%E5%BD%B1%E5%93%8D\"><span class=\"toc-text\">4.LIMIT 1 对优化的影响</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%A4%9A%E4%BD%BF%E7%94%A8COMMIT%E8%BF%9B%E8%A1%8C%E6%89%8B%E5%8A%A8%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">5.多使用COMMIT进行手动提交</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">索引失效的情况</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%85%A8%E5%80%BC%E5%8C%B9%E9%85%8D\"><span class=\"toc-text\">全值匹配</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E6%B3%95%E5%88%99\"><span class=\"toc-text\">最左前缀法则</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%AE%A1%E7%AE%97%E3%80%81%E5%87%BD%E6%95%B0%E3%80%81%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%89%8B%E5%8A%A8%E6%88%96%E8%87%AA%E5%8A%A8%EF%BC%89%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">计算、函数、类型转换（手动或自动）导致索引失效</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%94%E5%9B%9E%E6%9D%A1%E4%BB%B6%E5%8F%B3%E8%BE%B9%E7%9A%84%E5%88%97%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">返回条件右边的列索引失效</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%94%B9%E6%AD%A3%EF%BC%9A%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95%E7%9A%84%E6%97%B6%E5%80%99%E6%8A%8Aname%E5%86%99%E5%88%B0%E8%BF%94%E5%9B%9E%E6%9D%A1%E4%BB%B6classid%E7%9A%84%E5%89%8D%E9%9D%A2\"><span class=\"toc-text\">改正：创建索引的时候把name写到返回条件classid的前面</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E7%AD%89%E4%BA%8E-x3D-%E6%88%96%E8%80%85-lt-gt-%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">不等于(!&#x3D;或者&lt;&gt;)导致索引失效</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#is-null%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95%EF%BC%8Cis-not-null-%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">is null可以使用索引，is not null 不能使用索引</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#like%E4%BB%A5%E9%80%9A%E9%85%8D%E7%AC%A6-%E5%BC%80%E5%A4%B4%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">like以通配符%开头导致索引失效</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#or%E5%89%8D%E5%90%8E%E5%AD%98%E5%9C%A8%E9%9D%9E%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%97%E5%AF%BC%E8%87%B4%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88\"><span class=\"toc-text\">or前后存在非索引的列导致索引失效</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BB%9F%E4%B8%80\"><span class=\"toc-text\">数据库和表的字符集统一</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A-2\"><span class=\"toc-text\">总结：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%EF%BC%88%E6%9D%A1%E4%BB%B6%EF%BC%89%E4%B8%8B%E6%8E%A8%EF%BC%9A%EF%BC%88ICP%EF%BC%89\"><span class=\"toc-text\">索引（条件）下推：（ICP）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ICP%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%EF%BC%9A\"><span class=\"toc-text\">ICP使用条件：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%85%88%E8%80%83%E8%99%91%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">优先考虑覆盖索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A5%BD%E5%A4%84%EF%BC%9A\"><span class=\"toc-text\">好处：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%BC%8A%E7%AB%AF%EF%BC%9A\"><span class=\"toc-text\">弊端：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A\"><span class=\"toc-text\">主键的设计：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E8%87%AA%E5%A2%9Eid%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">1.自增id存在的问题：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%B8%8D%E9%AB%98%EF%BC%9A\"><span class=\"toc-text\">1.可靠性不高：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%8D%E9%AB%98\"><span class=\"toc-text\">2.安全性不高</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E6%80%A7%E8%83%BD%E5%B7%AE%EF%BC%9A\"><span class=\"toc-text\">3.性能差：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E4%BA%A4%E4%BA%92%E5%A4%9A%EF%BC%9A\"><span class=\"toc-text\">4.交互多：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%B1%80%E9%83%A8%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%9A\"><span class=\"toc-text\">5.局部唯一性：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E4%B8%9A%E5%8A%A1%E5%AD%97%E6%AE%B5%E4%BD%9C%E4%B8%BA%E4%B8%BB%E9%94%AE%EF%BC%9A%E4%B8%8D%E5%A4%AA%E5%90%88%E9%80%82\"><span class=\"toc-text\">2.业务字段作为主键：不太合适</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%AE%BE%E8%AE%A1%E4%B8%BB%E9%94%AE%E7%9A%84%E5%BB%BA%E8%AE%AE\"><span class=\"toc-text\">设计主键的建议:</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96\"><span class=\"toc-text\">子查询优化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%AD%90%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E4%B8%8D%E9%AB%98%E7%9A%84%E5%8E%9F%E5%9B%A0%EF%BC%9A\"><span class=\"toc-text\">子查询执行效率不高的原因：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BC%98%E5%8C%96%EF%BC%9A\"><span class=\"toc-text\">优化：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MySQL中的锁","uid":"55817b11714364db5e90bcd7c8c20421","slug":"MySQL中的锁","date":"2022-06-11T12:23:16.177Z","updated":"2022-06-19T12:44:26.660Z","comments":true,"path":"api/articles/MySQL中的锁.json","keywords":null,"cover":[],"text":" MySQL中的锁在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突也是影响数据库并...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"范式","uid":"4a36e618a4b7e38da744c1d2baebbf87","slug":"范式","date":"2022-06-11T11:53:14.859Z","updated":"2022-06-11T11:55:10.247Z","comments":true,"path":"api/articles/范式.json","keywords":null,"cover":[],"text":" 范式：在关系型数据库中，关于数据表设计的基本原则，规则就成为范式 目前关系型数据库有六种常见范式，按照范式级别，从低到高分别是：第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。 数据库...","link":"","photos":[],"count_time":{"symbolsCount":"1.4k","symbolsTime":"1 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
{"title":"MySQL中的锁","uid":"55817b11714364db5e90bcd7c8c20421","slug":"MySQL中的锁","date":"2022-06-11T12:23:16.177Z","updated":"2022-06-19T12:44:26.660Z","comments":true,"path":"api/articles/MySQL中的锁.json","keywords":null,"cover":[],"content":"<p><a name=\"a6148931\"></a></p>\n<h1 id=\"MySQL中的锁\"><a href=\"#MySQL中的锁\" class=\"headerlink\" title=\"MySQL中的锁\"></a>MySQL中的锁</h1><p>在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的<br />资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL<br />的各个隔离级别提供了保证。 锁冲突也是影响数据库并发访问性能的一个重要因素。所以锁对数据库而<br />言显得尤其重要，也更加复杂。</p>\n<p><a name=\"6981eb67\"></a></p>\n<h3 id=\"并发问题的解决方案：\"><a href=\"#并发问题的解决方案：\" class=\"headerlink\" title=\"并发问题的解决方案：\"></a>并发问题的解决方案：</h3><p>1.读操作利用MVCC(多版本并发控制)，写操作进行加锁</p>\n<p>2.读写均进行加锁（读-写  彼此需要排队执行，影响性能）</p>\n<p><a name=\"e7d2e85a\"></a></p>\n<h3 id=\"分类：\"><a href=\"#分类：\" class=\"headerlink\" title=\"分类：\"></a>分类：</h3><p><img src=\"/../assets/1647330415924-fd19b2ca-7fd7-4e3f-aa74-a9801e66d694.png\" alt=\"1646550591725.png\"></p>\n<p><a name=\"40e1530c\"></a></p>\n<h5 id=\"1-从数据操作类型分类：读锁、写锁：\"><a href=\"#1-从数据操作类型分类：读锁、写锁：\" class=\"headerlink\" title=\"1.从数据操作类型分类：读锁、写锁：\"></a>1.从数据操作类型分类：读锁、写锁：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">读锁：也称共享锁。或S锁 针对同一份数据，多个事务的读操作可以同时进行而不会互相影响也不会互相阻塞\n\n写锁：也称排他锁。或X锁 当前写操作没完成前，会阻断其他写锁和读锁，确保给定的时间中，只有一个事务可以执行<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>注意：对于InnoDB来说，读锁和写锁可以加在表上，也可以加在行上，MyISAM不能加在行上</p>\n<p><a name=\"5fcd843b\"></a></p>\n<h5 id=\"2-从数据操作的粒度划分：表级锁，页级锁，行锁\"><a href=\"#2-从数据操作的粒度划分：表级锁，页级锁，行锁\" class=\"headerlink\" title=\"2.从数据操作的粒度划分：表级锁，页级锁，行锁\"></a>2.从数据操作的粒度划分：表级锁，页级锁，行锁</h5><p>为了尽可能的提高数据库的并发度，每次锁定的数据的范围越小越好，理论上每次只锁定当前操作的数据的方案会得到最大的并发度，但是管理锁很耗费资源，因此数据库系统需要在高并发响应和系统性能两个方面进行平衡，这就是<strong>锁粒度</strong>的概念</p>\n<p><a name=\"b629f059\"></a></p>\n<h4 id=\"表锁：\"><a href=\"#表锁：\" class=\"headerlink\" title=\"表锁：\"></a><strong>表锁</strong>：</h4><p>锁定整张表，是MySQL最基本的锁策略，<strong>可以避免死锁</strong>，但是并发量大大降低</p>\n<p><a name=\"4b47b0dc\"></a></p>\n<h5 id=\"①-表级别的S锁和X锁（不建议在InnoDB中使用）\"><a href=\"#①-表级别的S锁和X锁（不建议在InnoDB中使用）\" class=\"headerlink\" title=\"① 表级别的S锁和X锁（不建议在InnoDB中使用）\"></a>① 表级别的S锁和X锁（不建议在InnoDB中使用）</h5><p><a name=\"27b17a01\"></a></p>\n<h5 id=\"②-意向锁：不需要显示的添加\"><a href=\"#②-意向锁：不需要显示的添加\" class=\"headerlink\" title=\"② 意向锁：不需要显示的添加\"></a>② 意向锁：不需要显示的添加</h5><p>InnoDB支持多粒度锁，允许行级锁和表级锁共存</p>\n<p>1.意向锁的存在是为了协调行锁和表锁的关系，支持多粒度（表锁和行锁）的锁共存</p>\n<p>2.意向锁是一种不与行级锁冲突的表级锁</p>\n<p>3.表明某个事务正在某些行持有了锁或者该事务准备去持有锁</p>\n<p><a name=\"e8b57594\"></a></p>\n<h5 id=\"意向锁分为两种：\"><a href=\"#意向锁分为两种：\" class=\"headerlink\" title=\"意向锁分为两种：\"></a>意向锁分为两种：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">1.意向共享锁：事务有意对表中的某些行加共享锁\n\n2.意向排他锁：事务有意对表中的某些行加排他锁<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"d5b9aa63\"></a></p>\n<h6 id=\"意向锁需要解决的问题：\"><a href=\"#意向锁需要解决的问题：\" class=\"headerlink\" title=\"意向锁需要解决的问题：\"></a>意向锁需要解决的问题：</h6><p>如果我们给某一行数据加了排他锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排他锁了</p>\n<p><a name=\"7d8cff45\"></a></p>\n<h5 id=\"③-自增锁（保证主键唯一性）\"><a href=\"#③-自增锁（保证主键唯一性）\" class=\"headerlink\" title=\"③ 自增锁（保证主键唯一性）\"></a>③ 自增锁（保证主键唯一性）</h5><p><a name=\"63385559\"></a></p>\n<h5 id=\"④-元数据锁（MDL锁）：不需要显示的添加\"><a href=\"#④-元数据锁（MDL锁）：不需要显示的添加\" class=\"headerlink\" title=\"④ 元数据锁（MDL锁）：不需要显示的添加\"></a>④ 元数据锁（MDL锁）：不需要显示的添加</h5><p>当对一个表做增删改查操作的时候，加MDL读锁，当要对<strong>表结构变更操作</strong>的时候，加MDL写锁</p>\n<p><a name=\"0bb6e00a\"></a></p>\n<h4 id=\"InnoDB中行锁：只在存储引擎层实现\"><a href=\"#InnoDB中行锁：只在存储引擎层实现\" class=\"headerlink\" title=\"InnoDB中行锁：只在存储引擎层实现\"></a>InnoDB中行锁：只在存储引擎层实现</h4><p>优点：锁的力度小，发生锁冲突的概率低，可以实现高并发</p>\n<p>缺点：对于锁的开销比较大，加锁会比较慢，容易出现死锁</p>\n<p>InnoDB与MyISAM最大的区别：一是支持事务，二是支持行级锁</p>\n<p><a name=\"39db6643\"></a></p>\n<h5 id=\"①-记录锁：仅仅把一条记录锁上（同样有S和X两种锁）\"><a href=\"#①-记录锁：仅仅把一条记录锁上（同样有S和X两种锁）\" class=\"headerlink\" title=\"① 记录锁：仅仅把一条记录锁上（同样有S和X两种锁）\"></a>① 记录锁：仅仅把一条记录锁上（同样有S和X两种锁）</h5><p><a name=\"d35f392f\"></a></p>\n<h5 id=\"②-间隙锁（gap锁）：仅仅为了方式插入幻影记录，出现幻读，在某个区间范围加锁\"><a href=\"#②-间隙锁（gap锁）：仅仅为了方式插入幻影记录，出现幻读，在某个区间范围加锁\" class=\"headerlink\" title=\"② 间隙锁（gap锁）：仅仅为了方式插入幻影记录，出现幻读，在某个区间范围加锁\"></a>② 间隙锁（gap锁）：仅仅为了方式插入幻影记录，出现幻读，在某个区间范围加锁</h5><p><a name=\"146e7a42\"></a></p>\n<h6 id=\"间隙锁可能会导致死锁\"><a href=\"#间隙锁可能会导致死锁\" class=\"headerlink\" title=\"间隙锁可能会导致死锁\"></a>间隙锁可能会导致死锁</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">两个事务锁定了统一个范围，就会导致均不能对该范围进行操作<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"2cd86269\"></a></p>\n<h5 id=\"③-临键锁：相当于前两种锁的合体，相当于给间隙锁加上一个闭区间\"><a href=\"#③-临键锁：相当于前两种锁的合体，相当于给间隙锁加上一个闭区间\" class=\"headerlink\" title=\"③ 临键锁：相当于前两种锁的合体，相当于给间隙锁加上一个闭区间\"></a>③ 临键锁：相当于前两种锁的合体，相当于给间隙锁加上一个闭区间</h5><p><a name=\"ae2b59ed\"></a></p>\n<h5 id=\"④-插入意向锁：\"><a href=\"#④-插入意向锁：\" class=\"headerlink\" title=\"④ 插入意向锁：\"></a>④ 插入意向锁：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">一个事务在插入一条记录的时候需要判断一下插入的位置是否被别的事务加了gap锁，若有则需要等待，直到那一个事务进行提交,但是InnoDB规定事务在等待的时候页需要在内存中生成一个锁结构，就是插入意向锁<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>插入意向锁是一种gap锁，并不是意向锁，在insert操作时产生</p>\n<hr>\n<p><a name=\"e41746d3\"></a></p>\n<h4 id=\"页锁：\"><a href=\"#页锁：\" class=\"headerlink\" title=\"页锁：\"></a>页锁：</h4><p>页锁的开销介于表锁和行锁之间，也会出现死锁，并发度一般</p>\n<hr>\n<p><a name=\"c0600a0a\"></a></p>\n<h5 id=\"3-从对待锁的态度分类：乐观锁和悲观锁（两种设计思想，并不是具体实现）\"><a href=\"#3-从对待锁的态度分类：乐观锁和悲观锁（两种设计思想，并不是具体实现）\" class=\"headerlink\" title=\"3.从对待锁的态度分类：乐观锁和悲观锁（两种设计思想，并不是具体实现）\"></a>3.从对待锁的态度分类：乐观锁和悲观锁（两种设计思想，并不是具体实现）</h5><ol>\n<li><a name=\"3a6ec510\"></a></li>\n</ol>\n<h5 id=\"悲观锁（Pessimistic-Locking）\"><a href=\"#悲观锁（Pessimistic-Locking）\" class=\"headerlink\" title=\"悲观锁（Pessimistic Locking）\"></a>悲观锁（Pessimistic Locking）</h5><p>悲观锁是一种思想，顾名思义，就是很悲观，对数据被其他事务的修改持保守态度，会通过数据库自身<br />的锁机制来实现，从而保证数据操作的排它性。<br />悲观锁总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上<br />锁，这样别人想拿这个数据就会 阻塞 直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，<br />用完后再把资源转让给其它线程）。比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁，当<br />其他线程想要访问数据时，都需要阻塞挂起。Java中 synchronized 和 ReentrantLock 等独占锁就是<br />悲观锁思想的实现。</p>\n<ol start=\"2\">\n<li><a name=\"dae6de08\"></a></li>\n</ol>\n<h5 id=\"乐观锁（Optimistic-Locking）\"><a href=\"#乐观锁（Optimistic-Locking）\" class=\"headerlink\" title=\"乐观锁（Optimistic Locking）\"></a>乐观锁（Optimistic Locking）</h5><p>乐观锁认为对同一数据的并发操作不会总发生，属于小概率事件，不用每次都对数据上锁，但是在更新<br />的时候会判断一下在此期间别人有没有去更新这个数据，也就是不采用数据库自身的锁机制，而是通过<br />程序来实现。在程序上，我们可以采用 版本号机制 或者 CAS机制 实现。乐观锁适用于多读的应用类型，<br />这样可以提高吞吐量。在Java中 java.util.concurrent.atomic 包下的原子变量类就是使用了乐观锁<br />begin;<br />select * from student where id &lt;&#x3D;8 and id &gt; 3 for update;<br />的一种实现方式：CAS实现的。</p>\n<p><a name=\"304bb6d0\"></a></p>\n<h6 id=\"乐观锁的版本号机制\"><a href=\"#乐观锁的版本号机制\" class=\"headerlink\" title=\"乐观锁的版本号机制\"></a>乐观锁的版本号机制</h6><p>在表中设计一个 版本字段 version ，第一次读的时候，会获取 version 字段的取值。然后对数据进行更<br />新或删除操作时，会执行 UPDATE … SET version&#x3D;version+1 WHERE version&#x3D;version 。此时<br />如果已经有事务对这条数据进行了更改，修改就不会成功。</p>\n<p><a name=\"93fbdc8a\"></a></p>\n<h6 id=\"乐观锁的时间戳机制\"><a href=\"#乐观锁的时间戳机制\" class=\"headerlink\" title=\"乐观锁的时间戳机制\"></a>乐观锁的时间戳机制</h6><p>时间戳和版本号机制一样，也是在更新提交的时候，将当前数据的时间戳和更新之前取得的时间戳进行<br />比较，如果两者一致则更新成功，否则就是版本冲突。<br />你能看到乐观锁就是程序员自己控制数据并发操作的权限，基本是通过给数据行增加一个戳（版本号或<br />者时间戳），从而证明当前拿到的数据是否最新。</p>\n<ol start=\"3\">\n<li><a name=\"0d6f5ed6\"></a></li>\n</ol>\n<h5 id=\"两种锁的适用场景\"><a href=\"#两种锁的适用场景\" class=\"headerlink\" title=\"两种锁的适用场景\"></a>两种锁的适用场景</h5><p>从这两种锁的设计思想中，我们总结一下乐观锁和悲观锁的适用场景：</p>\n<p><strong>乐观锁</strong> 适合 读操作多 的场景，相对来说写的操作比较少。它的优点在于 程序实现 ， 不存在死锁<br />问题，不过适用场景也会相对乐观，因为它阻止不了除了程序以外的数据库操作。</p>\n<p><strong>悲观锁</strong> 适合 写操作多 的场景，因为写的操作具有 排它性 。采用悲观锁的方式，可以在数据库层<br />面阻止其他事务对该数据的操作权限，防止 读 - 写 和 写 - 写 的冲突</p>\n<p><a name=\"938b753f\"></a></p>\n<h5 id=\"4-按照加锁的方式进行划分：显式锁和隐式锁\"><a href=\"#4-按照加锁的方式进行划分：显式锁和隐式锁\" class=\"headerlink\" title=\"4.按照加锁的方式进行划分：显式锁和隐式锁\"></a>4.按照加锁的方式进行划分：显式锁和隐式锁</h5><p><a name=\"5a57901e\"></a></p>\n<h5 id=\"5-全局锁\"><a href=\"#5-全局锁\" class=\"headerlink\" title=\"5.全局锁\"></a>5.全局锁</h5><p>锁定整个数据库，当你需要让整个数据库处于只读状态，其他线程的DML和DDL操作会被阻塞，全局锁的典型使用场景是：做<strong>全库逻辑备份</strong></p>\n<p><a name=\"edb0e7a0\"></a></p>\n<h5 id=\"6-死锁\"><a href=\"#6-死锁\" class=\"headerlink\" title=\"6.死锁\"></a>6.死锁</h5><p>两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁</p>\n<p>如何处理死锁？</p>\n<p>1.等待，直到超时（可以设置超时时间）</p>\n<p>2.死锁的检测机制（wait-for grap算法）</p>\n<p><a name=\"5cb1d9ab\"></a></p>\n<h5 id=\"如何避免死锁：\"><a href=\"#如何避免死锁：\" class=\"headerlink\" title=\"如何避免死锁：\"></a>如何避免死锁：</h5><p>1.合理设计索引，是业务SQL尽可能通过索引定位更少的行，减少锁竞争</p>\n<p>2.调整业务逻辑SQL执行顺序，避免更新&#x2F;删除长时间持有锁的SQL在事务前面</p>\n<p>3.避免大事务，可以将大事务拆分成多个小事务来进行处理，小事务缩短锁定资源的时间，发生锁冲突的几率更小</p>\n<p>4.在并发比较高的系统中，不要显示的加锁，特别是在事务中显示加锁</p>\n<p>5.降低隔离级别</p>\n<p><img src=\"/../assets/1647330452986-22b08389-68c2-4045-b64b-7dd90df49fbf.png\" alt=\"1646625844994.png\"></p>\n<p>结构解析：</p>\n<ol>\n<li>锁所在的事务信息 ：<br />不论是 表锁 还是 行锁 ，都是在事务执行过程中生成的，哪个事务生成了这个 锁结构 ，这里就记录这个<br />事务的信息。<br />此 锁所在的事务信息 在内存结构中只是一个指针，通过指针可以找到内存中关于该事务的更多信息，比<br />方说事务id等。 </li>\n<li>索引信息 ：<br />对于 行锁 来说，需要记录一下加锁的记录是属于哪个索引的。这里也是一个指针。 </li>\n<li>表锁／行锁信息 ：<br />表锁结构 和 行锁结构 在这个位置的内容是不同的：<br />表锁：<br />记载着是对哪个表加的锁，还有其他的一些信息。<br />行锁：<br />记载了三个重要的信息：<br />Space ID ：记录所在表空间。<br />Page Number ：记录所在页号。<br />n_bits ：对于行锁来说，一条记录就对应着一个比特位，一个页面中包含很多记录，用不同<br />的比特位来区分到底是哪一条记录加了锁。为此在行锁结构的末尾放置了一堆比特位，这个<br />n_bits 属性代表使用了多少比特位。<br />n_bits的值一般都比页面中记录条数多一些。主要是为了之后在页面中插入了新记录后<br />也不至于重新分配锁结构 </li>\n<li>type_mode ：<br />这是一个32位的数，被分成了 lock_mode 、 lock_type 和 rec_lock_type 三个部分，如图所示：</li>\n</ol>\n<p><img src=\"/../assets/1647330466787-7a56f9ab-7ab3-4c84-af45-47a248df6c49.png\" alt=\"1646625884243.png\"><br />锁的模式（ lock_mode ），占用低4位，可选的值如下：<br />LOCK_IS （十进制的 0 ）：表示共享意向锁，也就是 IS锁 。<br />LOCK_IX （十进制的 1 ）：表示独占意向锁，也就是 IX锁 。<br />LOCK_S （十进制的 2 ）：表示共享锁，也就是 S锁 。<br />LOCK_X （十进制的 3 ）：表示独占锁，也就是 X锁 。<br />LOCK_AUTO_INC （十进制的 4 ）：表示 AUTO-INC锁 。<br />在InnoDB存储引擎中，LOCK_IS，LOCK_IX，LOCK_AUTO_INC都算是表级锁的模式，LOCK_S和<br />LOCK_X既可以算是表级锁的模式，也可以是行级锁的模式。<br />锁的类型（ lock_type ），占用第5～8位，不过现阶段只有第5位和第6位被使用：<br />LOCK_TABLE （十进制的 16 ），也就是当第5个比特位置为1时，表示表级锁。<br />LOCK_REC （十进制的 32 ），也就是当第6个比特位置为1时，表示行级锁。<br />行锁的具体类型（ rec_lock_type ），使用其余的位来表示。只有在 lock_type 的值为<br />LOCK_REC 时，也就是只有在该锁为行级锁时，才会被细分为更多的类型：<br />LOCK_ORDINARY （十进制的 0 ）：表示 next-key锁 。<br />LOCK_GAP （十进制的 512 ）：也就是当第10个比特位置为1时，表示 gap锁 。<br />LOCK_REC_NOT_GAP （十进制的 1024 ）：也就是当第11个比特位置为1时，表示正经 记录<br />锁 。<br />LOCK_INSERT_INTENTION （十进制的 2048 ）：也就是当第12个比特位置为1时，表示插入<br />意向锁。其他的类型：还有一些不常用的类型我们就不多说了。<br />is_waiting 属性呢？基于内存空间的节省，所以把 is_waiting 属性放到了 type_mode 这个32<br />位的数字中：<br />LOCK_WAIT （十进制的 256 ） ：当第9个比特位置为 1 时，表示 is_waiting 为 true ，也<br />就是当前事务尚未获取到锁，处在等待状态；当这个比特位为 0 时，表示 is_waiting 为<br />false ，也就是当前事务获取锁成功。</p>\n<ol start=\"5\">\n<li>其他信息 ：<br />为了更好的管理系统运行过程中生成的各种锁结构而设计了各种哈希表和链表。 </li>\n<li>一堆比特位 ：<br />如果是 行锁结构 的话，在该结构末尾还放置了一堆比特位，比特位的数量是由上边提到的 n_bits 属性<br />表示的。InnoDB数据页中的每条记录在 记录头信息 中都包含一个 heap_no 属性，伪记录 Infimum 的<br />heap_no 值为 0 ， Supremum 的 heap_no 值为 1 ，之后每插入一条记录， heap_no 值就增1。 锁结<br />构 最后的一堆比特位就对应着一个页面中的记录，一个比特位映射一个 heap_no ，即一个比特位映射<br />到页内的一条记录。</li>\n</ol>\n","text":" MySQL中的锁在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突也是影响数据库并...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#MySQL%E4%B8%AD%E7%9A%84%E9%94%81\"><span class=\"toc-text\">MySQL中的锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A\"><span class=\"toc-text\">并发问题的解决方案：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%88%86%E7%B1%BB%EF%BC%9A\"><span class=\"toc-text\">分类：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%EF%BC%9A%E8%AF%BB%E9%94%81%E3%80%81%E5%86%99%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">1.从数据操作类型分类：读锁、写锁：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%BB%8E%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C%E7%9A%84%E7%B2%92%E5%BA%A6%E5%88%92%E5%88%86%EF%BC%9A%E8%A1%A8%E7%BA%A7%E9%94%81%EF%BC%8C%E9%A1%B5%E7%BA%A7%E9%94%81%EF%BC%8C%E8%A1%8C%E9%94%81\"><span class=\"toc-text\">2.从数据操作的粒度划分：表级锁，页级锁，行锁</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%A1%A8%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">表锁：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84S%E9%94%81%E5%92%8CX%E9%94%81%EF%BC%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E5%9C%A8InnoDB%E4%B8%AD%E4%BD%BF%E7%94%A8%EF%BC%89\"><span class=\"toc-text\">① 表级别的S锁和X锁（不建议在InnoDB中使用）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E6%84%8F%E5%90%91%E9%94%81%EF%BC%9A%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E7%9A%84%E6%B7%BB%E5%8A%A0\"><span class=\"toc-text\">② 意向锁：不需要显示的添加</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%84%8F%E5%90%91%E9%94%81%E5%88%86%E4%B8%BA%E4%B8%A4%E7%A7%8D%EF%BC%9A\"><span class=\"toc-text\">意向锁分为两种：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%84%8F%E5%90%91%E9%94%81%E9%9C%80%E8%A6%81%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">意向锁需要解决的问题：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E8%87%AA%E5%A2%9E%E9%94%81%EF%BC%88%E4%BF%9D%E8%AF%81%E4%B8%BB%E9%94%AE%E5%94%AF%E4%B8%80%E6%80%A7%EF%BC%89\"><span class=\"toc-text\">③ 自增锁（保证主键唯一性）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81%EF%BC%88MDL%E9%94%81%EF%BC%89%EF%BC%9A%E4%B8%8D%E9%9C%80%E8%A6%81%E6%98%BE%E7%A4%BA%E7%9A%84%E6%B7%BB%E5%8A%A0\"><span class=\"toc-text\">④ 元数据锁（MDL锁）：不需要显示的添加</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#InnoDB%E4%B8%AD%E8%A1%8C%E9%94%81%EF%BC%9A%E5%8F%AA%E5%9C%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%B1%82%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">InnoDB中行锁：只在存储引擎层实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E8%AE%B0%E5%BD%95%E9%94%81%EF%BC%9A%E4%BB%85%E4%BB%85%E6%8A%8A%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95%E9%94%81%E4%B8%8A%EF%BC%88%E5%90%8C%E6%A0%B7%E6%9C%89S%E5%92%8CX%E4%B8%A4%E7%A7%8D%E9%94%81%EF%BC%89\"><span class=\"toc-text\">① 记录锁：仅仅把一条记录锁上（同样有S和X两种锁）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E9%97%B4%E9%9A%99%E9%94%81%EF%BC%88gap%E9%94%81%EF%BC%89%EF%BC%9A%E4%BB%85%E4%BB%85%E4%B8%BA%E4%BA%86%E6%96%B9%E5%BC%8F%E6%8F%92%E5%85%A5%E5%B9%BB%E5%BD%B1%E8%AE%B0%E5%BD%95%EF%BC%8C%E5%87%BA%E7%8E%B0%E5%B9%BB%E8%AF%BB%EF%BC%8C%E5%9C%A8%E6%9F%90%E4%B8%AA%E5%8C%BA%E9%97%B4%E8%8C%83%E5%9B%B4%E5%8A%A0%E9%94%81\"><span class=\"toc-text\">② 间隙锁（gap锁）：仅仅为了方式插入幻影记录，出现幻读，在某个区间范围加锁</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E9%97%B4%E9%9A%99%E9%94%81%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%AF%BC%E8%87%B4%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">间隙锁可能会导致死锁</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A2-%E4%B8%B4%E9%94%AE%E9%94%81%EF%BC%9A%E7%9B%B8%E5%BD%93%E4%BA%8E%E5%89%8D%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E5%90%88%E4%BD%93%EF%BC%8C%E7%9B%B8%E5%BD%93%E4%BA%8E%E7%BB%99%E9%97%B4%E9%9A%99%E9%94%81%E5%8A%A0%E4%B8%8A%E4%B8%80%E4%B8%AA%E9%97%AD%E5%8C%BA%E9%97%B4\"><span class=\"toc-text\">③ 临键锁：相当于前两种锁的合体，相当于给间隙锁加上一个闭区间</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E2%91%A3-%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">④ 插入意向锁：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">页锁：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BB%8E%E5%AF%B9%E5%BE%85%E9%94%81%E7%9A%84%E6%80%81%E5%BA%A6%E5%88%86%E7%B1%BB%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E5%85%B7%E4%BD%93%E5%AE%9E%E7%8E%B0%EF%BC%89\"><span class=\"toc-text\">3.从对待锁的态度分类：乐观锁和悲观锁（两种设计思想，并不是具体实现）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%82%B2%E8%A7%82%E9%94%81%EF%BC%88Pessimistic-Locking%EF%BC%89\"><span class=\"toc-text\">悲观锁（Pessimistic Locking）</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%EF%BC%88Optimistic-Locking%EF%BC%89\"><span class=\"toc-text\">乐观锁（Optimistic Locking）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%B7%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">乐观锁的版本号机制</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%B9%90%E8%A7%82%E9%94%81%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">乐观锁的时间戳机制</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E7%A7%8D%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">两种锁的适用场景</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%8C%89%E7%85%A7%E5%8A%A0%E9%94%81%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%9B%E8%A1%8C%E5%88%92%E5%88%86%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E5%92%8C%E9%9A%90%E5%BC%8F%E9%94%81\"><span class=\"toc-text\">4.按照加锁的方式进行划分：显式锁和隐式锁</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E5%85%A8%E5%B1%80%E9%94%81\"><span class=\"toc-text\">5.全局锁</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E6%AD%BB%E9%94%81\"><span class=\"toc-text\">6.死锁</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">如何避免死锁：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"事务","date":"2022-06-11T12:25:00.191Z","updated":"2022-06-11T12:25:34.870Z","comments":true,"path":"api/articles/事务.json","keywords":null,"cover":[],"text":"事务 事务的基础知识：在MySQL中只有InnoDB存储引擎支持事务 1.数据库事务的概述：事务是数据库区别于文件系统的重要特征之一，当我们有了事务就会让数据库始终保持一致性，同时我们还可以通过事务的机制恢复到某个时间点 基本概念：事务：是一组逻辑单元，使数据从一种状态转换到另一...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"索引优化与查询优化","uid":"70425fba86b2c28266d9c33de675b2d8","slug":"索引优化与查询优化","date":"2022-06-11T12:12:38.267Z","updated":"2022-06-11T12:21:33.664Z","comments":true,"path":"api/articles/索引优化与查询优化.json","keywords":null,"cover":[],"text":"索引优化与查询优化哪些维度可以进行数据库调优？ 1.索引失效、没有充分利用索引 — 建立索引 2.关联查询太多join（设计缺陷或不得已的需求） – sql优化 3..服务器调优及各个参数设置（缓冲，线程数等） – 调整my.cnf 4.数据过多 – 分库分表 sql查询优化的大...","link":"","photos":[],"count_time":{"symbolsCount":"7.1k","symbolsTime":"6 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
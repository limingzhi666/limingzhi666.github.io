{"title":"进程线程并行并发","uid":"6ce63568dd0197dd5234fafddc6d369d","slug":"进程线程并行并发","date":"2022-06-11T12:36:30.645Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/进程线程并行并发.json","keywords":null,"cover":null,"content":"<p><a name=\"6641aa3b\"></a></p>\n<h2 id=\"进程和线程：\"><a href=\"#进程和线程：\" class=\"headerlink\" title=\"进程和线程：\"></a>进程和线程：</h2><p><a name=\"dbd69b26\"></a></p>\n<h3 id=\"进程：资源分配的最小单位\"><a href=\"#进程：资源分配的最小单位\" class=\"headerlink\" title=\"进程：资源分配的最小单位\"></a>进程：资源分配的最小单位</h3><pre><code>程序由指令和数据组成，但这些指令需要运行，数据要读写，就必须将指令加载到CPU，数据加载至内存。在指令运行过程种还须需要用到磁盘，网络等设备。进程就是用来加载指令，管理内存，管理IO的\n\n当一个程序被运行，从磁盘加载这个程序的代码到内存种，这时就开启了一个进程\n\n进程可以理解为程序的一个实例。大部分程序可以同时运行多个进程（如记事本，浏览器等）但也有的程序只能启动一个线程（qq音乐等）\n</code></pre>\n<p><a name=\"30335701\"></a></p>\n<h3 id=\"线程：java中最小的调度单位\"><a href=\"#线程：java中最小的调度单位\" class=\"headerlink\" title=\"线程：java中最小的调度单位\"></a>线程：java中最小的调度单位</h3><pre><code>一个进程内可以分为一到多个线程\n\n一个线程就是一个指令流，将指令流种的一条条指令以一定的顺序交给CPU执行\n\njava中，线程作为最小调度单位，进程作为资源分配的最小单位，在Windows中进程是不活动的，只是作为线程的容器\n</code></pre>\n<p><a name=\"e29ae937\"></a></p>\n<h3 id=\"对比：\"><a href=\"#对比：\" class=\"headerlink\" title=\"对比：\"></a>对比：</h3><pre><code>1.进程基本上是相互独立的，而线程存在于进程内，是进程的一个子集\n\n2.进程拥有共享的资源，如内存空间，仅其内部的线程共享\n\n3.进程之间的通信较为复杂\n\n    ①.同一台计算机的进程通信称为IPC\n\n    ②.不同的计算机之间的进程通信，需要通过网络，遵守共同的协议，如HTTP\n\n4.线程的通信相对简单，因为他们共享进程内的内存，一个例子就是多个线程可以访问同一个共享变量\n\n5.线程更加轻量，线程上下文切换成本一般要比进程上下文成本低\n</code></pre>\n<p><a name=\"f3f3b6b0\"></a></p>\n<h2 id=\"并行和并发：\"><a href=\"#并行和并发：\" class=\"headerlink\" title=\"并行和并发：\"></a>并行和并发：</h2><p>单核CPU下，线程实际上还是串行执行的，操作系统中有一个组件叫做任务调度器，将cpu的时间片（很短）分给不同的线程使用，由于cpu在线程间的切换很快，人类感觉是同时运行的，总结就是：<strong>微观穿行，宏观并行</strong></p>\n<p><a name=\"2c5b83f4\"></a></p>\n<h5 id=\"一般会将这种线程轮流使用CPU的做法称为并发，concurrent\"><a href=\"#一般会将这种线程轮流使用CPU的做法称为并发，concurrent\" class=\"headerlink\" title=\"一般会将这种线程轮流使用CPU的做法称为并发，concurrent\"></a>一般会将这种线程轮流使用CPU的做法称为并发，concurrent</h5><p><a name=\"aed2fcb4\"></a></p>\n<h5 id=\"多核CPU下，每个核都可以调度运行线程，这时候线程是并行的\"><a href=\"#多核CPU下，每个核都可以调度运行线程，这时候线程是并行的\" class=\"headerlink\" title=\"多核CPU下，每个核都可以调度运行线程，这时候线程是并行的\"></a>多核CPU下，每个核都可以调度运行线程，这时候线程是并行的</h5><p><a name=\"c5f30ba8\"></a></p>\n<h5 id=\"并发：\"><a href=\"#并发：\" class=\"headerlink\" title=\"并发：\"></a>并发：</h5><pre><code>同一时间应对多件事情的能力\n</code></pre>\n<p><a name=\"9672c106\"></a></p>\n<h5 id=\"并行：\"><a href=\"#并行：\" class=\"headerlink\" title=\"并行：\"></a>并行：</h5><pre><code>同一时间动手去做多件事情的能力\n</code></pre>\n<p><a name=\"48407688\"></a></p>\n<h2 id=\"应用之异步调用\"><a href=\"#应用之异步调用\" class=\"headerlink\" title=\"应用之异步调用\"></a>应用之异步调用</h2><p><a name=\"188d67ce\"></a></p>\n<h5 id=\"同步：需要等待结果返回，才能继续运行\"><a href=\"#同步：需要等待结果返回，才能继续运行\" class=\"headerlink\" title=\"同步：需要等待结果返回，才能继续运行\"></a>同步：需要等待结果返回，才能继续运行</h5><p><a name=\"d8e77af5\"></a></p>\n<h5 id=\"异步：不需要等待结果返回就能继续运行\"><a href=\"#异步：不需要等待结果返回就能继续运行\" class=\"headerlink\" title=\"异步：不需要等待结果返回就能继续运行\"></a>异步：不需要等待结果返回就能继续运行</h5><p><a name=\"d88179b9\"></a></p>\n<h5 id=\"1-设计\"><a href=\"#1-设计\" class=\"headerlink\" title=\"1) 设计\"></a>1) 设计</h5><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如<br /><br>果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>\n<p><a name=\"a5409a61\"></a></p>\n<h5 id=\"2-结论\"><a href=\"#2-结论\" class=\"headerlink\" title=\"2) 结论\"></a>2) 结论</h5><p>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程<br /><br>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞 tomcat 的工作线程<br /><br>ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</p>\n","text":" 进程和线程： 进程：资源分配的最小单位程序由指令和数据组成，但这些指令需要运行，数据要读写，就必须将指令加载到CPU，数据加载至内存。在指令运行过程种还须需要用到磁盘，网络等设备。进程就是用来加载指令，管理内存，管理IO的 当一个程序被运行，从磁盘加载这个程序的代码到内存种，这...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">进程和线程：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%EF%BC%9A%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">进程：资源分配的最小单位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%EF%BC%9Ajava%E4%B8%AD%E6%9C%80%E5%B0%8F%E7%9A%84%E8%B0%83%E5%BA%A6%E5%8D%95%E4%BD%8D\"><span class=\"toc-text\">线程：java中最小的调度单位</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%B9%E6%AF%94%EF%BC%9A\"><span class=\"toc-text\">对比：</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%EF%BC%9A\"><span class=\"toc-text\">并行和并发：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E4%BC%9A%E5%B0%86%E8%BF%99%E7%A7%8D%E7%BA%BF%E7%A8%8B%E8%BD%AE%E6%B5%81%E4%BD%BF%E7%94%A8CPU%E7%9A%84%E5%81%9A%E6%B3%95%E7%A7%B0%E4%B8%BA%E5%B9%B6%E5%8F%91%EF%BC%8Cconcurrent\"><span class=\"toc-text\">一般会将这种线程轮流使用CPU的做法称为并发，concurrent</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E6%A0%B8CPU%E4%B8%8B%EF%BC%8C%E6%AF%8F%E4%B8%AA%E6%A0%B8%E9%83%BD%E5%8F%AF%E4%BB%A5%E8%B0%83%E5%BA%A6%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%B9%B6%E8%A1%8C%E7%9A%84\"><span class=\"toc-text\">多核CPU下，每个核都可以调度运行线程，这时候线程是并行的</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E5%8F%91%EF%BC%9A\"><span class=\"toc-text\">并发：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%B9%B6%E8%A1%8C%EF%BC%9A\"><span class=\"toc-text\">并行：</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">应用之异步调用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%EF%BC%9A%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%EF%BC%8C%E6%89%8D%E8%83%BD%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">同步：需要等待结果返回，才能继续运行</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5%EF%BC%9A%E4%B8%8D%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85%E7%BB%93%E6%9E%9C%E8%BF%94%E5%9B%9E%E5%B0%B1%E8%83%BD%E7%BB%A7%E7%BB%AD%E8%BF%90%E8%A1%8C\"><span class=\"toc-text\">异步：不需要等待结果返回就能继续运行</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">1) 设计</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">2) 结论</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"java线程","uid":"dffb2abec4fa02f1174c155cbd8d7f1a","slug":"java线程","date":"2022-06-11T12:49:10.748Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/java线程.json","keywords":null,"cover":[],"text":"java线程 创建和启动线程1.new Thread：public static void test1() &#123; Thread t = new Thread() &#123; //执行的方法 @Override public void run() &#123; log.d...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"事务","date":"2022-06-11T12:25:00.191Z","updated":"2022-06-11T12:25:34.870Z","comments":true,"path":"api/articles/事务.json","keywords":null,"cover":[],"text":"事务 事务的基础知识：在MySQL中只有InnoDB存储引擎支持事务 1.数据库事务的概述：事务是数据库区别于文件系统的重要特征之一，当我们有了事务就会让数据库始终保持一致性，同时我们还可以通过事务的机制恢复到某个时间点 基本概念：事务：是一组逻辑单元，使数据从一种状态转换到另一...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
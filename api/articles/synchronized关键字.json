{"title":"synchronized关键字","uid":"e1b3118af0455ea0158a80d4d6b7a3a6","slug":"synchronized关键字","date":"2022-06-11T12:58:01.936Z","updated":"2022-06-11T12:58:35.833Z","comments":true,"path":"api/articles/synchronized关键字.json","keywords":null,"cover":[],"content":"<meta name=\"referrer\" content=\"no-referrer\" />\n\n<p><a name=\"f28e0586\"></a></p>\n<h4 id=\"synchronized-解决方案\"><a href=\"#synchronized-解决方案\" class=\"headerlink\" title=\"synchronized 解决方案\"></a>synchronized 解决方案</h4><p><a name=\"a3bcabfa\"></a></p>\n<h5 id=\"互斥\"><a href=\"#互斥\" class=\"headerlink\" title=\"互斥\"></a>互斥</h5><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>\n<pre><code>阻塞式的解决方案：synchronized，Lock\n\n非阻塞式的解决方案：原子变量\n</code></pre>\n<p>synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程能持有</p>\n<p>【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区</p>\n<p>内的代码，不用担心线程上下文切换</p>\n<p>synchronized实际上是用对象锁保证了临界区内代码的原子性，临界区内的代码是不可分割的，不会被线程切换所打断</p>\n<hr>\n<p><a name=\"edc2da14\"></a></p>\n<h5 id=\"考察synchronized锁住的是哪个对象\"><a href=\"#考察synchronized锁住的是哪个对象\" class=\"headerlink\" title=\"考察synchronized锁住的是哪个对象\"></a>考察synchronized锁住的是哪个对象</h5><p>1.锁住的是n1-（this）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@Slf4j</span><span class=\"token punctuation\">(</span>topic <span class=\"token operator\">=</span> <span class=\"token string\">\"c.Number\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">&#123;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n <span class=\"token keyword\">public</span> <span class=\"token keyword\">synchronized</span> <span class=\"token keyword\">void</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span>\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n <span class=\"token class-name\">Number</span> n1 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Number</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span> n1<span class=\"token punctuation\">.</span><span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token punctuation\">&#123;</span> n1<span class=\"token punctuation\">.</span><span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>2.若synchronized加在静态方法上，则锁住的是当前类的运行时类对象（.class）</p>\n<hr>\n<p><a name=\"244bd311\"></a></p>\n<h5 id=\"变量的线程安全分析：\"><a href=\"#变量的线程安全分析：\" class=\"headerlink\" title=\"变量的线程安全分析：\"></a>变量的线程安全分析：</h5><p><a name=\"2eefdf6d\"></a></p>\n<h5 id=\"1-成员变量和静态变量是否线程安全？\"><a href=\"#1-成员变量和静态变量是否线程安全？\" class=\"headerlink\" title=\"1.成员变量和静态变量是否线程安全？\"></a>1.成员变量和静态变量是否线程安全？</h5><p>如果它们没有被共享，则是线程安全的</p>\n<p>如果它们被共享了，根据它们的状态是否能被改变，又分为两种情况</p>\n<pre><code>如果只有读操作，则线程安全\n\n如果有读写操作，则这段代码是临界区，需要考虑线程安全\n</code></pre>\n<p><a name=\"08483b1f\"></a></p>\n<h5 id=\"2-局部变量是否线程安全\"><a href=\"#2-局部变量是否线程安全\" class=\"headerlink\" title=\"2.局部变量是否线程安全\"></a>2.局部变量是否线程安全</h5><p>局部变量是线程安全的</p>\n<p>但局部变量引用的对象则未必</p>\n<pre><code>如果该对象没有逃离方法的作用访问。它是线程安全的\n\n如果该对象逃离方法的作用范围，需要考虑线程安全（如使用return）\n</code></pre>\n<p><a name=\"235fd8ae\"></a></p>\n<h5 id=\"3-线程安全的多个方法组合在一起不一定线程安全，需要在组合方法上添加线程安全保护\"><a href=\"#3-线程安全的多个方法组合在一起不一定线程安全，需要在组合方法上添加线程安全保护\" class=\"headerlink\" title=\"3.线程安全的多个方法组合在一起不一定线程安全，需要在组合方法上添加线程安全保护\"></a>3.线程安全的多个方法组合在一起不一定线程安全，需要在组合方法上添加线程安全保护</h5><p><a name=\"75156b50\"></a></p>\n<h5 id=\"4-不可变类线程安全\"><a href=\"#4-不可变类线程安全\" class=\"headerlink\" title=\"4.不可变类线程安全\"></a>4.不可变类线程安全</h5><pre><code>如String、Integer都是不可变类，内部的状态不可变，因此线程安全\n</code></pre>\n<p><a name=\"LIzBN\"></a></p>\n<h5 id=\"java对象的结构：\"><a href=\"#java对象的结构：\" class=\"headerlink\" title=\"java对象的结构：\"></a>java对象的结构：</h5><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331564265-946765a0-0db6-4c50-b632-9c43874e254c.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=OI8Wh&margin=%5Bobject%20Object%5D&name=1646818977749.png&originHeight=273&originWidth=226&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31026&status=done&style=none&taskId=uf759a681-354d-468c-8e6d-c5123688db7&title=\" alt=\"1646818977749.png\"><br><a name=\"t2V8x\"></a></p>\n<h6 id=\"1-对象头：\"><a href=\"#1-对象头：\" class=\"headerlink\" title=\"1.对象头：\"></a>1.对象头：</h6><pre><code>①：Mark Word：hashcode、分代年龄、状态、加锁状态位\n\n②：Klass word：类型指针（什么类型的对象）\n</code></pre>\n<p><a name=\"rmszF\"></a></p>\n<h6 id=\"2-对象体：\"><a href=\"#2-对象体：\" class=\"headerlink\" title=\"2.对象体：\"></a>2.对象体：</h6><pre><code>成员变量的信息\n</code></pre>\n<p><a name=\"F7kJ7\"></a></p>\n<h5 id=\"Java-对象头：\"><a href=\"#Java-对象头：\" class=\"headerlink\" title=\"Java 对象头：\"></a>Java 对象头：</h5><p>以 32 位虚拟机为例</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331647648-9cb72f7f-a22c-45b0-bc1e-7c8630a044ed.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=gUbTO&margin=%5Bobject%20Object%5D&name=1646816188296.png&originHeight=767&originWidth=815&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96448&status=done&style=none&taskId=uc7a77da7-028c-442f-96b0-404737cc97a&title=\" alt=\"1646816188296.png\"></p>\n<p>64 位虚拟机 Mark Word</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331657724-32b38b96-763d-4d69-a03d-8dfa8b0af79d.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=BGFXv&margin=%5Bobject%20Object%5D&name=1646816210489.png&originHeight=332&originWidth=797&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48869&status=done&style=none&taskId=u519fa2e8-8afd-48d6-ad06-328f75fd33b&title=\" alt=\"1646816210489.png\"></p>\n<p><a name=\"B37gp\"></a></p>\n<h4 id=\"Monitor概念\"><a href=\"#Monitor概念\" class=\"headerlink\" title=\"Monitor概念\"></a>Monitor概念</h4><p>Monitor被翻译为监视器或者管程</p>\n<p>每个Java对象都可以关联一个Monitor对象，如果使用synchronized给对象上锁（重量级）之后，该对象头的Mark Word中就被设置指向Monitor的指针</p>\n<p>Monitor结构如下:</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331664795-93569f93-828d-4255-b595-e2485367f62f.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=kWfnx&margin=%5Bobject%20Object%5D&name=1646817043063.png&originHeight=369&originWidth=932&originalType=binary&ratio=1&rotation=0&showTitle=false&size=159448&status=done&style=none&taskId=ud3f91798-c27e-4f22-bad1-804ad8b9476&title=\" alt=\"1646817043063.png\"></p>\n<p>1.刚开始Monitor种Owner为null</p>\n<p>2.当Thread-2执行synchronized(obj) 就会将Monitor的所有者Owner置为Thread-2，Monitor种只能有一个Owner</p>\n<p>3，在Thread-2上锁的过程种，如果Thread-3，4，5也来执行synchronized(obj) ，就会进入EntryList BLOCKED</p>\n<p>4.Thread-2执行完同步代码块的内容，然后唤醒EntryList种的等待线程来竞争锁，竞争是非公平的</p>\n<p>5.图中WaitSet种的Thread-0，Thread-1是之前获得过锁，当条件不满足WAITING状态的线程，后面讲wait-notify</p>\n<p>时分析</p>\n<pre><code>**注意：**\n\nsynchronized必须时进入同一个monitor才有上述效果\n\n不加synchronized的对象不会关联监视器，不遵从以上规则\n</code></pre>\n<p><a name=\"iRrlb\"></a></p>\n<h5 id=\"synchronized原理进阶：\"><a href=\"#synchronized原理进阶：\" class=\"headerlink\" title=\"synchronized原理进阶：\"></a>synchronized原理进阶：</h5><p><a name=\"OqIEp\"></a></p>\n<h6 id=\"轻量级锁：\"><a href=\"#轻量级锁：\" class=\"headerlink\" title=\"轻量级锁：\"></a>轻量级锁：</h6><p>使用场景：如果一个对象虽然有多线程访问，但多线程访问的时间是错开的（也就是没有竞争），那么可以使用轻量级锁</p>\n<p>轻量级锁对使用者是透明的，语法仍然为synchronized</p>\n<pre><code>1.创建锁记录(Lock Record)，每个线程的栈帧都会包含一个锁的记录，内存可以存储锁对象的Mark Word\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331672892-070b7bd5-6579-457e-ba07-5dd27a2fb346.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=S51SW&margin=%5Bobject%20Object%5D&name=1646819269864.png&originHeight=298&originWidth=564&originalType=binary&ratio=1&rotation=0&showTitle=false&size=74957&status=done&style=none&taskId=u5d55087d-5774-4296-9579-0c0b843cf8f&title=\" alt=\"1646819269864.png\"></p>\n<pre><code>2.让锁记录中Object reference 指向锁对象，并且尝试用cas替换Object中的Mark Word，将Mark Word的值存入锁记录（若Mark Word值已经被其他线程所修改则替换失败）\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331677706-96b88c01-6e5f-491d-8706-4ff5544e6299.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=Eof3x&margin=%5Bobject%20Object%5D&name=1646819423103.png&originHeight=332&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=96896&status=done&style=none&taskId=u4ffc58aa-4b8e-471e-90ff-2a6b7c78165&title=\" alt=\"1646819423103.png\"></p>\n<pre><code>3.如果cas替换成功，对象头中存储了锁记录地址和状态 00，表示由该线程给对象加锁\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331684295-f6ec6f3e-d6d7-4a06-b85c-868cf551ce31.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=m0jd9&margin=%5Bobject%20Object%5D&name=1646819563598.png&originHeight=331&originWidth=561&originalType=binary&ratio=1&rotation=0&showTitle=false&size=86859&status=done&style=none&taskId=u7bda4e91-1e43-4f32-9c4e-ace9616ce20&title=\" alt=\"1646819563598.png\"></p>\n<p><a name=\"pnn9u\"></a></p>\n<h6 id=\"如果cas失败：\"><a href=\"#如果cas失败：\" class=\"headerlink\" title=\"如果cas失败：\"></a>如果cas失败：</h6><pre><code>1.其他线程已经持有了该Object的轻量级锁，此时表明有竞争，进入锁膨胀过程\n\n2.如果是自己执行了synchronized锁重入，那么再添加一条Lock Record作为重入的计数&lt;br /&gt;![1646820022734.png](https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331695203-2b372579-5ee7-4efc-ae87-c2252e2679c6.png#clientId=u46ad077f-3ef3-4&amp;crop=0&amp;crop=0&amp;crop=1&amp;crop=1&amp;from=ui&amp;id=lrT5o&amp;margin=%5Bobject%20Object%5D&amp;name=1646820022734.png&amp;originHeight=359&amp;originWidth=597&amp;originalType=binary&amp;ratio=1&amp;rotation=0&amp;showTitle=false&amp;size=109184&amp;status=done&amp;style=none&amp;taskId=u75c465ef-1c37-456f-8a81-ec82f3f14d3&amp;title=)\n</code></pre>\n<p><a name=\"iwoqQ\"></a></p>\n<h5 id=\"解锁：\"><a href=\"#解锁：\" class=\"headerlink\" title=\"解锁：\"></a>解锁：</h5><pre><code>1.当退出synchronized代码块(解锁时) 如果有取值为null的锁记录，表示有重入，这时重置锁记录，表示重入计数减1\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331700148-c10bc06d-1a35-4574-9eed-971db387e798.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=E1uXK&margin=%5Bobject%20Object%5D&name=1646820139830.png&originHeight=325&originWidth=569&originalType=binary&ratio=1&rotation=0&showTitle=false&size=77873&status=done&style=none&taskId=u2b59c150-2256-4047-af83-0b67e90c399&title=\" alt=\"1646820139830.png\"></p>\n<pre><code>2.当退出synchronized代码块时，锁记录的值不为null，这是使用cas将Mark Word的值恢复给对象头\n\n    成功，则解锁成功\n\n    失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程\n</code></pre>\n<hr>\n<p><a name=\"NWHTs\"></a></p>\n<h4 id=\"2-锁膨胀：\"><a href=\"#2-锁膨胀：\" class=\"headerlink\" title=\"2.锁膨胀：\"></a>2.锁膨胀：</h4><p>如果在尝试加轻量级锁的过程中，CAS操作无法成功，这时一种情况就是有其他线程为此对象加上了轻量级锁(有竞争)，这时需要进行锁膨胀，将轻量级锁变为重量级锁</p>\n<p><a name=\"RHZwQ\"></a></p>\n<h6 id=\"1-当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁\"><a href=\"#1-当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁\" class=\"headerlink\" title=\"1.当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁\"></a>1.当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</h6><p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331711134-bfec0a44-ea3f-403e-8fca-313f248b18bf.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=kiLPy&margin=%5Bobject%20Object%5D&name=1646820530427.png&originHeight=335&originWidth=917&originalType=binary&ratio=1&rotation=0&showTitle=false&size=154768&status=done&style=none&taskId=u277a0719-beed-421e-aa01-7105a95210e&title=\" alt=\"1646820530427.png\"></p>\n<p><a name=\"TbNyM\"></a></p>\n<h6 id=\"2-这时Thread-1加轻量级锁失败，进入锁膨胀流程\"><a href=\"#2-这时Thread-1加轻量级锁失败，进入锁膨胀流程\" class=\"headerlink\" title=\"2.这时Thread-1加轻量级锁失败，进入锁膨胀流程\"></a>2.这时Thread-1加轻量级锁失败，进入锁膨胀流程</h6><pre><code>①：即为Object对象申请Monitor锁，让Object指向重量级锁地址（后两位数字变为10）\n\n②：然后自己进入Monitor的EntryList BLOCKED\n</code></pre>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331723636-10e38e48-aab4-4b1e-86ff-26e6fcd9063d.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=LNw96&margin=%5Bobject%20Object%5D&name=1646820663799.png&originHeight=349&originWidth=953&originalType=binary&ratio=1&rotation=0&showTitle=false&size=149788&status=done&style=none&taskId=u6538085b-3000-418c-84a2-0215196e841&title=\" alt=\"1646820663799.png\"></p>\n<p><a name=\"Nubsp\"></a></p>\n<h6 id=\"3-当Thread-0退出同步块解锁时，使用cas将Mark-Word的值恢复给对象头，失败，这时会进入重量级解锁流程：即按照Monitor地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的BLOCKED线程\"><a href=\"#3-当Thread-0退出同步块解锁时，使用cas将Mark-Word的值恢复给对象头，失败，这时会进入重量级解锁流程：即按照Monitor地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的BLOCKED线程\" class=\"headerlink\" title=\"3.当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败，这时会进入重量级解锁流程：即按照Monitor地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的BLOCKED线程\"></a>3.当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败，这时会进入重量级解锁流程：即按照Monitor地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的BLOCKED线程</h6><hr>\n<p><a name=\"fVcmz\"></a></p>\n<h4 id=\"3-自旋优化：（比较适合多核CPU）\"><a href=\"#3-自旋优化：（比较适合多核CPU）\" class=\"headerlink\" title=\"3.自旋优化：（比较适合多核CPU）\"></a>3.自旋优化：（比较适合多核CPU）</h4><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持有锁线程已经退出了同步块，释放了锁），这时当前线程就可以避免阻塞 (阻塞会发生上下文切换，消耗性能)</p>\n<p>自旋成功的情况：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331737005-be68d674-d629-43a0-afa9-23481e95be46.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=tZyhQ&margin=%5Bobject%20Object%5D&name=1646823854008.png&originHeight=564&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&size=184437&status=done&style=none&taskId=ud9862ced-b343-499e-94c5-8047f103f47&title=\" alt=\"1646823854008.png\"></p>\n<p>自旋失败的情况：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331748742-eed12473-fc55-4180-a963-1fb4bf4a01be.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=pTsfC&margin=%5Bobject%20Object%5D&name=1646823915727.png&originHeight=503&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&size=178807&status=done&style=none&taskId=uf713b8c4-3a1c-46e6-97d2-b13e1384c2c&title=\" alt=\"1646823915727.png\"></p>\n<p><strong>注意：</strong></p>\n<p>1.在java6之后自旋锁是自适应的，比如对象刚刚的一次自选操作成功过，那么认为这次自旋成功的可能性会高，就会多自旋几次；反之，就是少自旋甚至不自旋，比较只能</p>\n<p>2.自旋会占用CPU时间，单核CPU自旋就是浪费，多核CPU自旋才能发挥优势</p>\n<p>3.java 7 以后不能控制是否开启自旋功能</p>\n<hr>\n<p><a name=\"sVq35\"></a></p>\n<h4 id=\"4-偏向锁：\"><a href=\"#4-偏向锁：\" class=\"headerlink\" title=\"4.偏向锁：\"></a>4.偏向锁：</h4><p>轻量级锁在没有竞争时(就自己这个线程)，每次重入仍然需要执行CAS操作（性能损耗）</p>\n<p>java6中引入了偏向锁来做进一步优化：只有第一次使用CAS将线程ID设置到对象的Mark Word头，之后发现这个线程ID是自己的就没有表示竞争，不用重新CAS。以后只要不发生竞争，这个对象就归该线程所有</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331758667-d9e024ec-f3fa-4e8b-9b30-9c08719f35ea.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=GqR7e&margin=%5Bobject%20Object%5D&name=1646824479431.png&originHeight=371&originWidth=878&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83643&status=done&style=none&taskId=u86ba7020-2f2a-4297-91cc-c8f7ea29d49&title=\" alt=\"1646824479431.png\"></p>\n<p><a name=\"VQgWW\"></a></p>\n<h5 id=\"4-1-偏向状态：\"><a href=\"#4-1-偏向状态：\" class=\"headerlink\" title=\"4.1 偏向状态：\"></a>4.1 偏向状态：</h5><p>回忆对象头格式：</p>\n<p><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331764995-3921596a-4470-4ee1-8b89-38ccea895d64.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=F1BXf&margin=%5Bobject%20Object%5D&name=1646824815055.png&originHeight=391&originWidth=972&originalType=binary&ratio=1&rotation=0&showTitle=false&size=241294&status=done&style=none&taskId=u351c0e7c-a705-4211-b068-610f0013a48&title=\" alt=\"1646824815055.png\"></p>\n<p>一个对象创建时：</p>\n<pre><code>1.如果开启了偏向锁(默认开启)，那么对象创建后，markword值的后三位为101(biased_lock字段表示是否开启偏向锁，1为开启)，此时他的thread、epoc、age都为0\n\n2.偏向锁是默认延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加参数来禁用延迟\n\n3.如果没有开启偏向锁，那么对象创建后，markword值为001，此时他的hashcode、age、都为0，第一次用到hashcode时才会赋值\n\n4.处于偏向锁的对象解锁后，线程id仍存储于对象头中\n</code></pre>\n<p><strong>注意：</strong></p>\n<pre><code>当我们的程序本身就是线程很多，那么偏向锁就不适用，可以通过参数来禁用：\n\n添加VM参数： -xx:-UseBiasedLocking来禁用偏向锁\n</code></pre>\n<p><a name=\"sHjcL\"></a></p>\n<h5 id=\"4-2-撤销偏向锁—调用对象的hashcode方法\"><a href=\"#4-2-撤销偏向锁—调用对象的hashcode方法\" class=\"headerlink\" title=\"4.2 撤销偏向锁—调用对象的hashcode方法\"></a>4.2 撤销偏向锁—调用对象的hashcode方法</h5><p>当我们调用对象的hashcode方法就会禁用掉偏向锁</p>\n<p>原因：通过对象头的结构可知，Mark Word 的空间是有限的，当我们开启偏向锁，就会存储线程id，而没有空间存储hashcode，所以我们调用hashcode方法，就会关闭偏向锁，清除掉线程id替换为hashcode</p>\n<p><a name=\"hh3zx\"></a></p>\n<h5 id=\"为什么轻量级锁和重量级锁不会有上述问题？\"><a href=\"#为什么轻量级锁和重量级锁不会有上述问题？\" class=\"headerlink\" title=\"为什么轻量级锁和重量级锁不会有上述问题？\"></a>为什么轻量级锁和重量级锁不会有上述问题？</h5><ol>\n<li>轻量级锁会存储在线程栈帧的锁记录中</li>\n<li>重量级锁会将hashcode存储在Monitor对象中，解锁时再进行还原</li>\n<li>只有偏向锁没有额外的空间，所以会有上述问题</li>\n</ol>\n<p><a name=\"h8Y79\"></a></p>\n<h5 id=\"4-3-撤销偏向锁—其他线程使用对象\"><a href=\"#4-3-撤销偏向锁—其他线程使用对象\" class=\"headerlink\" title=\"4.3 撤销偏向锁—其他线程使用对象\"></a>4.3 撤销偏向锁—其他线程使用对象</h5><p>当其他线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p>\n<p><a name=\"PttCR\"></a></p>\n<h5 id=\"4-4-撤销偏向锁—调用wait-x2F-notify\"><a href=\"#4-4-撤销偏向锁—调用wait-x2F-notify\" class=\"headerlink\" title=\"4.4 撤销偏向锁—调用wait&#x2F;notify\"></a>4.4 撤销偏向锁—调用wait&#x2F;notify</h5><p>只有重量级锁才有这两个方法，所以调用会将偏向锁或轻量级锁转换为重量级锁</p>\n<p><a name=\"cIE1l\"></a></p>\n<h5 id=\"4-5-批量重偏向\"><a href=\"#4-5-批量重偏向\" class=\"headerlink\" title=\"4.5 批量重偏向\"></a>4.5 批量重偏向</h5><p>如果对象虽然被多个线程访问，但是没有竞争，这时偏向了线程T1的对象仍有机会重新偏向T2，重偏向会重置对象的Thread ID(线程ID)</p>\n<p>当撤销偏向锁的阈值超过了20次，jvm会觉得是不是偏向错了呢？于是会给在这些对象加锁时重新偏向至加锁线程</p>\n<p><a name=\"R5BqT\"></a></p>\n<h5 id=\"4-6-批量撤销\"><a href=\"#4-6-批量撤销\" class=\"headerlink\" title=\"4.6 批量撤销\"></a>4.6 批量撤销</h5><p>当撤销偏向锁的阈值超过了40次，jvm会觉得自己偏向错了，根本就不该偏向，就会把整个类的所有对象变为不可偏向的，新建的对象也是不可偏向的</p>\n<p><a name=\"tR1Bd\"></a></p>\n<h4 id=\"5-锁消除\"><a href=\"#5-锁消除\" class=\"headerlink\" title=\"5.锁消除\"></a>5.锁消除</h4><p>java运行时有一个JIT即时编译器，会对java字节码进一步优化，反复运行的代码超过一定的阈值就会进行即时优化，当发现变量不会存在线程安全问题，JIT就会把多余的synchronized去掉<br /><img src=\"https://cdn.nlark.com/yuque/0/2022/png/26737039/1647331776291-02fe3c41-c01a-481b-8ae4-d64bbf35697d.png#clientId=u46ad077f-3ef3-4&crop=0&crop=0&crop=1&crop=1&from=ui&id=GlY39&margin=%5Bobject%20Object%5D&name=1646830802690.png&originHeight=547&originWidth=504&originalType=binary&ratio=1&rotation=0&showTitle=false&size=112884&status=done&style=none&taskId=u010365c0-5f5c-45e2-8036-96ee4089daa&title=\" alt=\"1646830802690.png\"></p>\n<hr>\n<p><a name=\"VD4MF\"></a></p>\n<h4 id=\"6-锁的粗化\"><a href=\"#6-锁的粗化\" class=\"headerlink\" title=\"6.锁的粗化\"></a>6.锁的粗化</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n             <span class=\"token function\">sout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n     <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>锁粗化后：扩大锁的范围，避免反复加锁和释放锁</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n     <span class=\"token keyword\">synchronized</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Test</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">class</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n         <span class=\"token keyword\">for</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> i<span class=\"token operator\">=</span><span class=\"token number\">0</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">&lt;</span><span class=\"token number\">1000</span><span class=\"token punctuation\">;</span>i<span class=\"token operator\">++</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">&#123;</span>\n             <span class=\"token function\">sout</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n         <span class=\"token punctuation\">&#125;</span>\n     <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","text":" synchronized 解决方案 互斥为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#synchronized-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88\"><span class=\"toc-text\">synchronized 解决方案</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%92%E6%96%A5\"><span class=\"toc-text\">互斥</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%80%83%E5%AF%9Fsynchronized%E9%94%81%E4%BD%8F%E7%9A%84%E6%98%AF%E5%93%AA%E4%B8%AA%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">考察synchronized锁住的是哪个对象</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90%EF%BC%9A\"><span class=\"toc-text\">变量的线程安全分析：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F\"><span class=\"toc-text\">1.成员变量和静态变量是否线程安全？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">2.局部变量是否线程安全</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%A4%9A%E4%B8%AA%E6%96%B9%E6%B3%95%E7%BB%84%E5%90%88%E5%9C%A8%E4%B8%80%E8%B5%B7%E4%B8%8D%E4%B8%80%E5%AE%9A%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BB%84%E5%90%88%E6%96%B9%E6%B3%95%E4%B8%8A%E6%B7%BB%E5%8A%A0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4\"><span class=\"toc-text\">3.线程安全的多个方法组合在一起不一定线程安全，需要在组合方法上添加线程安全保护</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8\"><span class=\"toc-text\">4.不可变类线程安全</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#java%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BB%93%E6%9E%84%EF%BC%9A\"><span class=\"toc-text\">java对象的结构：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%9A\"><span class=\"toc-text\">1.对象头：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E5%AF%B9%E8%B1%A1%E4%BD%93%EF%BC%9A\"><span class=\"toc-text\">2.对象体：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Java-%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%9A\"><span class=\"toc-text\">Java 对象头：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Monitor%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Monitor概念</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#synchronized%E5%8E%9F%E7%90%86%E8%BF%9B%E9%98%B6%EF%BC%9A\"><span class=\"toc-text\">synchronized原理进阶：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">轻量级锁：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9Ccas%E5%A4%B1%E8%B4%A5%EF%BC%9A\"><span class=\"toc-text\">如果cas失败：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%A7%A3%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">解锁：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#2-%E9%94%81%E8%86%A8%E8%83%80%EF%BC%9A\"><span class=\"toc-text\">2.锁膨胀：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#1-%E5%BD%93Thread-1%E8%BF%9B%E8%A1%8C%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%8A%A0%E9%94%81%E6%97%B6%EF%BC%8CThread-0%E5%B7%B2%E7%BB%8F%E5%AF%B9%E8%AF%A5%E5%AF%B9%E8%B1%A1%E5%8A%A0%E4%BA%86%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81\"><span class=\"toc-text\">1.当Thread-1进行轻量级加锁时，Thread-0已经对该对象加了轻量级锁</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#2-%E8%BF%99%E6%97%B6Thread-1%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%BF%9B%E5%85%A5%E9%94%81%E8%86%A8%E8%83%80%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">2.这时Thread-1加轻量级锁失败，进入锁膨胀流程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#3-%E5%BD%93Thread-0%E9%80%80%E5%87%BA%E5%90%8C%E6%AD%A5%E5%9D%97%E8%A7%A3%E9%94%81%E6%97%B6%EF%BC%8C%E4%BD%BF%E7%94%A8cas%E5%B0%86Mark-Word%E7%9A%84%E5%80%BC%E6%81%A2%E5%A4%8D%E7%BB%99%E5%AF%B9%E8%B1%A1%E5%A4%B4%EF%BC%8C%E5%A4%B1%E8%B4%A5%EF%BC%8C%E8%BF%99%E6%97%B6%E4%BC%9A%E8%BF%9B%E5%85%A5%E9%87%8D%E9%87%8F%E7%BA%A7%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B%EF%BC%9A%E5%8D%B3%E6%8C%89%E7%85%A7Monitor%E5%9C%B0%E5%9D%80%E6%89%BE%E5%88%B0Monitor%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%B0%86Owner%E8%AE%BE%E7%BD%AE%E4%B8%BAnull%EF%BC%8C%E5%94%A4%E9%86%92EntryList%E4%B8%AD%E7%9A%84BLOCKED%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">3.当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败，这时会进入重量级解锁流程：即按照Monitor地址找到Monitor对象，将Owner设置为null，唤醒EntryList中的BLOCKED线程</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#3-%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%EF%BC%9A%EF%BC%88%E6%AF%94%E8%BE%83%E9%80%82%E5%90%88%E5%A4%9A%E6%A0%B8CPU%EF%BC%89\"><span class=\"toc-text\">3.自旋优化：（比较适合多核CPU）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#4-%E5%81%8F%E5%90%91%E9%94%81%EF%BC%9A\"><span class=\"toc-text\">4.偏向锁：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-1-%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">4.1 偏向状态：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-2-%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81%E2%80%94%E8%B0%83%E7%94%A8%E5%AF%B9%E8%B1%A1%E7%9A%84hashcode%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">4.2 撤销偏向锁—调用对象的hashcode方法</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E5%92%8C%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E4%B8%8D%E4%BC%9A%E6%9C%89%E4%B8%8A%E8%BF%B0%E9%97%AE%E9%A2%98%EF%BC%9F\"><span class=\"toc-text\">为什么轻量级锁和重量级锁不会有上述问题？</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-3-%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81%E2%80%94%E5%85%B6%E4%BB%96%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">4.3 撤销偏向锁—其他线程使用对象</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-4-%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91%E9%94%81%E2%80%94%E8%B0%83%E7%94%A8wait-x2F-notify\"><span class=\"toc-text\">4.4 撤销偏向锁—调用wait&#x2F;notify</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-5-%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91\"><span class=\"toc-text\">4.5 批量重偏向</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-6-%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80\"><span class=\"toc-text\">4.6 批量撤销</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#5-%E9%94%81%E6%B6%88%E9%99%A4\"><span class=\"toc-text\">5.锁消除</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#6-%E9%94%81%E7%9A%84%E7%B2%97%E5%8C%96\"><span class=\"toc-text\">6.锁的粗化</span></a></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"ReentrantLock原理","uid":"de5cee1035d10664a305cb1a74a3c58a","slug":"ReentrantLock","date":"2022-06-11T13:07:20.302Z","updated":"2022-06-11T13:21:17.762Z","comments":true,"path":"api/articles/ReentrantLock.json","keywords":null,"cover":[],"text":" ReentrantLock原理： 1.非公平锁的实现原理： 加锁解锁流程：先从构造器来看，默认为非公平锁实现 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; NonfairSync 继承自 AQS 没...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"java线程","uid":"dffb2abec4fa02f1174c155cbd8d7f1a","slug":"java线程","date":"2022-06-11T12:49:10.748Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/java线程.json","keywords":null,"cover":[],"text":"java线程 创建和启动线程1.new Thread：public static void test1() &#123; Thread t = new Thread() &#123; //执行的方法 @Override public void run() &#123; log.d...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
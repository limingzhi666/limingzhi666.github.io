{"title":"ReentrantLock原理","uid":"de5cee1035d10664a305cb1a74a3c58a","slug":"ReentrantLock","date":"2022-06-11T13:07:20.302Z","updated":"2022-06-11T13:21:17.762Z","comments":true,"path":"api/articles/ReentrantLock.json","keywords":null,"cover":[],"content":"<p><a name=\"2830faba\"></a></p>\n<h4 id=\"ReentrantLock原理：\"><a href=\"#ReentrantLock原理：\" class=\"headerlink\" title=\"ReentrantLock原理：\"></a>ReentrantLock原理：</h4><p><img src=\"/../assets/1647332604849-364ee5e1-8403-41eb-affc-04a1f11e4417.png\" alt=\"1.png\"></p>\n<p><a name=\"2351ad44\"></a></p>\n<h5 id=\"1-非公平锁的实现原理：\"><a href=\"#1-非公平锁的实现原理：\" class=\"headerlink\" title=\"1.非公平锁的实现原理：\"></a>1.非公平锁的实现原理：</h5><p><a name=\"011bc33c\"></a></p>\n<h5 id=\"加锁解锁流程：\"><a href=\"#加锁解锁流程：\" class=\"headerlink\" title=\"加锁解锁流程：\"></a>加锁解锁流程：</h5><p>先从构造器来看，默认为非公平锁实现</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token class-name\">ReentrantLock</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n\tsync <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">NonfairSync</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>NonfairSync 继承自 AQS</p>\n<p><a name=\"faa92334\"></a></p>\n<h6 id=\"没有竞争时：\"><a href=\"#没有竞争时：\" class=\"headerlink\" title=\"没有竞争时：\"></a>没有竞争时：</h6><p><img src=\"/../assets/1647332611411-0dee52f4-9db5-433d-813e-e98e8abab492.png\" alt=\"2.png\"></p>\n<p><a name=\"ae9013f3\"></a></p>\n<h6 id=\"第一个竞争出现时（state表示是否被加锁）\"><a href=\"#第一个竞争出现时（state表示是否被加锁）\" class=\"headerlink\" title=\"第一个竞争出现时（state表示是否被加锁）\"></a>第一个竞争出现时（state表示是否被加锁）</h6><p><img src=\"/../assets/1647332616361-7b24ef80-e024-48a4-86d7-a3a4b43a5b3d.png\" alt=\"3.png\"></p>\n<p><a name=\"e06d682b\"></a></p>\n<h6 id=\"Thread-1-执行流程\"><a href=\"#Thread-1-执行流程\" class=\"headerlink\" title=\"Thread-1 执行流程\"></a>Thread-1 执行流程</h6><p>1.CAS尝试将state从0改为1，结果失败了</p>\n<p>2.进入tryAcquire方法，重新尝试，此时state已经是1，结果仍然失败</p>\n<p>3.进入addWaiter方法，构造Node队列</p>\n<pre><code>①：图中黄色三角表示Node的wautStatus状态，默认为0正常状态\n\n②：Node的创建是懒惰的\n\n③：第一个Node称为Dummy（哨兵），用来占位，不关联线程\n</code></pre>\n<p><img src=\"/../assets/1647332628016-c93836ec-62f4-4d97-ba4e-b266b7512fe0.png\" alt=\"4.png\"></p>\n<p><a name=\"9a050f0e\"></a></p>\n<h6 id=\"当前线程进入acquireQueued方法\"><a href=\"#当前线程进入acquireQueued方法\" class=\"headerlink\" title=\"当前线程进入acquireQueued方法\"></a>当前线程进入acquireQueued方法</h6><pre><code>1.acquireQueued方法会在一个死循环中不断尝试获取锁，失败后就会被park阻塞\n\n2.如果自己是在哨兵node下一个，就会再次进入tryAcquire方法尝试获取锁，此时state仍为1，失败\n\n3.进入shouldParkAfterAcquore方法，将前去node的waitStatus改为-1，返回false\n</code></pre>\n<p><img src=\"/../assets/1647332634136-28c89df2-5300-471e-95d6-b8a4249f2791.png\" alt=\"5.png\"></p>\n<pre><code>4.shouldParkAfterFailedAcquire方法执行完毕回到acquireQueued方法，再次tryAcquire尝试获得锁，此时state还是1，获取失败\n\n5.当再次进入 shouldParkAfterFailedAcquire 时，此时因为i其前驱node的waitState已经是-1，此时返回true\n\n6.进入parkAndCheckInterrupt，Thread-1被park阻塞(图中用灰色表示)\n</code></pre>\n<p><img src=\"/../assets/1647332637953-07044a69-fb04-49fe-8c77-51def643245c.png\" alt=\"6.png\"></p>\n<p><a name=\"112b61a9\"></a></p>\n<h6 id=\"再次有多个线程经历上述过程竞争失败，变成这个样子\"><a href=\"#再次有多个线程经历上述过程竞争失败，变成这个样子\" class=\"headerlink\" title=\"再次有多个线程经历上述过程竞争失败，变成这个样子\"></a>再次有多个线程经历上述过程竞争失败，变成这个样子</h6><p><img src=\"/../assets/1647332645560-6927bac5-fac1-48a2-9a77-3a26b1e01671.png\" alt=\"7.png\"></p>\n<p><a name=\"abf577cd\"></a></p>\n<h6 id=\"当Thread-0释放锁，则进入tryRelease方法：\"><a href=\"#当Thread-0释放锁，则进入tryRelease方法：\" class=\"headerlink\" title=\"当Thread-0释放锁，则进入tryRelease方法：\"></a>当Thread-0释放锁，则进入tryRelease方法：</h6><pre><code>1.设置exclusiveOwnerThread为null--表示当前没有线程持有锁\n\n2.设置state为0\n</code></pre>\n<p><img src=\"/../assets/1647332653201-ad3da733-6974-4926-bcce-5451fffde0bc.png\" alt=\"8.png\"></p>\n<p>等待队列不为null，并且前驱节点的waitStatus &#x3D; -1，则进入unparkSuccessor方法</p>\n<p>找到队列中距离head最近的一个Node，unpark让其恢复运行，本例中为Thread-1</p>\n<p>回到Thread-1的acquireQueued方法</p>\n<p><img src=\"/../assets/1647332657453-f5d82edc-1063-4ad5-891b-1e6f422ae347.png\" alt=\"9.png\"></p>\n<p><a name=\"5fc80be8\"></a></p>\n<h6 id=\"若加锁成功（没有竞争），则：\"><a href=\"#若加锁成功（没有竞争），则：\" class=\"headerlink\" title=\"若加锁成功（没有竞争），则：\"></a>若加锁成功（没有竞争），则：</h6><pre><code>exclusiveOwnerThread为Thread-1，state值为1\n\nhead指向刚刚Thread-1所在的Node，并将Thread-1刚刚所在的Node清空Thread(不关联线程)\n\n原本的前驱节点从链表中断开，被垃圾回收\n</code></pre>\n<p><a name=\"5e7784be\"></a></p>\n<h6 id=\"如果此时有新的线程来进行竞争-非公平的体现\"><a href=\"#如果此时有新的线程来进行竞争-非公平的体现\" class=\"headerlink\" title=\"如果此时有新的线程来进行竞争**(非公平的体现)**\"></a>如果此时有新的线程来进行竞争**(非公平的体现)**</h6><p><img src=\"/../assets/1647332665782-3ed8a036-ce5e-4211-a4a5-a7194deaed42.png\" alt=\"10.png\"></p>\n<p>则可能又被Thread-4占据锁资源</p>\n<pre><code>Thread-4被设置为exclusiveOwnerThread，state = 1\n\nThread-1再次进入acquireQueued方法，若尝试获取锁失败，则进入等待队列被park\n</code></pre>\n<hr>\n<p><a name=\"9e0c19cc\"></a></p>\n<h5 id=\"2-可重入原理：\"><a href=\"#2-可重入原理：\" class=\"headerlink\" title=\"2.可重入原理：\"></a>2.可重入原理：</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">static</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">NonfairSync</span> <span class=\"token keyword\">extends</span> <span class=\"token class-name\">Sync</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// ...</span>\n    <span class=\"token comment\">// Sync 继承过来的方法, 方便阅读, 放在此处</span>\n    <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">nonfairTryAcquire</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> acquires<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token keyword\">final</span> <span class=\"token class-name\">Thread</span> current <span class=\"token operator\">=</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compareAndSetState</span><span class=\"token punctuation\">(</span><span class=\"token number\">0</span><span class=\"token punctuation\">,</span> acquires<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n                <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n                <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token comment\">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span>\n        <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>current <span class=\"token operator\">==</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token comment\">// state++</span>\n            <span class=\"token keyword\">int</span> nextc <span class=\"token operator\">=</span> c <span class=\"token operator\">+</span> acquires<span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextc <span class=\"token operator\">&lt;</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// overflow</span>\n                <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Error</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"Maximum lock count exceeded\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>nextc<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n\n    <span class=\"token comment\">// Sync 继承过来的方法, 方便阅读, 放在此处</span>\n    <span class=\"token keyword\">protected</span> <span class=\"token keyword\">final</span> <span class=\"token keyword\">boolean</span> <span class=\"token function\">tryRelease</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> releases<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// state--</span>\n        <span class=\"token keyword\">int</span> c <span class=\"token operator\">=</span> <span class=\"token function\">getState</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> releases<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token class-name\">Thread</span><span class=\"token punctuation\">.</span><span class=\"token function\">currentThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">!=</span> <span class=\"token function\">getExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n            <span class=\"token keyword\">throw</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IllegalMonitorStateException</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">boolean</span> free <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 支持锁重入, 只有 state 减为 0, 才释放成功</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>c <span class=\"token operator\">==</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            free <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">setExclusiveOwnerThread</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n        <span class=\"token function\">setState</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> free<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"8c9d507e\"></a></p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>当再次分配到资源时，因为自己之前就已经拿到了锁，则会让state自增，当解锁时让state自减</p>\n<hr>\n<p><a name=\"30764858\"></a></p>\n<h5 id=\"3-可打断原理\"><a href=\"#3-可打断原理\" class=\"headerlink\" title=\"3.可打断原理\"></a>3.可打断原理</h5><p><a name=\"86af4623\"></a></p>\n<h6 id=\"①-不可打断模式：\"><a href=\"#①-不可打断模式：\" class=\"headerlink\" title=\"① 不可打断模式：\"></a>① 不可打断模式：</h6><p>在此模式下，即使被其他线程打断(interrupt方法)，仍会驻留在AQS队列中，等待获取到锁之后才能继续运行(是继续运行，只是将打断标记设置为true)</p>\n<p><a name=\"11b07786\"></a></p>\n<h6 id=\"②-可打断模式：\"><a href=\"#②-可打断模式：\" class=\"headerlink\" title=\"② 可打断模式：\"></a>② 可打断模式：</h6><p>当被其他线程调用interrupt方式时抛出异常</p>\n<hr>\n<p><a name=\"ed5c11bc\"></a></p>\n<h5 id=\"4-公平锁实现原理：\"><a href=\"#4-公平锁实现原理：\" class=\"headerlink\" title=\"4.公平锁实现原理：\"></a>4.公平锁实现原理：</h5><p>与非公平锁的区别就是，调用公平锁的方法会先判断AQS等待队列中是否前驱节点，没有等待的线程才会去调用cas方法竞争锁</p>\n<hr>\n<p><a name=\"237a54cc\"></a></p>\n<h5 id=\"5-条件变量的实现原理：\"><a href=\"#5-条件变量的实现原理：\" class=\"headerlink\" title=\"5.条件变量的实现原理：\"></a>5.条件变量的实现原理：</h5><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p>\n<p><a name=\"fcdbefb8\"></a></p>\n<h5 id=\"await流程：\"><a href=\"#await流程：\" class=\"headerlink\" title=\"await流程：\"></a>await流程：</h5><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 方法</p>\n<p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p>\n<p><img src=\"/../assets/1647332791000-c80394eb-b9bc-4650-9df8-23e8eeba1e85.png\" alt=\"1.png\"></p>\n<p>接下来进入 AQS 的 fullyRelease 方法，释放同步器上的锁</p>\n<p><img src=\"/../assets/1647332794692-e2dc33f5-5f86-4051-921a-9c49e926c667.png\" alt=\"2.png\"></p>\n<p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p>\n<p><img src=\"/../assets/1647332798003-4f403d49-908b-44db-880b-8174f882ff23.png\" alt=\"3.png\"></p>\n<p>park 阻塞 Thread-0</p>\n<p><img src=\"/../assets/1647332803111-2b720146-deb1-426a-99c6-0ed4cfe8d95e.png\" alt=\"4.png\"></p>\n<hr>\n<p><a name=\"b25fca64\"></a></p>\n<h5 id=\"signal流程：\"><a href=\"#signal流程：\" class=\"headerlink\" title=\"signal流程：\"></a>signal流程：</h5><p>假设 Thread-1 要来唤醒 Thread-0</p>\n<p><img src=\"/../assets/1647332806759-bd5cd5e5-8da5-4a3d-98ef-8d02c12f3586.png\" alt=\"5.png\"></p>\n<p>进入 ConditionObject 的 doSignal 方法，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p>\n<p><img src=\"/../assets/1647332810916-cb3bca89-d812-4b30-a8a7-ea0399c6350b.png\" alt=\"6.png\"></p>\n<p>执行 transferForSignal 方法，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的<br />waitStatus 改为 -1</p>\n<p><img src=\"/../assets/1647332816514-52f96c92-902b-40e2-8167-9cfcfe000544.png\" alt=\"7.png\"></p>\n<p>Thread-1 释放锁，进入 unlock 方法</p>\n","text":" ReentrantLock原理： 1.非公平锁的实现原理： 加锁解锁流程：先从构造器来看，默认为非公平锁实现 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; NonfairSync 继承自 AQS 没...","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ReentrantLock%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">ReentrantLock原理：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">1.非公平锁的实现原理：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8A%A0%E9%94%81%E8%A7%A3%E9%94%81%E6%B5%81%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">加锁解锁流程：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E6%B2%A1%E6%9C%89%E7%AB%9E%E4%BA%89%E6%97%B6%EF%BC%9A\"><span class=\"toc-text\">没有竞争时：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AB%9E%E4%BA%89%E5%87%BA%E7%8E%B0%E6%97%B6%EF%BC%88state%E8%A1%A8%E7%A4%BA%E6%98%AF%E5%90%A6%E8%A2%AB%E5%8A%A0%E9%94%81%EF%BC%89\"><span class=\"toc-text\">第一个竞争出现时（state表示是否被加锁）</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#Thread-1-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Thread-1 执行流程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E8%BF%9B%E5%85%A5acquireQueued%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">当前线程进入acquireQueued方法</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%86%8D%E6%AC%A1%E6%9C%89%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%8F%E5%8E%86%E4%B8%8A%E8%BF%B0%E8%BF%87%E7%A8%8B%E7%AB%9E%E4%BA%89%E5%A4%B1%E8%B4%A5%EF%BC%8C%E5%8F%98%E6%88%90%E8%BF%99%E4%B8%AA%E6%A0%B7%E5%AD%90\"><span class=\"toc-text\">再次有多个线程经历上述过程竞争失败，变成这个样子</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%BD%93Thread-0%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%8C%E5%88%99%E8%BF%9B%E5%85%A5tryRelease%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">当Thread-0释放锁，则进入tryRelease方法：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E8%8B%A5%E5%8A%A0%E9%94%81%E6%88%90%E5%8A%9F%EF%BC%88%E6%B2%A1%E6%9C%89%E7%AB%9E%E4%BA%89%EF%BC%89%EF%BC%8C%E5%88%99%EF%BC%9A\"><span class=\"toc-text\">若加锁成功（没有竞争），则：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E5%A6%82%E6%9E%9C%E6%AD%A4%E6%97%B6%E6%9C%89%E6%96%B0%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9D%A5%E8%BF%9B%E8%A1%8C%E7%AB%9E%E4%BA%89-%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84%E4%BD%93%E7%8E%B0\"><span class=\"toc-text\">如果此时有新的线程来进行竞争**(非公平的体现)**</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">2.可重入原理：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E5%8F%AF%E6%89%93%E6%96%AD%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">3.可打断原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E2%91%A0-%E4%B8%8D%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">① 不可打断模式：</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E2%91%A1-%E5%8F%AF%E6%89%93%E6%96%AD%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">② 可打断模式：</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%85%AC%E5%B9%B3%E9%94%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">4.公平锁实现原理：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9A\"><span class=\"toc-text\">5.条件变量的实现原理：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#await%E6%B5%81%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">await流程：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#signal%E6%B5%81%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">signal流程：</span></a></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"wait/notify，join，park/Unpark","uid":"489d7b6b150f5087fe22abf19dc56ce1","slug":"waitnotify，join，parkUnpark","date":"2022-06-11T13:10:26.016Z","updated":"2022-06-11T13:11:09.285Z","comments":true,"path":"api/articles/waitnotify，join，parkUnpark.json","keywords":null,"cover":[],"text":"wait&#x2F;notify，join，park&#x2F;Unparkwait&#x2F;notify的原理： 1.Owner发现线程条件不满足，调用wait方法，即可进入WaitSet变为WAITING状态 2.BLOCKED和WAITING的线程都处于阻塞状态，不占用C...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"synchronized关键字","uid":"e1b3118af0455ea0158a80d4d6b7a3a6","slug":"synchronized关键字","date":"2022-06-11T12:58:01.936Z","updated":"2022-06-11T12:58:35.833Z","comments":true,"path":"api/articles/synchronized关键字.json","keywords":null,"cover":[],"text":" synchronized 解决方案 互斥为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":11,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
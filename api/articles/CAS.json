{"title":"CAS","uid":"779600de7239585350eddc687c9afdbb","slug":"CAS","date":"2022-06-11T13:20:41.435Z","updated":"2022-06-11T13:21:17.762Z","comments":true,"path":"api/articles/CAS.json","keywords":null,"cover":null,"content":"<h4 id=\"CAS与volatile\"><a href=\"#CAS与volatile\" class=\"headerlink\" title=\"CAS与volatile\"></a>CAS与volatile</h4><p>CAS — compareAndSet()，内部实现了原子性（）</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">withdraw</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Integer</span> amount<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 需要不断尝试，直到成功为止</span>\n    <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span><span class=\"token boolean\">true</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n        <span class=\"token comment\">// 比如拿到了旧值 1000</span>\n        <span class=\"token keyword\">int</span> prev <span class=\"token operator\">=</span> balance<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token comment\">// 在这个基础上 1000-10 = 990</span>\n        <span class=\"token keyword\">int</span> next <span class=\"token operator\">=</span> prev <span class=\"token operator\">-</span> amount<span class=\"token punctuation\">;</span>\n         <span class=\"token comment\">/*\n         compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值\n         - 不一致了，next 作废，返回 false 表示失败\n         比如，别的线程已经做了减法，当前值已经被减成了 990\n         那么本线程的这次 990 就作废了，进入 while 下次循环重试\n         - 一致，以 next 设置为新值，返回 true 表示成功\n         */</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>balance<span class=\"token punctuation\">.</span><span class=\"token function\">compareAndSet</span><span class=\"token punctuation\">(</span>prev<span class=\"token punctuation\">,</span> next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n            <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">&#125;</span>\n    <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交</p>\n<p>换】的原子性。</p>\n<p>在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再</p>\n<p>开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子的。</p>\n<hr>\n<p>volatile</p>\n<p>获取共享变量时，为了保证变量的可见性，需要使用volatile修饰</p>\n<p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作volatile变量都是直接操作主存，即一个线程对volatile变量的修改，对另一个线程可见</p>\n<p>CAS必须借助volatile才能读取到共享变量的最新值来实现【比较并交换】的效果</p>\n<hr>\n<p><a name=\"297edac8\"></a></p>\n<h5 id=\"为什么无锁效率高\"><a href=\"#为什么无锁效率高\" class=\"headerlink\" title=\"为什么无锁效率高:\"></a>为什么无锁效率高:</h5><p>无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时候，</p>\n<p>发生上下文切换，进入阻塞。</p>\n<p>但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑</p>\n<p>道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还</p>\n<p>是会导致上下文切换。</p>\n<hr>\n<p><a name=\"0a1e6679\"></a></p>\n<h5 id=\"CAS的特点：\"><a href=\"#CAS的特点：\" class=\"headerlink\" title=\"CAS的特点：\"></a>CAS的特点：</h5><p>结合CAS和volatile可以实现无锁并发，适用于线程少，多核CPU的场景下</p>\n<p>CAS是基于乐观锁的思想</p>\n<p>synchronized是基于悲观锁的思想</p>\n<p>CAS体现的是无锁并发、无阻塞并发</p>\n<pre><code>因为没有使用synchronized，所以线程不会进入阻塞，这是效率提升的因素之一\n\n但如果竞争激烈，重试必然会频繁发生，反而效率会受到影响\n</code></pre>\n","text":"CAS与volatileCAS — compareAndSet()，内部实现了原子性（） public void withdraw(Integer amount) &#123; // 需要不断尝试，直到成功为止 while (true) &#123; // 比如拿到了旧值 100...","link":"","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":10,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CAS%E4%B8%8Evolatile\"><span class=\"toc-text\">CAS与volatile</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%A0%E9%94%81%E6%95%88%E7%8E%87%E9%AB%98\"><span class=\"toc-text\">为什么无锁效率高:</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#CAS%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">CAS的特点：</span></a></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"并查集","uid":"c18469ab20e7b093d36b4a61728d07eb","slug":"并查集","date":"2022-06-11T13:26:26.256Z","updated":"2022-06-11T13:28:31.701Z","comments":true,"path":"api/articles/并查集.json","keywords":null,"cover":[],"text":" class Solution &#123; public double[] calcEquation(List&lt;List&lt;String>> equations, double[] values, List&lt;List&lt;String>> queries) &...","link":"","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":8,"path":"api/categories/数据结构.json"}],"tags":[{"name":"数据结构","slug":"数据结构","count":8,"path":"api/tags/数据结构.json"},{"name":"算法","slug":"算法","count":8,"path":"api/tags/算法.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"java内存模型(JMM)","uid":"8719a59ea15091ad0c2facf954842244","slug":"java内存模型(JMM)","date":"2022-06-11T13:15:23.102Z","updated":"2022-06-11T13:21:17.770Z","comments":true,"path":"api/articles/java内存模型(JMM).json","keywords":null,"cover":[],"text":"java内存模型(JMM)java内存模型：JMM即java Memory Model，它定义了内存、工作内存抽象概念、底层对CPU寄存器、缓存、硬件内存、CPU指令优化等 JMM体现在以下几个方面：​ 1.原子性：保证指令不会受到线程上下文切换的影响 ​ 2.可见性：保证指令不...","link":"","photos":[],"count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":10,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
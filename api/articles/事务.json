{"title":"MySQL事务","uid":"c1f6d722cc4602038235f2e7924e8ff2","slug":"事务","date":"2022-06-11T12:25:00.191Z","updated":"2022-06-11T12:25:34.870Z","comments":true,"path":"api/articles/事务.json","keywords":null,"cover":[],"content":"<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><p><a name=\"7a3b28c3\"></a></p>\n<h4 id=\"事务的基础知识：\"><a href=\"#事务的基础知识：\" class=\"headerlink\" title=\"事务的基础知识：\"></a>事务的基础知识：</h4><p>在MySQL中只有InnoDB存储引擎支持事务</p>\n<p><a name=\"e5e00f51\"></a></p>\n<h4 id=\"1-数据库事务的概述：\"><a href=\"#1-数据库事务的概述：\" class=\"headerlink\" title=\"1.数据库事务的概述：\"></a>1.数据库事务的概述：</h4><pre><code>事务是数据库区别于文件系统的重要特征之一，当我们有了事务就会让数据库始终保持一致性，同时我们还可以通过事务的机制恢复到某个时间点\n</code></pre>\n<p><a name=\"5117e5be\"></a></p>\n<h5 id=\"基本概念：\"><a href=\"#基本概念：\" class=\"headerlink\" title=\"基本概念：\"></a>基本概念：</h5><p>事务：是一组逻辑单元，使数据从一种状态转换到另一种状态</p>\n<p>事务处理原则：保证所有事务作为一个工作单元来执行，即使出现了故障都不能改变这种执行方式，一个事务中执行多个操作，要么都被提交，要么全部放弃，回滚到最初的状态</p>\n<p>如：转账操作就是一个事务，不能让钱的总额改变</p>\n<p><a name=\"108aacf8\"></a></p>\n<h4 id=\"事务的ACID特征：\"><a href=\"#事务的ACID特征：\" class=\"headerlink\" title=\"事务的ACID特征：\"></a>事务的ACID特征：</h4><p><a name=\"abbdc0dd\"></a></p>\n<h5 id=\"1-原子性\"><a href=\"#1-原子性\" class=\"headerlink\" title=\"1.原子性\"></a>1.原子性</h5><pre><code>原子性指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚\n</code></pre>\n<p><a name=\"ab59f449\"></a></p>\n<h5 id=\"2-一致性\"><a href=\"#2-一致性\" class=\"headerlink\" title=\"2.一致性\"></a>2.一致性</h5><pre><code>一致性是指事务在执行前后，数据从一个合法性状态，变换到另一个合法性的状态（满足实际规定）\n\n例如：A有100元，去取钱不能多余100元（因为规定钱不能为负数）\n\n            A给B转账，要保证A和B的余额总数转账前后相同\n</code></pre>\n<p><a name=\"64736181\"></a></p>\n<h5 id=\"3-隔离性\"><a href=\"#3-隔离性\" class=\"headerlink\" title=\"3.隔离性\"></a>3.隔离性</h5><pre><code>指一个事务的执行不能被其他事务干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的过程中各个事务之间不能互相干扰\n</code></pre>\n<p><a name=\"f0083522\"></a></p>\n<h5 id=\"4-持久性\"><a href=\"#4-持久性\" class=\"headerlink\" title=\"4.持久性\"></a>4.持久性</h5><pre><code>一旦事务进行了提交，则对数据的改变是永久性的，不会被接下来的其他操作影响\n</code></pre>\n<p>持久性是通过事务日志来保证的，日志包括了重做日志和回滚日志，当我们通过事务对数据进行修改的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改，这样的好处是，即使数据库宕机，数据库重启后也能找到没有更新到数据库中的重做日志，重新执行，从而使事务具有持久性</p>\n<p><a name=\"8c9d507e\"></a></p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><p>ACID是事务的四大特征，原子性是基础，隔离性是手段，一致性是约束条件，而持久性是我们的目的</p>\n<p>数据库事务其实就是数据库操作者为了方便，把需要保证原子性，隔离性，一致性，持久性的一个或多个数据库操作成为一个事务</p>\n<p><a name=\"bd17d807\"></a></p>\n<h4 id=\"事务的状态\"><a href=\"#事务的状态\" class=\"headerlink\" title=\"事务的状态\"></a>事务的状态</h4><p>活动的：事务对应的数据库操作正在执行中</p>\n<p>部分提交：事务操作执行完成，还未刷盘将数据保存到磁盘</p>\n<p>失败的：事务处于活动或部分提交状态时，遇到了一些错误导致事务停止执行</p>\n<p>中止的：当事务一部分变为失败的状态，回滚到之前的状态，回滚完毕后成为事务中止的</p>\n<p>提交的：一个处于部分提交的状态通过修改过的数据同步到磁盘上</p>\n<hr>\n<p><a name=\"a45dbcb3\"></a></p>\n<h4 id=\"如何使用事务？\"><a href=\"#如何使用事务？\" class=\"headerlink\" title=\"如何使用事务？\"></a>如何使用事务？</h4><p><a name=\"a0c06a5e\"></a></p>\n<h5 id=\"事务的完整过程：\"><a href=\"#事务的完整过程：\" class=\"headerlink\" title=\"事务的完整过程：\"></a>事务的完整过程：</h5><p>1.开启事务</p>\n<p>2.一系列的DML操作</p>\n<p>3.事务的状态：（事务结束）</p>\n<pre><code>    提交：COMMIT\n\n    中止：ROLLBACK\n</code></pre>\n<p><a name=\"18e6eb79\"></a></p>\n<h5 id=\"1-显式事务\"><a href=\"#1-显式事务\" class=\"headerlink\" title=\"1.显式事务\"></a>1.显式事务</h5><pre><code>使用关键字开启事务（两种方式）\n\n    start transaction （使用该方式可以设置是否只读？可以读写（默认read write）？一致性读？）\n\n    begin\n\n保存点（savepoint）可以控制回滚到保存点而不是回滚到最初状态\n</code></pre>\n<p><a name=\"317cc4b4\"></a></p>\n<h5 id=\"2-隐式事务\"><a href=\"#2-隐式事务\" class=\"headerlink\" title=\"2.隐式事务\"></a>2.隐式事务</h5><p>关键字：autocommit（自动提交）</p>\n<p>默认开启自动提交的状态下，我们的每一个DML操作都是一个隐式事务，会自动提交</p>\n<p>如果我们显式的开启了事务，那么DML操作就不会自动提交数据</p>\n<p><a name=\"499dadd2\"></a></p>\n<h5 id=\"隐式提交数据的情况：\"><a href=\"#隐式提交数据的情况：\" class=\"headerlink\" title=\"隐式提交数据的情况：\"></a>隐式提交数据的情况：</h5><p>1.数据定义语言（DDL）CREATE、ALTER、DROP等操作</p>\n<p>2.使用或修改MySQL数据库中的表，如：ALTER USER、CREATE USER等</p>\n<p>3.事务控制或关于锁定的语句</p>\n<pre><code>当一个事务还没进行提交或回滚操作时，又显式的开启了一个事务，那么会隐式提交上一个事务\n\n当前的autocommit系统变量的值为OFF，手动变为ON会隐式提交前面语句的事务\n\n使用LOCK TABLES等关于锁定语句也会隐式提交前面语句所属的事务\n</code></pre>\n<p>4.加载数据的语句</p>\n<pre><code>使用LOAD DATA语句来批量向数据库中导入数据时，也会隐式的提交前面语句所属的事务\n</code></pre>\n<p>5.关于MySQL复制的一些语句</p>\n<pre><code>使用START SLAVE、STOP SLAVE、RESET SLAVE等语句也会隐式的提交前面语句所属的事务\n</code></pre>\n<p>6.一些其他语句</p>\n<pre><code>使用ANALYZE TABLE（分析表） 检查表，优化表等操作也会隐式的提交前面语句所属的事务\n</code></pre>\n<hr>\n<p><a name=\"06f80776\"></a></p>\n<h4 id=\"数据并发问题：\"><a href=\"#数据并发问题：\" class=\"headerlink\" title=\"数据并发问题：\"></a>数据并发问题：</h4><p><a name=\"ca7ff7c1\"></a></p>\n<h5 id=\"1-脏写\"><a href=\"#1-脏写\" class=\"headerlink\" title=\"1.脏写\"></a>1.脏写</h5><pre><code>对于两个事务A，B，如果事务A修改了另一个事务B修改过的数据，那就说明发生了脏写\n</code></pre>\n<p><a name=\"76c25e89\"></a></p>\n<h5 id=\"2-脏读\"><a href=\"#2-脏读\" class=\"headerlink\" title=\"2.脏读\"></a>2.脏读</h5><pre><code>事务A读取了已经被事务B更新但还未提交的数据，如果事务B进行回滚，那么A读取的内容就是临时且无效的\n</code></pre>\n<p><a name=\"d4a47ac9\"></a></p>\n<h5 id=\"3-不可重复读\"><a href=\"#3-不可重复读\" class=\"headerlink\" title=\"3.不可重复读\"></a>3.不可重复读</h5><pre><code>事务A读取了一个字段，然后事务B更新了该字段，之后事务A再次进行读取，发现数据改变了\n</code></pre>\n<p><a name=\"61df47f0\"></a></p>\n<h5 id=\"4-幻读\"><a href=\"#4-幻读\" class=\"headerlink\" title=\"4.幻读\"></a>4.幻读</h5><pre><code>事务A从一个表中读取了一个字段，然后事务B在该表中插入了一些新的行，之后事务A再次读取同一个表，就会多出几行\n</code></pre>\n<p><a name=\"41fd275d\"></a></p>\n<h4 id=\"事务的隔离级别：（隔离级别越高，并发性越差）\"><a href=\"#事务的隔离级别：（隔离级别越高，并发性越差）\" class=\"headerlink\" title=\"事务的隔离级别：（隔离级别越高，并发性越差）\"></a>事务的隔离级别：（隔离级别越高，并发性越差）</h4><p>1.读未提交：解决脏写</p>\n<p>2.读已提交：解决脏读、脏写</p>\n<p>3.可重复读：解决脏写，脏读，不可重复读 （MySQL默认）</p>\n<p>4.可串行化：均解决</p>\n<p><a name=\"8fed12c0\"></a></p>\n<h4 id=\"事务日志：\"><a href=\"#事务日志：\" class=\"headerlink\" title=\"事务日志：\"></a>事务日志：</h4><p>事务的隔离性是由锁机制实现</p>\n<p>而事务的原子性，一致性，持久性由事务的redo日志undo日志来保证</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">REDO LOG 重做日志，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性\n\nUNDO LOG  回滚日志，回滚行记录到某个特定版本，用来保证事务的原子性和一直性<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><img src=\"/../assets/1647330760226-ecbc2786-eebc-472d-ba34-67bca5cfe996.png\" alt=\"1646546763678.png\"></p>\n<p><a name=\"8746eb75\"></a></p>\n<h5 id=\"REDO日志的优点和特点：\"><a href=\"#REDO日志的优点和特点：\" class=\"headerlink\" title=\"REDO日志的优点和特点：\"></a>REDO日志的优点和特点：</h5><p>优点：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">1.redo日志降低了刷盘频率\n\n2.redo日志占用的空间非常小<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>特点：</p>\n<p><a name=\"bfd08834\"></a></p>\n<h5 id=\"redo日志是顺序写入磁盘的\"><a href=\"#redo日志是顺序写入磁盘的\" class=\"headerlink\" title=\"redo日志是顺序写入磁盘的\"></a>redo日志是顺序写入磁盘的</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">在执行事务的过程中，每执行一条语句，就可能产生若干条redo日志，这些日志是按照产生的顺序写入磁盘的，也就是使用顺序IO，效率比随机IO快<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"4c23280b\"></a></p>\n<h5 id=\"事务执行过程中，redo-log-不断记录\"><a href=\"#事务执行过程中，redo-log-不断记录\" class=\"headerlink\" title=\"事务执行过程中，redo log 不断记录\"></a>事务执行过程中，redo log 不断记录</h5><p>redo log是存储引擎层产生的，而bin log是数据库层产生的，在一个事务执行过程中，一直不断的向redo log顺序记录，而bin log直到事务提交才会一次性写入bin log文件中</p>\n<hr>\n<p><a name=\"0938c8cb\"></a></p>\n<h5 id=\"UNDO日志\"><a href=\"#UNDO日志\" class=\"headerlink\" title=\"UNDO日志\"></a>UNDO日志</h5><p>undo log 的产生也会伴随着redo log的产生，因为undo log也需要持久性的保护</p>\n<p><a name=\"8076e5d8\"></a></p>\n<h5 id=\"作用：\"><a href=\"#作用：\" class=\"headerlink\" title=\"作用：\"></a>作用：</h5><p>1.回滚数据</p>\n<p>2.MVCC</p>\n","text":"事务 事务的基础知识：在MySQL中只有InnoDB存储引擎支持事务 1.数据库事务的概述：事务是数据库区别于文件系统的重要特征之一，当我们有了事务就会让数据库始终保持一致性，同时我们还可以通过事务的机制恢复到某个时间点 基本概念：事务：是一组逻辑单元，使数据从一种状态转换到另一...","link":"","photos":[],"count_time":{"symbolsCount":"2.5k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"},{"name":"事务","slug":"事务","count":1,"path":"api/tags/事务.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">事务</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A\"><span class=\"toc-text\">事务的基础知识：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E6%A6%82%E8%BF%B0%EF%BC%9A\"><span class=\"toc-text\">1.数据库事务的概述：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A\"><span class=\"toc-text\">基本概念：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E5%BE%81%EF%BC%9A\"><span class=\"toc-text\">事务的ACID特征：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E5%8E%9F%E5%AD%90%E6%80%A7\"><span class=\"toc-text\">1.原子性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%B8%80%E8%87%B4%E6%80%A7\"><span class=\"toc-text\">2.一致性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E9%9A%94%E7%A6%BB%E6%80%A7\"><span class=\"toc-text\">3.隔离性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E6%8C%81%E4%B9%85%E6%80%A7\"><span class=\"toc-text\">4.持久性</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">事务的状态</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E4%BA%8B%E5%8A%A1%EF%BC%9F\"><span class=\"toc-text\">如何使用事务？</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%8C%E6%95%B4%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">事务的完整过程：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E6%98%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">1.显式事务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E9%9A%90%E5%BC%8F%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">2.隐式事务</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%9A%90%E5%BC%8F%E6%8F%90%E4%BA%A4%E6%95%B0%E6%8D%AE%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9A\"><span class=\"toc-text\">隐式提交数据的情况：</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98%EF%BC%9A\"><span class=\"toc-text\">数据并发问题：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-%E8%84%8F%E5%86%99\"><span class=\"toc-text\">1.脏写</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E8%84%8F%E8%AF%BB\"><span class=\"toc-text\">2.脏读</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB\"><span class=\"toc-text\">3.不可重复读</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-%E5%B9%BB%E8%AF%BB\"><span class=\"toc-text\">4.幻读</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%EF%BC%9A%EF%BC%88%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E8%B6%8A%E9%AB%98%EF%BC%8C%E5%B9%B6%E5%8F%91%E6%80%A7%E8%B6%8A%E5%B7%AE%EF%BC%89\"><span class=\"toc-text\">事务的隔离级别：（隔离级别越高，并发性越差）</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E6%97%A5%E5%BF%97%EF%BC%9A\"><span class=\"toc-text\">事务日志：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#REDO%E6%97%A5%E5%BF%97%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E7%89%B9%E7%82%B9%EF%BC%9A\"><span class=\"toc-text\">REDO日志的优点和特点：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#redo%E6%97%A5%E5%BF%97%E6%98%AF%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5%E7%A3%81%E7%9B%98%E7%9A%84\"><span class=\"toc-text\">redo日志是顺序写入磁盘的</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8Credo-log-%E4%B8%8D%E6%96%AD%E8%AE%B0%E5%BD%95\"><span class=\"toc-text\">事务执行过程中，redo log 不断记录</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#UNDO%E6%97%A5%E5%BF%97\"><span class=\"toc-text\">UNDO日志</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%BD%9C%E7%94%A8%EF%BC%9A\"><span class=\"toc-text\">作用：</span></a></li></ol></li></ol></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"进程线程并行并发","uid":"6ce63568dd0197dd5234fafddc6d369d","slug":"进程线程并行并发","date":"2022-06-11T12:36:30.645Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/进程线程并行并发.json","keywords":null,"cover":null,"text":" 进程和线程： 进程：资源分配的最小单位程序由指令和数据组成，但这些指令需要运行，数据要读写，就必须将指令加载到CPU，数据加载至内存。在指令运行过程种还须需要用到磁盘，网络等设备。进程就是用来加载指令，管理内存，管理IO的 当一个程序被运行，从磁盘加载这个程序的代码到内存种，这...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"JUC","slug":"JUC","count":6,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":6,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":6,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"MySQL中的锁","uid":"55817b11714364db5e90bcd7c8c20421","slug":"MySQL中的锁","date":"2022-06-11T12:23:16.177Z","updated":"2022-06-11T12:24:00.496Z","comments":true,"path":"api/articles/MySQL中的锁.json","keywords":null,"cover":[],"text":" MySQL中的锁在数据库中，除传统的计算资源（如CPU、RAM、I&#x2F;O等）的争用以外，数据也是一种供许多用户共享的资源。为保证数据的一致性，需要对 并发操作进行控制 ，因此产生了 锁 。同时 锁机制 也为实现MySQL的各个隔离级别提供了保证。 锁冲突也是影响数据库并...","link":"","photos":[],"count_time":{"symbolsCount":"4.7k","symbolsTime":"4 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":6,"path":"api/tags/MySQL.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}
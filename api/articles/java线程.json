{"title":"java线程","uid":"dffb2abec4fa02f1174c155cbd8d7f1a","slug":"java线程","date":"2022-06-11T12:49:10.748Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/java线程.json","keywords":null,"cover":[],"content":"<h1 id=\"java线程\"><a href=\"#java线程\" class=\"headerlink\" title=\"java线程\"></a>java线程</h1><p><a name=\"9525811a\"></a></p>\n<h2 id=\"创建和启动线程\"><a href=\"#创建和启动线程\" class=\"headerlink\" title=\"创建和启动线程\"></a>创建和启动线程</h2><h5 id=\"1-new-Thread：\"><a href=\"#1-new-Thread：\" class=\"headerlink\" title=\"1.new Thread：\"></a>1.new Thread：</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">test1</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n           <span class=\"token comment\">//执行的方法</span>\n           <span class=\"token annotation punctuation\">@Override</span>\n           <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n               log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"running\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n           <span class=\"token punctuation\">&#125;</span>\n       <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//命名线程</span>\n       t<span class=\"token punctuation\">.</span><span class=\"token function\">setName</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"t1\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token comment\">//启动线程</span>\n       t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"bc710a52\"></a></p>\n<h5 id=\"2-使用Runnable配合Thread（将需要执行的任务与创建线程分离，更灵活）\"><a href=\"#2-使用Runnable配合Thread（将需要执行的任务与创建线程分离，更灵活）\" class=\"headerlink\" title=\"2.使用Runnable配合Thread（将需要执行的任务与创建线程分离，更灵活）\"></a>2.使用Runnable配合Thread（将需要执行的任务与创建线程分离，更灵活）</h5><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n   <span class=\"token class-name\">Runnable</span> r <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Runnable</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n       <span class=\"token annotation punctuation\">@Override</span>\n       <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n          log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"running\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n       <span class=\"token punctuation\">&#125;</span>\n   <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">;</span>\n    <span class=\"token class-name\">Thread</span> t <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">,</span> <span class=\"token string\">\"t2\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    t<span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"22de69cf\"></a></p>\n<h4 id=\"原理：Thread和Runnable的关系\"><a href=\"#原理：Thread和Runnable的关系\" class=\"headerlink\" title=\"原理：Thread和Runnable的关系\"></a>原理：Thread和Runnable的关系</h4><p>方法一：实际上是手动重写了run方法，就会执行子类的run方法</p>\n<p>方法二：在构造器中传入一个Runnable实例，内部在初始化方法将runnable实例赋值给了Thread中的一个成员变量。Thread类中的Run方法会判断runnable对象是否为null，不为null就运行Thread的run方法</p>\n<p><a name=\"8c9d507e\"></a></p>\n<h5 id=\"总结：\"><a href=\"#总结：\" class=\"headerlink\" title=\"总结：\"></a>总结：</h5><pre><code>方法一就是把线程和任务合并，方法二就是把线程和任务分开了\n\n用Runnable更容易与线程池等高级API配合\n\n用Runnable让任务脱离了Thread继承体系，更灵活\n</code></pre>\n<p><a name=\"0ecdadae\"></a></p>\n<h5 id=\"3-FutureTask-配合-Thread\"><a href=\"#3-FutureTask-配合-Thread\" class=\"headerlink\" title=\"3.FutureTask 配合 Thread\"></a>3.FutureTask 配合 Thread</h5><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token keyword\">throws</span> <span class=\"token class-name\">Exception</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token comment\">// 创建任务对象</span>\n    <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">Integer</span><span class=\"token punctuation\">></span></span> task3 <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">FutureTask</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">&#123;</span>\n        log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">return</span> <span class=\"token number\">100</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">&#125;</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 参数1 是任务对象; 参数2 是线程名字，推荐</span>\n    <span class=\"token keyword\">new</span> <span class=\"token class-name\">Thread</span><span class=\"token punctuation\">(</span>task3<span class=\"token punctuation\">,</span> <span class=\"token string\">\"t3\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">start</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// 主线程阻塞，同步等待 task 执行完毕的结果</span>\n    <span class=\"token class-name\">Integer</span> result <span class=\"token operator\">=</span> task3<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    log<span class=\"token punctuation\">.</span><span class=\"token function\">debug</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"结果是:&#123;&#125;\"</span><span class=\"token punctuation\">,</span> result<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"96e2a861\"></a></p>\n<h2 id=\"查看进程线程的方法\"><a href=\"#查看进程线程的方法\" class=\"headerlink\" title=\"查看进程线程的方法\"></a>查看进程线程的方法</h2><p><a name=\"windows\"></a></p>\n<h5 id=\"windows\"><a href=\"#windows\" class=\"headerlink\" title=\"windows\"></a>windows</h5><p>任务管理器可以查看进程和线程数，也可以用来杀死进程<br /><br>tasklist 查看进程<br /><br>taskkill 杀死进程</p>\n<p><a name=\"linux\"></a></p>\n<h5 id=\"linux\"><a href=\"#linux\" class=\"headerlink\" title=\"linux\"></a>linux</h5><p>ps -fe 查看所有进程<br /><br>ps -fT -p  查看某个进程（PID）的所有线程<br /><br>kill 杀死进程<br /><br>top 按大写 H 切换是否显示线程<br /><br>top -H -p  查看某个进程（PID）的所有线程</p>\n<p><a name=\"Java\"></a></p>\n<h5 id=\"Java\"><a href=\"#Java\" class=\"headerlink\" title=\"Java\"></a>Java</h5><p>jps 命令查看所有 Java 进程<br /><br>jstack  查看某个 Java 进程（PID）的所有线程状态<br /><br>jconsole 来查看某个 Java 进程中线程的运行情况（图形界面）</p>\n<p>jconsole 远程监控配置<br /><br>需要以如下方式运行你的 java 类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">java <span class=\"token operator\">-</span><span class=\"token class-name\">Djava</span><span class=\"token punctuation\">.</span>rmi<span class=\"token punctuation\">.</span>server<span class=\"token punctuation\">.</span>hostname<span class=\"token operator\">=</span>`ip地址` <span class=\"token operator\">-</span><span class=\"token class-name\">Dcom</span><span class=\"token punctuation\">.</span>sun<span class=\"token punctuation\">.</span>management<span class=\"token punctuation\">.</span>jmxremote <span class=\"token operator\">-</span>\n<span class=\"token class-name\">Dcom</span><span class=\"token punctuation\">.</span>sun<span class=\"token punctuation\">.</span>management<span class=\"token punctuation\">.</span>jmxremote<span class=\"token punctuation\">.</span>port<span class=\"token operator\">=</span>`连接端口` <span class=\"token operator\">-</span><span class=\"token class-name\">Dcom</span><span class=\"token punctuation\">.</span>sun<span class=\"token punctuation\">.</span>management<span class=\"token punctuation\">.</span>jmxremote<span class=\"token punctuation\">.</span>ssl<span class=\"token operator\">=</span>是否安全连接 <span class=\"token operator\">-</span>\n<span class=\"token class-name\">Dcom</span><span class=\"token punctuation\">.</span>sun<span class=\"token punctuation\">.</span>management<span class=\"token punctuation\">.</span>jmxremote<span class=\"token punctuation\">.</span>authenticate<span class=\"token operator\">=</span>是否认证 java类<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>修改 &#x2F;etc&#x2F;hosts 文件将 127.0.0.1 映射至主机名<br /><br>如果要认证访问，还需要做如下步骤<br /><br>复制 jmxremote.password 文件<br /><br>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写<br /><br>连接时填入 controlRole（用户名），R&amp;D（密码）</p>\n<p><a name=\"95740118\"></a></p>\n<h2 id=\"线程运行原理\"><a href=\"#线程运行原理\" class=\"headerlink\" title=\"线程运行原理\"></a>线程运行原理</h2><h4 id=\"栈与栈帧：\"><a href=\"#栈与栈帧：\" class=\"headerlink\" title=\"栈与栈帧：\"></a>栈与栈帧：</h4><p>JVM中由堆，栈，方法区所组成，其中栈内存就是给线程使用的，每个线程启动后，虚拟机就会为其分配一块栈内存</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">每个栈由多个栈帧组成，对应着每次方法调用所占用的内存\n\n每个线程只能有一个活动栈帧，对应着当前正在执行的方法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"1c2dd30e\"></a></p>\n<h4 id=\"线程上下文切换：\"><a href=\"#线程上下文切换：\" class=\"headerlink\" title=\"线程上下文切换：\"></a>线程上下文切换：</h4><p>从使用CPU到不使用CPU的状态就是一次上下文切换</p>\n<p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">线程的 cpu 时间片用完\n\n垃圾回收\n\n有更高优先级的线程需要运行\n\n线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念<br /><br>就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等\n\nContext Switch 频繁发生会影响性能<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"d41d8cd9\"></a><a name=\"101260cd\"></a></p>\n<h2 id=\"常见方法：\"><a href=\"#常见方法：\" class=\"headerlink\" title=\"常见方法：\"></a>常见方法：</h2><p><a name=\"39884850\"></a></p>\n<h5 id=\"1-start-和-run：\"><a href=\"#1-start-和-run：\" class=\"headerlink\" title=\"1.start 和 run：\"></a>1.start 和 run：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">start()：启动一个新线程，在新的线程运行 run 方法中的代码\n\n**注意：**start 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的start方法只能调用一次，如果调用了多次会出现IllegalThreadStateException\n\nrun()：新线程启动后会调用的方法\n\n如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的 run 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"c3f06b8f\"></a></p>\n<h5 id=\"2-sleep和yield：\"><a href=\"#2-sleep和yield：\" class=\"headerlink\" title=\"2.sleep和yield：\"></a>2.sleep和yield：</h5><pre class=\"line-numbers language-none\"><code class=\"language-none\">sleep\n\n1.调用sleep会让当前线程从Running进入Timed Waiting状态**（阻塞）**\n\n2.其他线程使用interrupt方法打断正在睡眠的线程，此时sleep方法会抛出InterrupedException\n\n3.睡眠结束后的线程未必会立即执行\n\n4.建议使用TimeUnit的sleep代替Thread的sleep来获得更好的可读性\n\nyield\n\n1.调用yield会让当前线程从Running进入Runnable**就绪**状态，然后调度执行其他线程\n\n2.具体的实现依赖于操作系统的任务调度器（可能没有其他线程，调用yield后还是会分给当前线程）<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p><a name=\"9cdb3b71\"></a></p>\n<h5 id=\"区别：\"><a href=\"#区别：\" class=\"headerlink\" title=\"区别：\"></a>区别：</h5><p>操作系统的时间调度器可以将cpu分配给就绪状态的线程，但是不能分配给阻塞状态的线程</p>\n<p><a name=\"c8dc1199\"></a></p>\n<h5 id=\"3-优先级：setPriority-默认为5-范围是1-10\"><a href=\"#3-优先级：setPriority-默认为5-范围是1-10\" class=\"headerlink\" title=\"3.优先级：setPriority() 默认为5 范围是1-10\"></a>3.优先级：setPriority() 默认为5 范围是1-10</h5><p><a name=\"09dbc7a7\"></a></p>\n<h5 id=\"4-join：等待调用join的线程运行结束\"><a href=\"#4-join：等待调用join的线程运行结束\" class=\"headerlink\" title=\"4.join：等待调用join的线程运行结束\"></a>4.join：等待调用join的线程运行结束</h5><p>join可以有参数，表示最多等待的时间（毫秒）</p>\n<p>线程的同步（需要等待结果的返回）</p>\n<p><img src=\"/../assets/1647331167427-6bdded40-f757-403a-aff4-f860aa6651c7.png\" alt=\"1646718430383.png\"></p>\n<p><a name=\"d89d483a\"></a></p>\n<h5 id=\"5-interrupt：打断正在运行的线程\"><a href=\"#5-interrupt：打断正在运行的线程\" class=\"headerlink\" title=\"5.interrupt：打断正在运行的线程\"></a>5.interrupt：打断正在运行的线程</h5><p>打断 sleep，wait，join 的线程会重置打断标记为false</p>\n<p>isInterrupted():可以获取打断标记，正常运行的线程并不会直接被打断，可通过打断标记判断，若被打断则结束线程</p>\n<p>interrupted():判断完是否被打断之后，会清楚打断标记（true-&gt;false）</p>\n<p><a name=\"f5f26a4b\"></a></p>\n<h5 id=\"多线程设计模式之两阶段终止：\"><a href=\"#多线程设计模式之两阶段终止：\" class=\"headerlink\" title=\"多线程设计模式之两阶段终止：\"></a>多线程设计模式之两阶段终止：</h5><p>T1线程‘’优雅的‘’终止线程T2   优雅：给T2一个做其他事情的机会（通过我们写的代码）</p>\n<p><a name=\"963d004e\"></a></p>\n<h5 id=\"错误思路\"><a href=\"#错误思路\" class=\"headerlink\" title=\"错误思路\"></a>错误思路</h5><p><a name=\"be2b094b\"></a></p>\n<h6 id=\"使用线程对象的-stop-方法停止线程\"><a href=\"#使用线程对象的-stop-方法停止线程\" class=\"headerlink\" title=\"使用线程对象的 stop() 方法停止线程\"></a>使用线程对象的 stop() 方法停止线程</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"2bd54a50\"></a></p>\n<h6 id=\"使用-System-exit-int-方法停止线程\"><a href=\"#使用-System-exit-int-方法停止线程\" class=\"headerlink\" title=\"使用 System.exit(int) 方法停止线程\"></a>使用 System.exit(int) 方法停止线程</h6><pre class=\"line-numbers language-none\"><code class=\"language-none\">目的仅是停止一个线程，但这种做法会让整个程序都停止<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p><a name=\"b4852214\"></a></p>\n<h5 id=\"两阶段终止模式：\"><a href=\"#两阶段终止模式：\" class=\"headerlink\" title=\"两阶段终止模式：\"></a>两阶段终止模式：</h5><p><img src=\"/../assets/1647331192919-a234488c-d060-4a08-b75e-aa6399bb5933.png\" alt=\"1646719847015.png\"></p>\n<p><a name=\"fa21b4d0\"></a></p>\n<h5 id=\"6-不推荐使用的方法\"><a href=\"#6-不推荐使用的方法\" class=\"headerlink\" title=\"6.不推荐使用的方法\"></a>6.不推荐使用的方法</h5><p>这些方法已过时，容易破坏同步代码块，造成线程死锁</p>\n<p>stop() \t\t\t\t\t\t停止线程运行</p>\n<p>suspend() \t\t\t\t挂起（暂停）线程运行</p>\n<p>resume() \t\t\t\t\t恢复线程运行</p>\n<p><a name=\"d3f80786\"></a></p>\n<h2 id=\"主线程和守护线程\"><a href=\"#主线程和守护线程\" class=\"headerlink\" title=\"主线程和守护线程\"></a>主线程和守护线程</h2><p>setDaemon(true)：表示为守护线程  \t默认为false</p>\n<p>当主线程结束后。守护线程会被强制结束</p>\n<p>java中垃圾回收器就是一种守护线程</p>\n<p>Tomcat中的Acceptor个Poller线程都是守护线程，所以Tomcat接收到shutdown命令后，不会等待它们处理完当前请求</p>\n<p><a name=\"6368709f\"></a></p>\n<h2 id=\"线程的5种状态：\"><a href=\"#线程的5种状态：\" class=\"headerlink\" title=\"线程的5种状态：\"></a>线程的5种状态：</h2><p>这是从操作系统层面来描述的</p>\n<p><img src=\"/../assets/1647331208969-1bf3b12d-a836-410c-ba27-2ee908fdefa6.png\" alt=\"1646722438520.png\"><br />初始状态：仅在语言层面创建了线程对象，还未与操作系统线程关联</p>\n<p>可运行状态：（就绪状态）指该线程已经被创建（与操作系统线程关联），可由CPU调度执行</p>\n<p>运行状态：指获取了CPU时间片运行中的状态</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">当CPU时间片用完，会从运行状态转换至可运行状态，会导致线程的上下文切换<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>阻塞状态：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">如果调用了阻塞API，比如BIO读写文件，这时该线程实际上不会用到CPU，会导致线程上下文切换，进入阻塞状态\n\n等BIO操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】\n\n与【可运行状态】的区别是，对于阻塞状态的线程来说，只要它们一直不唤醒，调度器就不会考虑它们<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>终止状态：表示线程已经执行完毕，生命周期已经结束，不会再转换为其他状态</p>\n<hr>\n<p>线程的6种状态</p>\n<p>根据Thread State枚举类的描述，进行分类</p>\n<p><img src=\"/../assets/1647331215316-1ef329d5-c656-4931-9009-96408cad09fd.png\" alt=\"1646723788025.png\"></p>\n<p>NEW：线程刚被创建，但是还没调用start()方法</p>\n<p>RUNNABLE：当调用了start()方法之后，java API层面的RUNNABLE状态涵盖了操作系统层面的[可运行状态]，</p>\n<p>[运行状态]、[阻塞状态]（由于BIO导致的线程阻塞，在Java里无法区分，认为是可运行的）</p>\n<p>BLOCKED ， WAITING ， TIMED_WAITING：都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节</p>\n<p>详述</p>\n<p>TERMINATED：当线程代码运行结束</p>\n","text":"java线程 创建和启动线程1.new Thread：public static void test1() &#123; Thread t = new Thread() &#123; //执行的方法 @Override public void run() &#123; log.d...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":10,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#java%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">java线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%9B%E5%BB%BA%E5%92%8C%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">创建和启动线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-new-Thread%EF%BC%9A\"><span class=\"toc-text\">1.new Thread：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-%E4%BD%BF%E7%94%A8Runnable%E9%85%8D%E5%90%88Thread%EF%BC%88%E5%B0%86%E9%9C%80%E8%A6%81%E6%89%A7%E8%A1%8C%E7%9A%84%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%88%86%E7%A6%BB%EF%BC%8C%E6%9B%B4%E7%81%B5%E6%B4%BB%EF%BC%89\"><span class=\"toc-text\">2.使用Runnable配合Thread（将需要执行的任务与创建线程分离，更灵活）</span></a></li></ol></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86%EF%BC%9AThread%E5%92%8CRunnable%E7%9A%84%E5%85%B3%E7%B3%BB\"><span class=\"toc-text\">原理：Thread和Runnable的关系</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93%EF%BC%9A\"><span class=\"toc-text\">总结：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-FutureTask-%E9%85%8D%E5%90%88-Thread\"><span class=\"toc-text\">3.FutureTask 配合 Thread</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">查看进程线程的方法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#windows\"><span class=\"toc-text\">windows</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#linux\"><span class=\"toc-text\">linux</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#Java\"><span class=\"toc-text\">Java</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">线程运行原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7%EF%BC%9A\"><span class=\"toc-text\">栈与栈帧：</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%EF%BC%9A\"><span class=\"toc-text\">线程上下文切换：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">常见方法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#1-start-%E5%92%8C-run%EF%BC%9A\"><span class=\"toc-text\">1.start 和 run：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#2-sleep%E5%92%8Cyield%EF%BC%9A\"><span class=\"toc-text\">2.sleep和yield：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E5%88%AB%EF%BC%9A\"><span class=\"toc-text\">区别：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#3-%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9AsetPriority-%E9%BB%98%E8%AE%A4%E4%B8%BA5-%E8%8C%83%E5%9B%B4%E6%98%AF1-10\"><span class=\"toc-text\">3.优先级：setPriority() 默认为5 范围是1-10</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#4-join%EF%BC%9A%E7%AD%89%E5%BE%85%E8%B0%83%E7%94%A8join%E7%9A%84%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9D%9F\"><span class=\"toc-text\">4.join：等待调用join的线程运行结束</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#5-interrupt%EF%BC%9A%E6%89%93%E6%96%AD%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">5.interrupt：打断正在运行的线程</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%EF%BC%9A\"><span class=\"toc-text\">多线程设计模式之两阶段终止：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E9%94%99%E8%AF%AF%E6%80%9D%E8%B7%AF\"><span class=\"toc-text\">错误思路</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84-stop-%E6%96%B9%E6%B3%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">使用线程对象的 stop() 方法停止线程</span></a></li><li class=\"toc-item toc-level-6\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8-System-exit-int-%E6%96%B9%E6%B3%95%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">使用 System.exit(int) 方法停止线程</span></a></li></ol></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F%EF%BC%9A\"><span class=\"toc-text\">两阶段终止模式：</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#6-%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">6.不推荐使用的方法</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">主线程和守护线程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%845%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A\"><span class=\"toc-text\">线程的5种状态：</span></a></li></ol></li></ol>","author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"synchronized关键字","uid":"e1b3118af0455ea0158a80d4d6b7a3a6","slug":"synchronized关键字","date":"2022-06-11T12:58:01.936Z","updated":"2022-06-11T12:58:35.833Z","comments":true,"path":"api/articles/synchronized关键字.json","keywords":null,"cover":[],"text":" synchronized 解决方案 互斥为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 synchronized，来解决上述问题，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":10,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"进程线程并行并发","uid":"6ce63568dd0197dd5234fafddc6d369d","slug":"进程线程并行并发","date":"2022-06-11T12:36:30.645Z","updated":"2022-06-11T12:49:42.674Z","comments":true,"path":"api/articles/进程线程并行并发.json","keywords":null,"cover":null,"text":" 进程和线程： 进程：资源分配的最小单位程序由指令和数据组成，但这些指令需要运行，数据要读写，就必须将指令加载到CPU，数据加载至内存。在指令运行过程种还须需要用到磁盘，网络等设备。进程就是用来加载指令，管理内存，管理IO的 当一个程序被运行，从磁盘加载这个程序的代码到内存种，这...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"JUC","slug":"JUC","count":7,"path":"api/categories/JUC.json"}],"tags":[{"name":"JUC","slug":"JUC","count":7,"path":"api/tags/JUC.json"},{"name":"java","slug":"java","count":10,"path":"api/tags/java.json"},{"name":"多线程","slug":"多线程","count":7,"path":"api/tags/多线程.json"}],"author":{"name":"小李不在_","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/20210313122054101.png","link":"/","description":"<b>Welcome</b> <br />  <b>qq：3163678221</b><br />  <b>河北工程大学</b>","socials":{"github":"https://github.com/limingzhi666","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}